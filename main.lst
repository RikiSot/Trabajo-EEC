CCS PCD C Compiler, Version 5.091, 43599               27-ene.-21 21:19

               Filename:   F:\Industriales\Especialidad\SDM\Trabajo-EEC\main.lst

               ROM used:   8494 bytes (10%)
                           Largest free fragment is 57042
               RAM used:   2883 (18%) at main() level
                           2996 (18%) worst case
               Stack used: 90 locations (34 in main + 56 for interrupts)
               Stack size: 176

00000:  GOTO    1F0E
*
00022:  DATA    08,07,00
*
0004A:  DATA    A0,02,00
0004C:  DATA    2E,07,00
.................... /**
....................  @file    main.c
....................  @author  Ricardo Gomez, Klaudija Ziliute
.................... 
....................  @brief   main EEC
.................... */
.................... 
.................... /* SECTION 1: Included header files to compile this file           */
.................... #include "33FJ128MC804.h"
.................... 
.................... #ifndef LIB_h
.................... #define LIB_h
.................... 
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device DSPIC33FJ128MC804
*
00200:  CLR     32
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    53,46,00
0020E:  DATA    2C,31,00
00210:  DATA    0D,00,00
00212:  CLR     32
00214:  MOV     #21E,W3
00216:  ADD     W3,W0,W0
00218:  TBLRDL.B[W0],W0L
0021A:  CLR.B   1
0021C:  RETURN  
0021E:  DATA    53,41,00
00220:  DATA    2C,30,00
00222:  DATA    0D,00,00
00224:  CLR     32
00226:  MOV     #230,W3
00228:  ADD     W3,W0,W0
0022A:  TBLRDL.B[W0],W0L
0022C:  CLR.B   1
0022E:  RETURN  
00230:  DATA    52,2C,00
00232:  DATA    31,0D,00
00234:  DATA    00,00,00
00236:  CLR     32
00238:  MOV     #242,W3
0023A:  ADD     W3,W0,W0
0023C:  TBLRDL.B[W0],W0L
0023E:  CLR.B   1
00240:  RETURN  
00242:  DATA    24,52,00
00244:  DATA    65,70,00
00246:  DATA    72,65,00
00248:  DATA    73,65,00
0024A:  DATA    6E,74,00
0024C:  DATA    61,63,00
0024E:  DATA    69,6F,00
00250:  DATA    6E,20,00
00252:  DATA    67,72,00
00254:  DATA    61,66,00
00256:  DATA    69,63,00
00258:  DATA    61,2C,00
0025A:  DATA    46,75,00
0025C:  DATA    6E,63,00
0025E:  DATA    69,6F,00
00260:  DATA    6E,2C,00
00262:  DATA    64,61,00
00264:  DATA    74,6F,00
00266:  DATA    73,20,00
00268:  DATA    31,0A,00
0026A:  DATA    00,00,00
0026C:  CLR     32
0026E:  MOV     #278,W3
00270:  ADD     W3,W0,W0
00272:  TBLRDL.B[W0],W0L
00274:  CLR.B   1
00276:  RETURN  
00278:  DATA    26,30,00
0027A:  DATA    2C,32,00
0027C:  DATA    35,30,00
0027E:  DATA    2C,30,00
00280:  DATA    2C,31,00
00282:  DATA    2C,30,00
00284:  DATA    0A,00,00
00286:  CLR     32
00288:  MOV     #292,W3
0028A:  ADD     W3,W0,W0
0028C:  TBLRDL.B[W0],W0L
0028E:  CLR.B   1
00290:  RETURN  
00292:  DATA    23,30,00
00294:  DATA    2C,32,00
00296:  DATA    35,30,00
00298:  DATA    2C,30,00
0029A:  DATA    2C,31,00
0029C:  DATA    2C,30,00
0029E:  DATA    0A,00,00
*
002EA:  MOV     W5,[W15++]
002EC:  MOV     W6,[W15++]
002EE:  MOV     #8E,W1
002F0:  CP0     W0
002F2:  BRA     Z,318
002F4:  BTSC    W0.F
002F6:  BRA     300
002F8:  BCLR.B  42.0
002FA:  RLC     W0,W0
002FC:  DEC     W1,W1
002FE:  BRA     2F4
00300:  SWAP    W1
00302:  BCLR.B  42.0
00304:  RRC     W1,W1
00306:  BCLR    W0.F
00308:  SWAP    W0
0030A:  XOR.B   W0L,W1L,W1L
0030C:  AND.B   #0,W0L
0030E:  BRA     31E
00310:  MOV.B   W1L,W0L
00312:  BSET    W1.7
00314:  AND.B   #0,W1L
00316:  BRA     31E
00318:  CLR     W0
0031A:  CLR     W1
0031C:  BRA     31E
0031E:  MOV     [--W15],W6
00320:  MOV     [--W15],W5
00322:  RETURN  
00324:  MOV     W5,[W15++]
00326:  MOV     W6,[W15++]
00328:  MOV     W7,[W15++]
0032A:  XOR     W1,W3,W4
0032C:  BTSS    W4.F
0032E:  BRA     33C
00330:  BCLR.B  42.0
00332:  BCLR.B  42.1
00334:  BTSS    W1.F
00336:  BRA     384
00338:  BSET.B  42.0
0033A:  BRA     384
0033C:  MOV     W1,W4
0033E:  MOV     W0,W5
00340:  MOV     W3,W6
00342:  MOV     W2,W7
00344:  RLC     W1,W1
00346:  SWAP    W1
00348:  RLC     W3,W3
0034A:  SWAP    W3
0034C:  SUB.B   W3L,W1L,W1L
0034E:  BRA     Z,35A
00350:  BTSS    W4.F
00352:  BRA     384
00354:  MOV     #1,W0
00356:  XOR.B   42
00358:  BRA     384
0035A:  MOV.B   W4L,W1L
0035C:  MOV.B   W6L,W3L
0035E:  BCLR    W1.7
00360:  BCLR    W3.7
00362:  SUB.B   W3L,W1L,W1L
00364:  BRA     Z,370
00366:  BTSS    W4.F
00368:  BRA     384
0036A:  MOV     #1,W0
0036C:  XOR.B   42
0036E:  BRA     384
00370:  SUB     W7,W5,W1
00372:  BRA     Z,37E
00374:  BTSS    W4.F
00376:  BRA     384
00378:  MOV     #1,W0
0037A:  XOR.B   42
0037C:  BRA     384
0037E:  BCLR.B  42.0
00380:  BRA     384
00382:  BRA     384
00384:  MOV     [--W15],W7
00386:  MOV     [--W15],W6
00388:  MOV     [--W15],W5
0038A:  RETURN  
*
003A4:  MOV     W5,[W15++]
003A6:  MOV     #C,W5
003A8:  REPEAT  #4
003AA:  MOV     [W5++],[W15++]
003AC:  CLR     W9
003AE:  XOR     W1,W3,W9
003B0:  MOV     W1,W6
003B2:  MOV     W0,W5
003B4:  MOV     W3,W8
003B6:  MOV     W2,W7
003B8:  RLC     W1,W1
003BA:  SWAP    W1
003BC:  ZE      W1,W1
003BE:  CP0     W1
003C0:  BRA     Z,45E
003C2:  RLC     W3,W3
003C4:  SWAP    W3
003C6:  ZE      W3,W3
003C8:  CP0     W3
003CA:  BRA     Z,45E
003CC:  CLR     W0
003CE:  SUB.B   W1L,W3L,W0L
003D0:  BRA     NC,3D8
003D2:  ADD.B   #7F,W0L
003D4:  BRA     C,45E
003D6:  BRA     3DE
003D8:  SUB.B   #81,W0L
003DA:  BRA     NC,45E
003DC:  BRA     Z,45E
003DE:  MOV     W5,W1
003E0:  MOV     W6,W2
003E2:  BSET    W2.7
003E4:  AND     #FF,W2
003E6:  AND     #FF,W8
003E8:  BSET    W8.7
003EA:  MOV     #19,W10
003EC:  CLR     W3
003EE:  CLR     W4
003F0:  SUB     W1,W7,W1
003F2:  SUBB    W2,W8,W2
003F4:  BRA     N,3FA
003F6:  BRA     C,400
003F8:  BRA     NZ,402
003FA:  ADD     W1,W7,W1
003FC:  ADDC    W2,W8,W2
003FE:  BRA     402
00400:  BSET    W4.0
00402:  DEC     W10,W10
00404:  BRA     Z,414
00406:  BCLR.B  42.0
00408:  RLC     W1,W1
0040A:  RLC     W2,W2
0040C:  BCLR.B  42.0
0040E:  RLC     W4,W4
00410:  RLC     W3,W3
00412:  BRA     3F0
00414:  CLR     W10
00416:  BTSC    W3.8
00418:  BRA     41C
0041A:  BRA     428
0041C:  BCLR.B  42.0
0041E:  RRC     W3,W3
00420:  BCLR    W3.7
00422:  RRC     W4,W4
00424:  RLC     W10,W10
00426:  BRA     42C
00428:  DEC     W0,W0
0042A:  BRA     Z,45E
0042C:  BTSC    W10.F
0042E:  BRA     NC,43A
00430:  RLC     W1,W1
00432:  RLC     W2,W2
00434:  SUB     W1,W7,W1
00436:  SUBB    W2,W8,W2
00438:  BRA     NC,44C
0043A:  INC     W4,W4
0043C:  BRA     NZ,44C
0043E:  INC     W3,W3
00440:  BRA     NZ,44C
00442:  INC     W0,W0
00444:  BRA     Z,45E
00446:  BRA     44C
00448:  DEC     W0,W0
0044A:  BRA     Z,45E
0044C:  SWAP    W0
0044E:  RRC     W0,W1
00450:  BSET    W1.F
00452:  BTSS    W9.F
00454:  BCLR    W1.F
00456:  BCLR    W3.7
00458:  XOR.B   W3L,W1L,W1L
0045A:  MOV     W4,W0
0045C:  BRA     464
0045E:  MOV     #0,W0
00460:  MOV     #0,W1
00462:  BRA     464
00464:  MOV     #14,W5
00466:  REPEAT  #4
00468:  MOV     [--W15],[W5--]
0046A:  MOV     [--W15],W5
0046C:  RETURN  
0046E:  MOV     W5,[W15++]
00470:  MOV     #C,W5
00472:  REPEAT  #3
00474:  MOV     [W5++],[W15++]
00476:  CLR     W9
00478:  MOV     #8000,W8
0047A:  BTSC.B  43.0
0047C:  XOR     W8,W3,W3
0047E:  CP0     W0
00480:  BRA     NZ,488
00482:  MOV     #7FFF,W10
00484:  AND     W1,W10,W10
00486:  BTSS.B  42.1
00488:  MOV     W1,W10
0048A:  XOR     W3,W10,W11
0048C:  MOV     W1,W6
0048E:  MOV     W3,W7
00490:  MOV     W3,W12
00492:  BCLR.B  42.1
00494:  BCLR.B  42.0
00496:  RLC     W6,W6
00498:  SWAP    W6
0049A:  AND     #FF,W6
0049C:  CP0     W6
0049E:  BRA     Z,5E2
004A0:  BCLR.B  42.1
004A2:  BCLR.B  42.0
004A4:  RLC     W7,W7
004A6:  SWAP    W7
004A8:  AND     #FF,W7
004AA:  CP0     W7
004AC:  BRA     Z,5EC
004AE:  BCLR.B  42.1
004B0:  BCLR.B  42.0
004B2:  CP      W7,W6
004B4:  BRA     Z,5EE
004B6:  BRA     N,5FE
004B8:  BCLR    W9.0
004BA:  BSET    W9.1
004BC:  SUB     W7,W6,W8
004BE:  MOV     W7,W6
004C0:  AND     #FF,W1
004C2:  BSET    W1.7
004C4:  AND     #FF,W3
004C6:  BSET    W3.7
004C8:  MOV     #28,W7
004CA:  CP      W7,W8
004CC:  BRA     N,4F0
004CE:  BCLR.B  42.1
004D0:  BCLR.B  42.0
004D2:  RRC     W1,W1
004D4:  RRC     W0,W0
004D6:  DEC     W8,W8
004D8:  BRA     NZ,4CE
004DA:  BRA     4F6
004DC:  MOV     #28,W7
004DE:  CP      W7,W8
004E0:  BRA     N,4F4
004E2:  BCLR.B  42.1
004E4:  BCLR.B  42.0
004E6:  RRC     W3,W3
004E8:  RRC     W2,W2
004EA:  DEC     W8,W8
004EC:  BRA     NZ,4E2
004EE:  BRA     50E
004F0:  MOV     W2,W0
004F2:  MOV     W3,W1
004F4:  BRA     57C
004F6:  BTSS    W11.F
004F8:  BRA     51C
004FA:  BTSC    W9.4
004FC:  MOV     W12,W11
004FE:  NEG     W0,W0
00500:  BRA     Z,506
00502:  COM.B   W1L,W1L
00504:  BRA     508
00506:  NEG     W1,W1
00508:  BTSC    W9.4
0050A:  BRA     562
0050C:  BRA     51C
0050E:  BTSS    W11.F
00510:  BRA     51C
00512:  NEG     W2,W2
00514:  BRA     Z,51A
00516:  COM.B   W3L,W3L
00518:  BRA     51C
0051A:  NEG     W3,W3
0051C:  AND     #FF,W5
0051E:  BCLR.B  42.1
00520:  BCLR.B  42.0
00522:  ADD     W0,W2,W0
00524:  ADDC.B  W1L,W3L,W1L
00526:  BTSC.B  42.0
00528:  BSET    W9.3
0052A:  BTSC    W9.0
0052C:  BRA     540
0052E:  BTSC    W9.1
00530:  BRA     534
00532:  BRA     54A
00534:  BTSC    W11.F
00536:  BRA     562
00538:  BTSC    W9.3
0053A:  BRA     58E
0053C:  BSET    W9.6
0053E:  BRA     57C
00540:  BTSC    W11.F
00542:  BRA     562
00544:  BTSC    W9.3
00546:  BRA     58E
00548:  BRA     57C
0054A:  BCLR    W9.2
0054C:  BTSC    W11.F
0054E:  BRA     558
00550:  MOV     W10,W11
00552:  BTSC    W9.3
00554:  BRA     58E
00556:  BRA     5C4
00558:  BSET    W9.4
0055A:  XOR.B   #80,W1L
0055C:  BTSC    W1.7
0055E:  BRA     4FA
00560:  MOV     W10,W11
00562:  AND     #FF,W1
00564:  IOR      W0,  W1,W7
00566:  BRA     Z,57C
00568:  BTSC    W1.7
0056A:  BRA     57C
0056C:  BCLR.B  42.1
0056E:  BCLR.B  42.0
00570:  RLC     W0,W0
00572:  RLC     W1,W1
00574:  DEC     W6,W6
00576:  BTSC.B  42.1
00578:  BRA     5DC
0057A:  BRA     568
0057C:  BTSC    W9.0
0057E:  MOV     W10,W11
00580:  BTSC    W9.1
00582:  MOV     W12,W11
00584:  BTSS    W9.5
00586:  BRA     5BC
00588:  BTSC    W10.F
0058A:  BSET    W0.8
0058C:  BRA     5C4
0058E:  BSET.B  42.0
00590:  RRC.B   W1L,W1L
00592:  RRC     W0,W0
00594:  BTSC.B  42.0
00596:  BSET    W9.5
00598:  INC     W6,W6
0059A:  BRA     Z,5DC
0059C:  BTSS    W9.5
0059E:  BRA     5B0
005A0:  INC     W0,W0
005A2:  BRA     NZ,5B0
005A4:  INC.B   W1L,W1L
005A6:  BRA     NZ,5B0
005A8:  RRC.B   W1L,W1L
005AA:  RRC     W0,W0
005AC:  INC     W6,W6
005AE:  BRA     Z,5DC
005B0:  BTSC    W9.0
005B2:  MOV     W10,W11
005B4:  BTSC    W9.1
005B6:  MOV     W12,W11
005B8:  BTSC.B  42.1
005BA:  BRA     5DC
005BC:  BTSC    W9.6
005BE:  MOV     W10,W11
005C0:  BTSC    W9.7
005C2:  MOV     W12,W11
005C4:  IOR      W0,  W1,W2
005C6:  BRA     Z,60E
005C8:  BCLR    W1.7
005CA:  SWAP    W6
005CC:  BCLR.B  42.1
005CE:  BCLR.B  42.0
005D0:  RRC     W6,W6
005D2:  XOR     W6,W1,W1
005D4:  BSET    W1.F
005D6:  BTSS    W11.F
005D8:  BCLR    W1.F
005DA:  BRA     60E
005DC:  MOV     #0,W0
005DE:  MOV     #0,W1
005E0:  BRA     60E
005E2:  BTSC    W10.F
005E4:  XOR     W8,W3,W3
005E6:  MOV     W2,W0
005E8:  MOV     W3,W1
005EA:  BRA     60E
005EC:  BRA     60E
005EE:  AND     #FF,W3
005F0:  BSET    W3.7
005F2:  AND     #FF,W1
005F4:  BSET    W1.7
005F6:  BTSC    W11.F
005F8:  BCLR    W3.7
005FA:  BSET    W9.2
005FC:  BRA     50E
005FE:  SUB     W6,W7,W8
00600:  AND     #FF,W1
00602:  BSET    W1.7
00604:  AND     #FF,W3
00606:  BSET    W3.7
00608:  BCLR    W9.1
0060A:  BSET    W9.0
0060C:  BRA     4DC
0060E:  MOV     #12,W5
00610:  REPEAT  #3
00612:  MOV     [--W15],[W5--]
00614:  MOV     [--W15],W5
00616:  RETURN  
*
00EA0:  MOV     W5,[W15++]
00EA2:  MOV     #C,W5
00EA4:  REPEAT  #3
00EA6:  MOV     [W5++],[W15++]
00EA8:  MOV     #0,W9
00EAA:  BTSC.B  43.0
00EAC:  MOV     #1,W9
00EAE:  MOV     W9,[W15++]
00EB0:  CLR     W4
00EB2:  CLR     W5
00EB4:  CLR     W6
00EB6:  CLR     W7
00EB8:  XOR     W2,W3,W8
00EBA:  BRA     Z,EDE
00EBC:  MOV     #20,W8
00EBE:  BCLR.B  42.0
00EC0:  RLC     W0,W0
00EC2:  RLC     W1,W1
00EC4:  RLC     W4,W4
00EC6:  RLC     W5,W5
00EC8:  CP      W5,W3
00ECA:  BRA     NZ,ECE
00ECC:  CPB     W4,W2
00ECE:  BRA     NC,ED6
00ED0:  SUB     W4,W2,W4
00ED2:  SUBB    W5,W3,W5
00ED4:  BSET.B  42.0
00ED6:  RLC     W6,W6
00ED8:  RLC     W7,W7
00EDA:  DEC     W8,W8
00EDC:  BRA     NZ,EBE
00EDE:  MOV     W7,W1
00EE0:  MOV     W6,W0
00EE2:  MOV     [--W15],W9
00EE4:  CP0     W9
00EE6:  BRA     Z,EEA
00EE8:  MOV.D   W4,W0
00EEA:  MOV     #12,W5
00EEC:  REPEAT  #3
00EEE:  MOV     [--W15],[W5--]
00EF0:  MOV     [--W15],W5
00EF2:  RETURN  
*
0109E:  MOV     W5,[W15++]
010A0:  MOV     #C,W5
010A2:  REPEAT  #3
010A4:  MOV     [W5++],[W15++]
010A6:  MUL.UU  W0,W2,W4
010A8:  MUL.UU  W0,W3,W6
010AA:  BCLR.B  42.0
010AC:  ADD     W6,W5,W5
010AE:  ADDC    W7,#0,W8
010B0:  MUL.UU  W1,W2,W6
010B2:  ADDC    W6,W5,W5
010B4:  ADDC    W7,W8,W8
010B6:  MUL.UU  W1,W3,W6
010B8:  ADD     W6,W8,W8
010BA:  ADDC    #0,W7
010BC:  MOV     W7,W3
010BE:  MOV     W8,W2
010C0:  MOV     W5,W1
010C2:  MOV     W4,W0
010C4:  MOV     #12,W5
010C6:  REPEAT  #3
010C8:  MOV     [--W15],[W5--]
010CA:  MOV     [--W15],W5
010CC:  RETURN  
*
01A04:  MOV     W1,[W15++]
01A06:  MOV     12DC,W1
01A08:  MOV.B   W0L,[W1++]
01A0A:  CLR.B   [W1]
01A0C:  MOV     [--W15],W1
01A0E:  INC     12DC
01A10:  RETURN  
01A12:  MOV     W5,[W15++]
01A14:  MOV     #C,W5
01A16:  REPEAT  #3
01A18:  MOV     [W5++],[W15++]
01A1A:  BTSS    W0.F
01A1C:  BRA     1A3C
01A1E:  NEG     W0,W0
01A20:  BSET    W4.8
01A22:  BTSS    W4.F
01A24:  BRA     1A3C
01A26:  MOV     W0,[W15++]
01A28:  MOV     #2D,W0
01A2A:  MOV     W4,[W15++]
01A2C:  MOV     W0,[W15++]
01A2E:  MOV     [--W15],W0
01A30:  CALL    1A04
*
01A34:  MOV     [--W15],W4
01A36:  MOV     [--W15],W0
01A38:  BCLR    W4.8
01A3A:  DEC.B   0008
01A3C:  CLR     W5
01A3E:  MOV     W0,W7
01A40:  MOV     W4,W9
01A42:  BCLR    W4.F
01A44:  CP0.B   W4L
01A46:  BRA     NZ,1A54
01A48:  BTSC    W9.F
01A4A:  BRA     1A50
01A4C:  MOV     #0,W5
01A4E:  BRA     1A7E
01A50:  MOV     #0,W5
01A52:  BRA     1A7E
01A54:  BTSS    W9.8
01A56:  SUB.B   W4L,#6,W5L
01A58:  BTSC    W9.8
01A5A:  SUB.B   W4L,#7,W5L
01A5C:  BRA     NC,1A7C
01A5E:  MOV     #30,W0
01A60:  BTSS    W9.F
01A62:  MOV     #20,W0
01A64:  MOV     W0,[W15++]
01A66:  MOV     W4,[W15++]
01A68:  MOV     W0,[W15++]
01A6A:  MOV     [--W15],W0
01A6C:  CALL    1A04
*
01A70:  MOV     [--W15],W4
01A72:  MOV     [--W15],W0
01A74:  DEC     W5,W5
01A76:  BRA     NN,1A64
01A78:  MOV     #5,W5
01A7A:  BRA     1A7E
01A7C:  MOV     W4,W5
01A7E:  MOV     #6,W4
01A80:  BTSC    W5.8
01A82:  INC     W4,W4
01A84:  BSET    W5.E
01A86:  BTSC    W9.F
01A88:  BSET    W5.F
01A8A:  MOV     #2710,W8
01A8C:  REPEAT  #11
01A8E:  DIV.U   W7,W8
01A90:  CALL    1AE4
*
01A94:  MOV     W1,W7
01A96:  MOV     #3E8,W8
01A98:  REPEAT  #11
01A9A:  DIV.U   W7,W8
01A9C:  CALL    1AE4
*
01AA0:  MOV     W1,W7
01AA2:  MOV     #64,W8
01AA4:  REPEAT  #11
01AA6:  DIV.U   W7,W8
01AA8:  CALL    1AE4
*
01AAC:  MOV     W1,W7
01AAE:  MOV     #A,W8
01AB0:  REPEAT  #11
01AB2:  DIV.U   W7,W8
01AB4:  CALL    1AE4
*
01AB8:  BTSS    W9.8
01ABA:  BRA     1AD0
01ABC:  MOV     #2D,W0
01ABE:  MOV     W1,[W15++]
01AC0:  MOV     W4,[W15++]
01AC2:  MOV     W0,[W15++]
01AC4:  MOV     [--W15],W0
01AC6:  CALL    1A04
*
01ACA:  MOV     [--W15],W4
01ACC:  MOV     [--W15],W1
01ACE:  BCLR    W9.8
01AD0:  MOV     #30,W0
01AD2:  ADD.B   W1L,W0L,W0L
01AD4:  MOV     W0,2A
01AD6:  MOV     W4,[W15++]
01AD8:  MOV     W0,[W15++]
01ADA:  MOV     [--W15],W0
01ADC:  CALL    1A04
*
01AE0:  MOV     [--W15],W4
01AE2:  BRA     1B38
01AE4:  MOV     #30,W6
01AE6:  CP0     W0
01AE8:  BRA     NZ,1B06
01AEA:  BTSS    W5.E
01AEC:  BRA     1B24
01AEE:  DEC     W4,W4
01AF0:  CP.B    W4L,W5L
01AF2:  BRA     Z,1AF8
01AF4:  BTSC.B  42.0
01AF6:  RETURN  
01AF8:  CP0     W0
01AFA:  BRA     NZ,1B06
01AFC:  BTSS    W5.E
01AFE:  BRA     1B24
01B00:  BTSS    W5.F
01B02:  MOV     #20,W6
01B04:  BRA     1B24
01B06:  BCLR    W5.E
01B08:  BTSS    W9.8
01B0A:  BRA     1B24
01B0C:  MOV     W0,W10
01B0E:  MOV     #2D,W0
01B10:  MOV     W1,[W15++]
01B12:  MOV     W4,[W15++]
01B14:  MOV     W0,[W15++]
01B16:  MOV     [--W15],W0
01B18:  CALL    1A04
*
01B1C:  MOV     [--W15],W4
01B1E:  MOV     [--W15],W1
01B20:  BCLR    W9.8
01B22:  MOV     W10,W0
01B24:  ADD.B   W6L,W0L,W0L
01B26:  MOV     W1,[W15++]
01B28:  MOV     W4,[W15++]
01B2A:  MOV     W0,[W15++]
01B2C:  MOV     [--W15],W0
01B2E:  CALL    1A04
*
01B32:  MOV     [--W15],W4
01B34:  MOV     [--W15],W1
01B36:  RETURN  
01B38:  MOV     #12,W5
01B3A:  REPEAT  #3
01B3C:  MOV     [--W15],[W5--]
01B3E:  MOV     [--W15],W5
01B40:  RETURN  
01B42:  MOV     W5,[W15++]
01B44:  MOV     #C,W5
01B46:  REPEAT  #3
01B48:  MOV     [W5++],[W15++]
01B4A:  BTSS    W0.F
01B4C:  BRA     1B66
01B4E:  NEG     W0,W0
01B50:  BSET    W4.8
01B52:  BTSS    W4.F
01B54:  BRA     1B66
01B56:  MOV     W0,[W15++]
01B58:  MOV     #2D,W0
01B5A:  BTSC.B  223.1
01B5C:  BRA     1B5A
01B5E:  MOV     W0,224
01B60:  MOV     [--W15],W0
01B62:  BCLR    W4.8
01B64:  DEC.B   0008
01B66:  CLR     W5
01B68:  MOV     W0,W7
01B6A:  MOV     W4,W9
01B6C:  BCLR    W4.F
01B6E:  CP0.B   W4L
01B70:  BRA     NZ,1B7E
01B72:  BTSC    W9.F
01B74:  BRA     1B7A
01B76:  MOV     #0,W5
01B78:  BRA     1BA2
01B7A:  MOV     #0,W5
01B7C:  BRA     1BA2
01B7E:  BTSS    W9.8
01B80:  SUB.B   W4L,#6,W5L
01B82:  BTSC    W9.8
01B84:  SUB.B   W4L,#7,W5L
01B86:  BRA     NC,1BA0
01B88:  MOV     #30,W0
01B8A:  BTSS    W9.F
01B8C:  MOV     #20,W0
01B8E:  MOV     W0,[W15++]
01B90:  BTSC.B  223.1
01B92:  BRA     1B90
01B94:  MOV     W0,224
01B96:  MOV     [--W15],W0
01B98:  DEC     W5,W5
01B9A:  BRA     NN,1B8E
01B9C:  MOV     #5,W5
01B9E:  BRA     1BA2
01BA0:  MOV     W4,W5
01BA2:  MOV     #6,W4
01BA4:  BTSC    W5.8
01BA6:  INC     W4,W4
01BA8:  BSET    W5.E
01BAA:  BTSC    W9.F
01BAC:  BSET    W5.F
01BAE:  MOV     #2710,W8
01BB0:  REPEAT  #11
01BB2:  DIV.U   W7,W8
01BB4:  CALL    1BF8
*
01BB8:  MOV     W1,W7
01BBA:  MOV     #3E8,W8
01BBC:  REPEAT  #11
01BBE:  DIV.U   W7,W8
01BC0:  CALL    1BF8
*
01BC4:  MOV     W1,W7
01BC6:  MOV     #64,W8
01BC8:  REPEAT  #11
01BCA:  DIV.U   W7,W8
01BCC:  CALL    1BF8
*
01BD0:  MOV     W1,W7
01BD2:  MOV     #A,W8
01BD4:  REPEAT  #11
01BD6:  DIV.U   W7,W8
01BD8:  CALL    1BF8
*
01BDC:  BTSS    W9.8
01BDE:  BRA     1BEA
01BE0:  MOV     #2D,W0
01BE2:  BTSC.B  223.1
01BE4:  BRA     1BE2
01BE6:  MOV     W0,224
01BE8:  BCLR    W9.8
01BEA:  MOV     #30,W0
01BEC:  ADD.B   W1L,W0L,W0L
01BEE:  MOV     W0,2A
01BF0:  BTSC.B  223.1
01BF2:  BRA     1BF0
01BF4:  MOV     W0,224
01BF6:  BRA     1C38
01BF8:  MOV     #30,W6
01BFA:  CP0     W0
01BFC:  BRA     NZ,1C1A
01BFE:  BTSS    W5.E
01C00:  BRA     1C2E
01C02:  DEC     W4,W4
01C04:  CP.B    W4L,W5L
01C06:  BRA     Z,1C0C
01C08:  BTSC.B  42.0
01C0A:  RETURN  
01C0C:  CP0     W0
01C0E:  BRA     NZ,1C1A
01C10:  BTSS    W5.E
01C12:  BRA     1C2E
01C14:  BTSS    W5.F
01C16:  MOV     #20,W6
01C18:  BRA     1C2E
01C1A:  BCLR    W5.E
01C1C:  BTSS    W9.8
01C1E:  BRA     1C2E
01C20:  MOV     W0,W10
01C22:  MOV     #2D,W0
01C24:  BTSC.B  223.1
01C26:  BRA     1C24
01C28:  MOV     W0,224
01C2A:  BCLR    W9.8
01C2C:  MOV     W10,W0
01C2E:  ADD.B   W6L,W0L,W0L
01C30:  BTSC.B  223.1
01C32:  BRA     1C30
01C34:  MOV     W0,224
01C36:  RETURN  
01C38:  MOV     #12,W5
01C3A:  REPEAT  #3
01C3C:  MOV     [--W15],[W5--]
01C3E:  MOV     [--W15],W5
01C40:  RETURN  
.................... 
.................... #list
.................... 
.................... #endif
.................... 
.................... #include <common.h>
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "Header.h"
.................... #ifndef Header_h
.................... #define Header_h
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses HS
.................... #fuses PR
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock= 11059200)
*
00750:  CP0     W0
00752:  BTSC.B  42.1
00754:  BRA     75E
00756:  REPEAT  #1595
00758:  NOP     
0075A:  DEC     W0,W0
0075C:  BRA     NZ,756
0075E:  RETURN  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON( pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define III            PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		   PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDO1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDI1 =     PIN_B7  //                    (43)
.................... #define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "Header.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "algoritmo.h"
.................... #include "miFAT.h"
.................... #include "sdcard.h"
.................... #include "BLUETOOTH.h"
.................... #include "BEEP.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void) //por comprobar en la placa
.................... {
....................     output_high(BTCM);
*
01788:  BCLR.B  2C1.0
0178A:  BSET.B  2C5.0
....................     setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_31);
0178C:  MOV     #9F00,W4
0178E:  MOV     W4,324
01790:  MOV     #86E0,W4
01792:  MOV     W4,320
....................     setup_adc_ports(sAN4, VSS_VDD);
01794:  MOV     #FFEF,W4
01796:  MOV     W4,32C
01798:  CLR     322
....................     set_adc_channel(4);
0179A:  MOV     #4,W4
0179C:  MOV     W4,328
0179E:  RETURN  
.................... //   setup_timer3(TMR_INTERNAL, 18425); //  200 Hz. Ty/2/18425
.................... //   ADC1CON2 = 0b0000000000000000; // voltage reference en ADC1CON2
.................... //   ADC1CON3 = 0b1000000000000000; // select the analog conversion clock <7:0> y <15> para enable Tad
.................... //   AD1PCFGL = 0b1111111111111110; // AN1 entrada analogica - RB1 - PGC en placa
.................... //   AD1CHS0  = 0b0000000100000001; // AN1 entrada seleccionada para el CH0
.................... //   AD1PCFGL = 0b0000000011110111; // AN4 entrada analogica - RB1 - PGC en placa
.................... //   AD1CHS0  = 0b0000010000000100; // AN4 entrada seleccionada para el CH0
.................... //
.................... //   ADC1CON1 = 0b1011010101000110; // 12 bits - Signed Integer - <7:5> 010 Timer3 for ADC1 - <15> Sampling inmediatly after EOC <9:0> unsigned int
.................... 
.................... }
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "lcd.h"
.................... /**
....................  @file    lcd.h
....................  @author  Ricardo Gï¿½mez
....................  @brief   LCD management
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __LCD_H
.................... #define __LCD_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "Header.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "algoritmo.h"
.................... #include "miFAT.h"
.................... #include "sdcard.h"
.................... #include "BLUETOOTH.h"
.................... #include "BEEP.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... /* SECTION 1: Included header files to compile this file           */
.................... 
.................... /* SECTION 2: Public macros                                        */
.................... 
.................... #define _CLEAR_DISPLAY 				0x01
.................... #define _8BIT_4LINES_NORMAL_RE1_IS0		0x3A
.................... #define _8BIT_4LINES_REVERSE_RE1_IS0		0x3B
.................... #define _8BIT_4LINES_RE0_IS1			0x39
.................... #define _8BIT_4LINES_RE0_IS0			0x38
.................... 
.................... #define _BS1_1					0x1E
.................... #define _POWER_DOWN_DISABLE			0x02
.................... #define _SEGMENT_NORMAL_WAY			0x05
.................... #define _NW					0x09
.................... 
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_ON		0x0F
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_OFF		0x0E
.................... #define _DISPLAY_ON_CURSOR_OFF_BLINK_OFF	0x0C
.................... #define _BS0_1					0x1C
.................... #define _INTERNAL_DIVIDER			0x13
.................... #define _CONTRAST				0x77
.................... #define _POWER_ICON_CONTRAST			0x5C
.................... #define _FOLLOWER_CONTROL			0x6E
.................... 
.................... #define ADDRESS_DDRAM				0x80
.................... 
.................... 
.................... /* SECTION 3: Public types                                         */
.................... 
.................... 
.................... /* SECTION 4: Public variables :: declarations, extern mandatory   */
.................... 
.................... 
.................... /* SECTION 5: Public functions :: declarations, extern optional
....................    Rule exception (callbacks)  :: declarations, extern recommended */
.................... void display_valueADC_title(void);
.................... void LCD_command(unsigned int8);
.................... void lcdi2cinit(void);
.................... void LCD_write(char*);
.................... void initmenu(void);                                      //Inicializa el menu principal
.................... void display_frecuencia(void);       // Muestra frecuencia
.................... void LCD_cursor_at(unsigned int8 line, unsigned int8 column);
.................... void display_alarma_alto(void); // Limpia pantalla y escribe mensaje de alarma
.................... void display_alarma_bajo(void);
.................... void display_final(void);
.................... void display_electrodo_suelto(void);
.................... void display_electrodo_recuperado(void);
.................... 
.................... 
.................... void lcdi2cinit(void)
.................... {
.................... 
....................   OFF(SD);
*
015DA:  BCLR.B  2D0.1
015DC:  BCLR.B  2D4.1
....................   delay_ms(200);
015DE:  MOV     #C8,W0
015E0:  CALL    750
....................   ON(PIN_C1);
*
015E4:  BCLR.B  2D0.1
015E6:  BSET.B  2D4.1
.................... 
....................   //leds output en open drain
....................   output_float(PIN_B8);
015E8:  BSET.B  2C9.0
....................   output_float(PIN_B9);
015EA:  BSET.B  2C9.1
.................... 
....................   //pullups
....................   set_pullup(TRUE, PIN_B8);
015EC:  BSET.B  6A.6
....................   set_pullup(TRUE, PIN_B9);
015EE:  BSET.B  6A.5
.................... 
.................... 
....................   //dspic as master, velocidad, nombre de la conexion
....................   #use i2c(Master, Fast=100000, i2c1)
*
0158E:  MOV     #FFFF,W0
01590:  BTSS.B  208.3
01592:  BRA     159E
01594:  BTSC.B  209.6
01596:  BRA     1594
01598:  MOV     W1,202
0159A:  BTSC.B  209.6
0159C:  BRA     159A
0159E:  MOV     #0,W0
015A0:  BTSC.B  209.7
015A2:  INC     W0,W0
015A4:  RETURN  
.................... 
....................   LCD_command(_CLEAR_DISPLAY);
*
015F0:  MOV.B   #1,W0L
015F2:  MOV.B   W0L,1330
015F4:  CALL    15A6
....................   LCD_command(_8BIT_4LINES_NORMAL_RE1_IS0);
*
015F8:  MOV.B   #3A,W0L
015FA:  MOV.B   W0L,1330
015FC:  CALL    15A6
....................   LCD_command(_BS1_1);
*
01600:  MOV.B   #1E,W0L
01602:  MOV.B   W0L,1330
01604:  CALL    15A6
....................   LCD_command(_POWER_DOWN_DISABLE);
*
01608:  MOV.B   #2,W0L
0160A:  MOV.B   W0L,1330
0160C:  CALL    15A6
....................   LCD_command(_SEGMENT_NORMAL_WAY);
*
01610:  MOV.B   #5,W0L
01612:  MOV.B   W0L,1330
01614:  CALL    15A6
....................   LCD_command(_NW);
*
01618:  MOV.B   #9,W0L
0161A:  MOV.B   W0L,1330
0161C:  CALL    15A6
....................   LCD_command(_8BIT_4LINES_RE0_IS1);
*
01620:  MOV.B   #39,W0L
01622:  MOV.B   W0L,1330
01624:  CALL    15A6
....................   LCD_command(_DISPLAY_ON_CURSOR_ON_BLINK_OFF);
*
01628:  MOV.B   #E,W0L
0162A:  MOV.B   W0L,1330
0162C:  CALL    15A6
....................   LCD_command(_BS0_1);
*
01630:  MOV.B   #1C,W0L
01632:  MOV.B   W0L,1330
01634:  CALL    15A6
....................   LCD_command(_INTERNAL_DIVIDER);
*
01638:  MOV.B   #13,W0L
0163A:  MOV.B   W0L,1330
0163C:  CALL    15A6
....................   LCD_command(_CONTRAST);
*
01640:  MOV.B   #77,W0L
01642:  MOV.B   W0L,1330
01644:  CALL    15A6
....................   LCD_command(_POWER_ICON_CONTRAST);
*
01648:  MOV.B   #5C,W0L
0164A:  MOV.B   W0L,1330
0164C:  CALL    15A6
....................   LCD_command(_FOLLOWER_CONTROL);
*
01650:  MOV.B   #6E,W0L
01652:  MOV.B   W0L,1330
01654:  CALL    15A6
....................   LCD_command(_8BIT_4LINES_RE0_IS0);
*
01658:  MOV.B   #38,W0L
0165A:  MOV.B   W0L,1330
0165C:  CALL    15A6
....................   LCD_command(_DISPLAY_ON_CURSOR_OFF_BLINK_OFF);
*
01660:  MOV.B   #C,W0L
01662:  MOV.B   W0L,1330
01664:  CALL    15A6
*
01668:  RETURN  
.................... 
.................... }
.................... 
.................... void LCD_command(unsigned int8 cmd)
.................... {
....................   i2c_start();
*
015A6:  BTSS.B  208.3
015A8:  BRA     15B2
015AA:  BSET.B  206.1
015AC:  BTSC.B  206.1
015AE:  BRA     15AC
015B0:  BRA     15B8
015B2:  BSET.B  206.0
015B4:  BTSC.B  206.0
015B6:  BRA     15B4
....................   i2c_write(0x78);
015B8:  MOV.B   #78,W1L
015BA:  CALL    158E
....................   i2c_write(0x00);
*
015BE:  CLR.B   W1
015C0:  CALL    158E
....................   i2c_write(cmd);
*
015C4:  MOV.B   1330,W0L
015C6:  MOV.B   W0L,2
015C8:  CALL    158E
....................   i2c_stop();
*
015CC:  MOV     #1F,W0
015CE:  AND     206,W0
015D0:  BRA     NZ,15CC
015D2:  BSET.B  206.2
015D4:  BTSC.B  206.2
015D6:  BRA     15D4
015D8:  RETURN  
.................... }
.................... 
.................... void LCD_write(char* cd)
*
016A4:  MOV     W5,[W15++]
016A6:  MOV     W6,[W15++]
016A8:  CLR.B   132C
.................... {
....................   unsigned int8 c=0;
....................   i2c_start();
016AA:  BTSS.B  208.3
016AC:  BRA     16B6
016AE:  BSET.B  206.1
016B0:  BTSC.B  206.1
016B2:  BRA     16B0
016B4:  BRA     16BC
016B6:  BSET.B  206.0
016B8:  BTSC.B  206.0
016BA:  BRA     16B8
....................   i2c_write(0x78);
016BC:  MOV.B   #78,W1L
016BE:  CALL    158E
....................   i2c_write(0x40);
*
016C2:  MOV.B   #40,W1L
016C4:  CALL    158E
....................   while(cd[c]!=0)
*
016C8:  MOV     132C,W4
016CA:  CLR.B   9
016CC:  MOV     W4,W0
016CE:  ADD     132A,W0
016D0:  MOV.B   [W0],W5L
016D2:  SE      W5,W5
016D4:  CP0     W5
016D6:  BRA     Z,16EE
....................   {
....................     i2c_write(cd[c]);
016D8:  MOV     132C,W4
016DA:  CLR.B   9
016DC:  MOV     W4,W0
016DE:  ADD     132A,W0
016E0:  MOV.B   [W0],W5L
016E2:  MOV.B   W5L,W1L
016E4:  CALL    158E
....................     c++;
*
016E8:  INC.B   132C
016EA:  GOTO    16C8
....................   }
....................   i2c_stop();
*
016EE:  MOV     #1F,W0
016F0:  AND     206,W0
016F2:  BRA     NZ,16EE
016F4:  BSET.B  206.2
016F6:  BTSC.B  206.2
016F8:  BRA     16F6
016FA:  MOV     [--W15],W6
016FC:  MOV     [--W15],W5
016FE:  RETURN  
.................... }
.................... 
.................... void LCD_cursor_at(unsigned int8 line, unsigned int8 column)
*
01684:  MOV     W5,[W15++]
.................... {
....................   LCD_command(0x80 | (line*0x20+column));
01686:  MOV.B   132A,W0L
01688:  CLR.B   1
0168A:  SL      W0,#5,W5
0168C:  MOV     132A,W4
0168E:  LSR     W4,#8,W4
01690:  ADD     W5,W4,W0
01692:  MOV     W0,W5
01694:  IOR     #80,W5
01696:  PUSH    1330
01698:  MOV.B   W5L,[W15-#2]
0169A:  POP     1330
0169C:  CALL    15A6
*
016A0:  MOV     [--W15],W5
016A2:  RETURN  
.................... }
.................... 
.................... void initmenu(void)
.................... {
.................... 	char cabecera[]="----WELCOME-----";
*
01700:  MOV     #2D2D,W4
01702:  MOV     W4,12EE
01704:  MOV     #2D2D,W4
01706:  MOV     W4,12F0
01708:  MOV     #4557,W4
0170A:  MOV     W4,12F2
0170C:  MOV     #434C,W4
0170E:  MOV     W4,12F4
01710:  MOV     #4D4F,W4
01712:  MOV     W4,12F6
01714:  MOV     #2D45,W4
01716:  MOV     W4,12F8
01718:  MOV     #2D2D,W4
0171A:  MOV     W4,12FA
0171C:  MOV     #2D2D,W4
0171E:  MOV     W4,12FC
01720:  CLR.B   12FE
.................... 	char boton[]="-------------";
01722:  MOV     #2D2D,W4
01724:  MOV     W4,1300
01726:  MOV     #2D2D,W4
01728:  MOV     W4,1302
0172A:  MOV     #2D2D,W4
0172C:  MOV     W4,1304
0172E:  MOV     #2D2D,W4
01730:  MOV     W4,1306
01732:  MOV     #2D2D,W4
01734:  MOV     W4,1308
01736:  MOV     #2D2D,W4
01738:  MOV     W4,130A
0173A:  MOV     #2D,W4
0173C:  MOV     W4,130C
.................... 	char palabra1[]="PRESS OK";
0173E:  MOV     #5250,W4
01740:  MOV     W4,130E
01742:  MOV     #5345,W4
01744:  MOV     W4,1310
01746:  MOV     #2053,W4
01748:  MOV     W4,1312
0174A:  MOV     #4B4F,W4
0174C:  MOV     W4,1314
0174E:  CLR.B   1316
.................... 	//char palabra2[]="OPCION 2";
.................... 	//char palabra3[]="OPCION 3";
.................... 	//char palabra4[]="OPCION 4";
.................... 
.................... 	LCD_cursor_at(0,0);
01750:  CLR.B   132A
01752:  CLR.B   132B
01754:  CALL    1684
.................... 	LCD_write(cabecera);
*
01758:  MOV     #12EE,W4
0175A:  MOV     W4,132A
0175C:  CALL    16A4
.................... 	LCD_cursor_at(1,0);
*
01760:  MOV.B   #1,W0L
01762:  MOV.B   W0L,132A
01764:  CLR.B   132B
01766:  CALL    1684
.................... 	LCD_write(boton);
*
0176A:  MOV     #1300,W4
0176C:  MOV     W4,132A
0176E:  CALL    16A4
.................... 	LCD_cursor_at(2,1);
*
01772:  MOV.B   #2,W0L
01774:  MOV.B   W0L,132A
01776:  MOV.B   #1,W0L
01778:  MOV.B   W0L,132B
0177A:  CALL    1684
.................... 	LCD_write(palabra1);
*
0177E:  MOV     #130E,W4
01780:  MOV     W4,132A
01782:  CALL    16A4
*
01786:  RETURN  
.................... }
.................... 
.................... void errorfichero(void)
.................... {
.................... 	char cabecera[]="------ERROR------";
.................... 	char boton[]="NO CONFIG.TXT DETE";
.................... 	char palabra1[]="PRESS RESET";
.................... 	//char palabra2[]="OPCION 2";
.................... 	//char palabra3[]="OPCION 3";
.................... 	//char palabra4[]="OPCION 4";
.................... 
.................... 	LCD_cursor_at(0,0);
.................... 	LCD_write(cabecera);
.................... 	LCD_cursor_at(1,0);
.................... 	LCD_write(boton);
.................... 	LCD_cursor_at(2,1);
.................... 	LCD_write(palabra1);
.................... }
.................... 
.................... void display_frecuencia(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
*
017E0:  MOV.B   #1,W0L
017E2:  MOV.B   W0L,1330
017E4:  CALL    15A6
.................... 	char cabecera[]="FRECUENCIA PPM: ";
*
017E8:  MOV     #5246,W4
017EA:  MOV     W4,12EE
017EC:  MOV     #4345,W4
017EE:  MOV     W4,12F0
017F0:  MOV     #4555,W4
017F2:  MOV     W4,12F2
017F4:  MOV     #434E,W4
017F6:  MOV     W4,12F4
017F8:  MOV     #4149,W4
017FA:  MOV     W4,12F6
017FC:  MOV     #5020,W4
017FE:  MOV     W4,12F8
01800:  MOV     #4D50,W4
01802:  MOV     W4,12FA
01804:  MOV     #203A,W4
01806:  MOV     W4,12FC
01808:  CLR.B   12FE
....................   char palabra1[]="-------------------";
0180A:  MOV     #2D2D,W4
0180C:  MOV     W4,1300
0180E:  MOV     #2D2D,W4
01810:  MOV     W4,1302
01812:  MOV     #2D2D,W4
01814:  MOV     W4,1304
01816:  MOV     #2D2D,W4
01818:  MOV     W4,1306
0181A:  MOV     #2D2D,W4
0181C:  MOV     W4,1308
0181E:  MOV     #2D2D,W4
01820:  MOV     W4,130A
01822:  MOV     #2D2D,W4
01824:  MOV     W4,130C
01826:  MOV     #2D2D,W4
01828:  MOV     W4,130E
0182A:  MOV     #2D2D,W4
0182C:  MOV     W4,1310
0182E:  MOV     #2D,W4
01830:  MOV     W4,1312
....................   char palabra2[]="BTOK PARA FINALIZAR";
01832:  MOV     #5442,W4
01834:  MOV     W4,1314
01836:  MOV     #4B4F,W4
01838:  MOV     W4,1316
0183A:  MOV     #5020,W4
0183C:  MOV     W4,1318
0183E:  MOV     #5241,W4
01840:  MOV     W4,131A
01842:  MOV     #2041,W4
01844:  MOV     W4,131C
01846:  MOV     #4946,W4
01848:  MOV     W4,131E
0184A:  MOV     #414E,W4
0184C:  MOV     W4,1320
0184E:  MOV     #494C,W4
01850:  MOV     W4,1322
01852:  MOV     #415A,W4
01854:  MOV     W4,1324
01856:  MOV     #52,W4
01858:  MOV     W4,1326
.................... 	LCD_cursor_at(0,0);
0185A:  CLR.B   132A
0185C:  CLR.B   132B
0185E:  CALL    1684
....................   LCD_write(cabecera);
*
01862:  MOV     #12EE,W4
01864:  MOV     W4,132A
01866:  CALL    16A4
....................   LCD_cursor_at(1,0);
*
0186A:  MOV.B   #1,W0L
0186C:  MOV.B   W0L,132A
0186E:  CLR.B   132B
01870:  CALL    1684
....................   LCD_write(palabra1);
*
01874:  MOV     #1300,W4
01876:  MOV     W4,132A
01878:  CALL    16A4
....................   LCD_cursor_at(2,0);
*
0187C:  MOV.B   #2,W0L
0187E:  MOV.B   W0L,132A
01880:  CLR.B   132B
01882:  CALL    1684
....................   LCD_write(palabra2);
*
01886:  MOV     #1314,W4
01888:  MOV     W4,132A
0188A:  CALL    16A4
*
0188E:  RETURN  
.................... }
.................... 
.................... void display_valueADC_title(void)
.................... {
....................   char cabecera[]="VALOR ADC: ";
....................   //char palabra2[]="OPCION 2";
....................   //char palabra3[]="OPCION 3";
....................   //char palabra4[]="OPCION 4";
.................... 
....................   LCD_cursor_at(0,0);
....................   LCD_write(cabecera);
.................... }
.................... 
.................... void display_alarma_bajo(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
*
019C6:  MOV.B   #1,W0L
019C8:  MOV.B   W0L,1330
019CA:  CALL    15A6
....................   LCD_cursor_at(0,0);
*
019CE:  CLR.B   132A
019D0:  CLR.B   132B
019D2:  CALL    1684
....................   char peligro[]="PULSACIONES BAJAS";
*
019D6:  MOV     #5550,W4
019D8:  MOV     W4,12EE
019DA:  MOV     #534C,W4
019DC:  MOV     W4,12F0
019DE:  MOV     #4341,W4
019E0:  MOV     W4,12F2
019E2:  MOV     #4F49,W4
019E4:  MOV     W4,12F4
019E6:  MOV     #454E,W4
019E8:  MOV     W4,12F6
019EA:  MOV     #2053,W4
019EC:  MOV     W4,12F8
019EE:  MOV     #4142,W4
019F0:  MOV     W4,12FA
019F2:  MOV     #414A,W4
019F4:  MOV     W4,12FC
019F6:  MOV     #53,W4
019F8:  MOV     W4,12FE
....................   LCD_write(peligro);
019FA:  MOV     #12EE,W4
019FC:  MOV     W4,132A
019FE:  CALL    16A4
*
01A02:  RETURN  
.................... }
.................... 
.................... void display_alarma_alto(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
*
01982:  MOV.B   #1,W0L
01984:  MOV.B   W0L,1330
01986:  CALL    15A6
....................   LCD_cursor_at(0,0);
*
0198A:  CLR.B   132A
0198C:  CLR.B   132B
0198E:  CALL    1684
....................   char peligro[]="PULSACIONES ELEVADAS";
*
01992:  MOV     #5550,W4
01994:  MOV     W4,12EE
01996:  MOV     #534C,W4
01998:  MOV     W4,12F0
0199A:  MOV     #4341,W4
0199C:  MOV     W4,12F2
0199E:  MOV     #4F49,W4
019A0:  MOV     W4,12F4
019A2:  MOV     #454E,W4
019A4:  MOV     W4,12F6
019A6:  MOV     #2053,W4
019A8:  MOV     W4,12F8
019AA:  MOV     #4C45,W4
019AC:  MOV     W4,12FA
019AE:  MOV     #5645,W4
019B0:  MOV     W4,12FC
019B2:  MOV     #4441,W4
019B4:  MOV     W4,12FE
019B6:  MOV     #5341,W4
019B8:  MOV     W4,1300
019BA:  CLR.B   1302
....................   LCD_write(peligro);
019BC:  MOV     #12EE,W4
019BE:  MOV     W4,132A
019C0:  CALL    16A4
*
019C4:  RETURN  
.................... }
.................... 
.................... void display_final(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
*
01ED2:  MOV.B   #1,W0L
01ED4:  MOV.B   W0L,1330
01ED6:  CALL    15A6
....................   LCD_cursor_at(0,0);
*
01EDA:  CLR.B   132A
01EDC:  CLR.B   132B
01EDE:  CALL    1684
....................   char fin[]="Fin del programa";
*
01EE2:  MOV     #6946,W4
01EE4:  MOV     W4,12EE
01EE6:  MOV     #206E,W4
01EE8:  MOV     W4,12F0
01EEA:  MOV     #6564,W4
01EEC:  MOV     W4,12F2
01EEE:  MOV     #206C,W4
01EF0:  MOV     W4,12F4
01EF2:  MOV     #7270,W4
01EF4:  MOV     W4,12F6
01EF6:  MOV     #676F,W4
01EF8:  MOV     W4,12F8
01EFA:  MOV     #6172,W4
01EFC:  MOV     W4,12FA
01EFE:  MOV     #616D,W4
01F00:  MOV     W4,12FC
01F02:  CLR.B   12FE
....................   LCD_write(fin);
01F04:  MOV     #12EE,W4
01F06:  MOV     W4,132A
01F08:  CALL    16A4
*
01F0C:  RETURN  
.................... }
.................... 
.................... void display_electrodo_suelto(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
*
01890:  MOV.B   #1,W0L
01892:  MOV.B   W0L,1330
01894:  CALL    15A6
....................   LCD_cursor_at(0,0);
*
01898:  CLR.B   132A
0189A:  CLR.B   132B
0189C:  CALL    1684
....................   char fin[]="ELECTRODO SUELTO";
*
018A0:  MOV     #4C45,W4
018A2:  MOV     W4,12EE
018A4:  MOV     #4345,W4
018A6:  MOV     W4,12F0
018A8:  MOV     #5254,W4
018AA:  MOV     W4,12F2
018AC:  MOV     #444F,W4
018AE:  MOV     W4,12F4
018B0:  MOV     #204F,W4
018B2:  MOV     W4,12F6
018B4:  MOV     #5553,W4
018B6:  MOV     W4,12F8
018B8:  MOV     #4C45,W4
018BA:  MOV     W4,12FA
018BC:  MOV     #4F54,W4
018BE:  MOV     W4,12FC
018C0:  CLR.B   12FE
....................   LCD_write(fin);
018C2:  MOV     #12EE,W4
018C4:  MOV     W4,132A
018C6:  CALL    16A4
*
018CA:  RETURN  
.................... }
.................... 
.................... void display_electrodo_recuperado(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
018CC:  MOV.B   #1,W0L
018CE:  MOV.B   W0L,1330
018D0:  CALL    15A6
.................... 	char cabecera[]="Contacto restaurado";
*
018D4:  MOV     #6F43,W4
018D6:  MOV     W4,12EE
018D8:  MOV     #746E,W4
018DA:  MOV     W4,12F0
018DC:  MOV     #6361,W4
018DE:  MOV     W4,12F2
018E0:  MOV     #6F74,W4
018E2:  MOV     W4,12F4
018E4:  MOV     #7220,W4
018E6:  MOV     W4,12F6
018E8:  MOV     #7365,W4
018EA:  MOV     W4,12F8
018EC:  MOV     #6174,W4
018EE:  MOV     W4,12FA
018F0:  MOV     #7275,W4
018F2:  MOV     W4,12FC
018F4:  MOV     #6461,W4
018F6:  MOV     W4,12FE
018F8:  MOV     #6F,W4
018FA:  MOV     W4,1300
....................   char palabra1[]="-------------------";
018FC:  MOV     #2D2D,W4
018FE:  MOV     W4,1302
01900:  MOV     #2D2D,W4
01902:  MOV     W4,1304
01904:  MOV     #2D2D,W4
01906:  MOV     W4,1306
01908:  MOV     #2D2D,W4
0190A:  MOV     W4,1308
0190C:  MOV     #2D2D,W4
0190E:  MOV     W4,130A
01910:  MOV     #2D2D,W4
01912:  MOV     W4,130C
01914:  MOV     #2D2D,W4
01916:  MOV     W4,130E
01918:  MOV     #2D2D,W4
0191A:  MOV     W4,1310
0191C:  MOV     #2D2D,W4
0191E:  MOV     W4,1312
01920:  MOV     #2D,W4
01922:  MOV     W4,1314
....................   char palabra2[]="BTOK PARA CONTINUAR";
01924:  MOV     #5442,W4
01926:  MOV     W4,1316
01928:  MOV     #4B4F,W4
0192A:  MOV     W4,1318
0192C:  MOV     #5020,W4
0192E:  MOV     W4,131A
01930:  MOV     #5241,W4
01932:  MOV     W4,131C
01934:  MOV     #2041,W4
01936:  MOV     W4,131E
01938:  MOV     #4F43,W4
0193A:  MOV     W4,1320
0193C:  MOV     #544E,W4
0193E:  MOV     W4,1322
01940:  MOV     #4E49,W4
01942:  MOV     W4,1324
01944:  MOV     #4155,W4
01946:  MOV     W4,1326
01948:  MOV     #52,W4
0194A:  MOV     W4,1328
.................... 	LCD_cursor_at(0,0);
0194C:  CLR.B   132A
0194E:  CLR.B   132B
01950:  CALL    1684
....................   LCD_write(cabecera);
*
01954:  MOV     #12EE,W4
01956:  MOV     W4,132A
01958:  CALL    16A4
....................   LCD_cursor_at(1,0);
*
0195C:  MOV.B   #1,W0L
0195E:  MOV.B   W0L,132A
01960:  CLR.B   132B
01962:  CALL    1684
....................   LCD_write(palabra1);
*
01966:  MOV     #1302,W4
01968:  MOV     W4,132A
0196A:  CALL    16A4
....................   LCD_cursor_at(2,0);
*
0196E:  MOV.B   #2,W0L
01970:  MOV.B   W0L,132A
01972:  CLR.B   132B
01974:  CALL    1684
....................   LCD_write(palabra2);
*
01978:  MOV     #1316,W4
0197A:  MOV     W4,132A
0197C:  CALL    16A4
*
01980:  RETURN  
.................... }
.................... 
.................... 
.................... #endif // __LCD_H
.................... // Do not write below this line!
.................... 
.................... #include "algoritmo.h"
.................... /**
....................  @file    ALGORITMO.h
....................  @author  Ricardo Gomez, Klaudija Ziliute
....................  @brief   PanTompkins header file
.................... */
.................... 
.................... 
.................... #ifndef __ALGORITMO_H
.................... #define __ALGORITMO_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "Header.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "algoritmo.h"
.................... #include "miFAT.h"
.................... #include "sdcard.h"
.................... #include "BLUETOOTH.h"
.................... #include "BEEP.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void) //por comprobar en la placa
.................... {
....................     output_high(BTCM);
....................     setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_31);
....................     setup_adc_ports(sAN4, VSS_VDD);
....................     set_adc_channel(4);
.................... //   setup_timer3(TMR_INTERNAL, 18425); //  200 Hz. Ty/2/18425
.................... //   ADC1CON2 = 0b0000000000000000; // voltage reference en ADC1CON2
.................... //   ADC1CON3 = 0b1000000000000000; // select the analog conversion clock <7:0> y <15> para enable Tad
.................... //   AD1PCFGL = 0b1111111111111110; // AN1 entrada analogica - RB1 - PGC en placa
.................... //   AD1CHS0  = 0b0000000100000001; // AN1 entrada seleccionada para el CH0
.................... //   AD1PCFGL = 0b0000000011110111; // AN4 entrada analogica - RB1 - PGC en placa
.................... //   AD1CHS0  = 0b0000010000000100; // AN4 entrada seleccionada para el CH0
.................... //
.................... //   ADC1CON1 = 0b1011010101000110; // 12 bits - Signed Integer - <7:5> 010 Timer3 for ADC1 - <15> Sampling inmediatly after EOC <9:0> unsigned int
.................... 
.................... }
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "BEEP.h"
.................... /**
....................  @file    BEEP.h
....................  @author  Julio Gomis-Tena
....................  @brief   Generate n "beeps" of variable frequency
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __BEEP_H
.................... #define __BEEP_H
.................... #include "Header.h"
.................... #ifndef Header_h
.................... #define Header_h
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses HS
.................... #fuses PR
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock= 11059200)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON( pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define III            PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		   PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDO1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDI1 =     PIN_B7  //                    (43)
.................... #define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #pin_select OC2 = BUZZER
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void); //Inicializa las frecuencias de los beeps y la separaciÃ³n entre ellos
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP(unsigned int8); //Realiza n beeps
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void)		//4kHz -> T/2= 125us
.................... {
.................... 	setup_timer3(TMR_INTERNAL|TMR_DIV_BY_1, 737); // 5kHz. Frecuencia de los beeps
*
0166A:  CLR     112
0166C:  MOV     #2E1,W4
0166E:  MOV     W4,10E
01670:  MOV     #8000,W4
01672:  MOV     W4,112
.................... 	set_compare_time(2, 0);
01674:  CLR     188
.................... 	setup_compare(2, COMPARE_OFF);
01676:  CLR     18A
.................... 
.................... 		// (11059200/2)/256/432 = 50 Hz  <-> 100ms
.................... 	setup_timer4(TMR_INTERNAL|TMR_DIV_BY_8, 1843);
01678:  CLR     11E
0167A:  MOV     #733,W4
0167C:  MOV     W4,11A
0167E:  MOV     #8010,W4
01680:  MOV     W4,11E
01682:  RETURN  
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 N_beep;
.................... 
.................... void BEEP(unsigned int8 n)
.................... {
.................... 	if(n<127)
*
0038C:  MOV     135E,W4
0038E:  MOV     #7F,W3
00390:  CP.B    W3L,W4L
00392:  BRA     LEU,39E
.................... 		N_beep = 2*n;
00394:  MOV.B   135E,W0L
00396:  MOV.B   W0L,85A
00398:  SL.B    85A
0039A:  GOTO    3A0
.................... 	else
.................... 		N_beep = 255;
*
0039E:  SETM.B  85A
.................... 
.................... 	enable_interrupts(INT_TIMER4);
003A0:  BSET.B  97.3
003A2:  RETURN  
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #INT_TIMER4
.................... void isr_TIMER4()			// Cada 100 ms. Espaciado entre beeps. Habra que asociarlo a una interrupcion por software
*
002A0:  PUSH    42
002A2:  PUSH    36
002A4:  PUSH    32
002A6:  MOV     W0,[W15++]
002A8:  MOV     #2,W0
002AA:  REPEAT  #C
002AC:  MOV     [W0++],[W15++]
.................... {
.................... 		if((N_beep%2)==1)
002AE:  MOV.B   85A,W0L
002B0:  CLR.B   1
002B2:  AND     W0,#1,W5
002B4:  CP      W5,#1
002B6:  BRA     NZ,2C0
.................... 		{
.................... 			setup_compare(2, COMPARE_TOGGLE | COMPARE_TIMER3);
002B8:  MOV     #B,W4
002BA:  MOV     W4,18A
.................... 		}
002BC:  GOTO    2C6
.................... 		else
.................... 		{
.................... 			setup_compare(2, COMPARE_OFF);
*
002C0:  CLR     18A
.................... 			OFF(BUZZER);
002C2:  BCLR.B  2D0.6
002C4:  BCLR.B  2D4.6
.................... 		}
.................... 
.................... 		if( N_beep>0 )
002C6:  CP0.B   85A
002C8:  BRA     Z,2D4
.................... 		{
.................... 		   	N_beep-=1;
002CA:  MOV     85A,W4
002CC:  SUB.B   W4L,#1,W0L
002CE:  MOV.B   W0L,85A
.................... 		}
002D0:  GOTO    2D8
.................... 		else
.................... 		{
.................... 			disable_interrupts(INT_TIMER4);
*
002D4:  BCLR.B  97.3
002D6:  NOP     
.................... 		}
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
002D8:  BCLR.B  87.3
002DA:  MOV     #1A,W0
002DC:  REPEAT  #C
002DE:  MOV     [--W15],[W0--]
002E0:  MOV     [--W15],W0
002E2:  POP     32
002E4:  POP     36
002E6:  POP     42
002E8:  RETFIE  
.................... #endif // __BEEP_H
.................... 
.................... 
.................... 
.................... int algoritmo(void);
.................... void init_algoritmo(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... unsigned int16 yECG[6];
.................... unsigned int16 der, maximo, maximo_ant;
.................... float umbral;
.................... unsigned int16 k;
.................... int1 flag;
.................... unsigned int16 BCL, BCL2; // contador interno (1 BCL=4ms)
.................... 
.................... 
.................... void init_algoritmo()
*
017A0:  MOV     W5,[W15++]
.................... {
.................... 	BCL=0;
017A2:  CLR     874
.................... 	k=0;
017A4:  CLR     872
.................... 	umbral=0;
017A6:  CLR     86E
017A8:  CLR     870
.................... 	flag=0;
017AA:  BCLR.B  85B.0
.................... 	maximo=0;
017AC:  CLR     86A
.................... 	maximo_ant=0;
017AE:  CLR     86C
.................... 	for(int e=0; e<6; e++)
017B0:  CLR     12EE
017B2:  MOV     12EE,W4
017B4:  CP      W4,#6
017B6:  BRA     GE,17DA
.................... 	{
.................... 		yECG[e]=read_adc();
017B8:  MOV     12EE,W4
017BA:  MUL.UU  W4,#2,W0
017BC:  MOV     #85C,W4
017BE:  ADD     W0,W4,W5
017C0:  BCLR.B  320.0
017C2:  BSET.B  320.1
017C4:  BTSS.B  320.0
017C6:  BRA     17C4
017C8:  MOV     300,W4
017CA:  MOV     W4,[W5+#0]
.................... 		delay_ms(4);
017CC:  REPEAT  #1662
017CE:  NOP     
017D0:  REPEAT  #3FFF
017D2:  NOP     
017D4:  INC     12EE
017D6:  GOTO    17B2
.................... 	}
.................... 	enable_interrupts(INT_TIMER2);
*
017DA:  BSET.B  94.7
017DC:  MOV     [--W15],W5
017DE:  RETURN  
.................... }
.................... 
.................... // Bucle principal del programa. Debe ejecutarse cada 4ms (250Hz).
.................... int algoritmo(void)
*
00618:  MOV     W5,[W15++]
.................... {
.................... 	int pulsaciones;
.................... 	yECG[5] = yECG[4];		// Hace 20 ms
0061A:  PUSH    864
0061C:  POP     866
.................... 	yECG[4] = yECG[3];		// Hace 16 ms
0061E:  PUSH    862
00620:  POP     864
.................... 	yECG[3] = yECG[2]; 		// Hace 12 ms
00622:  PUSH    860
00624:  POP     862
.................... 	yECG[2] = yECG[1]; 		// Hace 8 ms
00626:  PUSH    85E
00628:  POP     860
.................... 	yECG[1] = yECG[0]; 		// Hace 4 ms
0062A:  PUSH    85C
0062C:  POP     85E
.................... 	yECG[0] = read_adc(); // Ahora
0062E:  BCLR.B  320.0
00630:  BSET.B  320.1
00632:  BTSS.B  320.0
00634:  BRA     632
00636:  PUSH    300
00638:  POP     85C
.................... 
.................... 	//Valor absoluto de la derivada
.................... 	der = (yECG[5] > yECG[0]) ? (yECG[5] - yECG[0]) : (yECG[0] - yECG[5]);
0063A:  MOV     85C,W0
0063C:  MOV     866,W4
0063E:  CP      W4,W0
00640:  BRA     LEU,64C
00642:  MOV     866,W4
00644:  MOV     85C,W3
00646:  SUB     W4,W3,W0
00648:  GOTO    652
*
0064C:  MOV     85C,W4
0064E:  MOV     866,W3
00650:  SUB     W4,W3,W0
00652:  MOV     W0,868
.................... 
.................... 	if(der > maximo) maximo = der;
00654:  MOV     86A,W0
00656:  MOV     868,W4
00658:  CP      W4,W0
0065A:  BRA     LEU,660
0065C:  PUSH    868
0065E:  POP     86A
.................... 
.................... 	if(flag == 0)
00660:  BTSC.B  85B.0
00662:  BRA     688
.................... 	{
.................... 		if(der > umbral)
00664:  MOV     868,W0
00666:  CALL    2EA
*
0066A:  MOV     W0,W2
0066C:  MOV     W1,W3
0066E:  MOV     86E,W0
00670:  MOV     870,W1
00672:  CALL    324
*
00676:  BRA     NC,688
.................... 		{
.................... 			flag = 1;
00678:  BSET.B  85B.0
.................... 			// basal cycle length
.................... 			BCL2 = BCL;
0067A:  PUSH    874
0067C:  POP     876
.................... 			BCL = 0;
0067E:  CLR     874
.................... 			BEEP(1);
00680:  MOV.B   #1,W0L
00682:  MOV.B   W0L,135E
00684:  CALL    38C
.................... 		}
.................... 	}
.................... 
.................... 	if (flag == 1)
*
00688:  BTSS.B  85B.0
0068A:  BRA     68E
.................... 	{
.................... 		k++;
0068C:  INC     0872
.................... 	}
.................... 
.................... 	//Durante 60 puntos = RR min = 0.24seg = 250 bpm
.................... 	//no se puede detectar otro punto RR
.................... 	//solo pasado ese tiempo se hace el calculo
.................... 
.................... 	if(k >60) // hay que calcular el tiempo que son 0.24s para nuestra freq (60 no)
0068E:  MOV     872,W4
00690:  MOV     #3C,W3
00692:  CP      W3,W4
00694:  BRA     C,6CE
.................... 	{
.................... 		k = 0;
00696:  CLR     872
.................... 		flag = 0;
00698:  BCLR.B  85B.0
.................... 
.................... 		//Me quedo con la Media del incremento MAX
.................... 		//De estos 200 puntos y del incremento de los anteriores
.................... 
.................... 		umbral = (maximo + maximo_ant)/2;
0069A:  MOV     86A,W0
0069C:  ADD     86C,W0
0069E:  MOV     W0,W5
006A0:  LSR     W5,#1,W0
006A2:  CALL    2EA
*
006A6:  MOV     W0,86E
006A8:  MOV     W1,870
.................... 		maximo_ant = maximo;
006AA:  PUSH    86A
006AC:  POP     86C
.................... 		maximo = 0;
006AE:  CLR     86A
.................... 
.................... 		//Reduzco el umbral al 66%
.................... 
.................... 		umbral = umbral -(umbral/3);
006B0:  MOV     86E,W0
006B2:  MOV     870,W1
006B4:  MOV     #0,W2
006B6:  MOV     #4040,W3
006B8:  CALL    3A4
*
006BC:  BSET.B  43.0
006BE:  MOV     W0,W2
006C0:  MOV     W1,W3
006C2:  MOV     86E,W0
006C4:  MOV     870,W1
006C6:  CALL    46E
*
006CA:  MOV     W0,86E
006CC:  MOV     W1,870
.................... 	}
.................... 
.................... 	//Si pasa un rato
.................... 	//equivaldria a un pulso de 15bpm si se detectara punto R
.................... 	//y no se ha superado el umbral se reinicia
.................... 
.................... 	if(BCL > 1000)
006CE:  MOV     874,W4
006D0:  MOV     #3E8,W3
006D2:  CP      W3,W4
006D4:  BRA     C,6E0
.................... 	{
.................... 		maximo = 0;
006D6:  CLR     86A
.................... 		umbral = 0;
006D8:  CLR     86E
006DA:  CLR     870
.................... 		flag = 1;
006DC:  BSET.B  85B.0
.................... 		BCL = 0;
006DE:  CLR     874
.................... 	}
.................... 	//Calculo el ritmo cardiaco (si esta en rango fisiologico)
.................... 	//y si no permanece el valor anteriore
.................... 	//15000 son las muestras de 1 minuto (60000[ms]/4[ms/muestra])
.................... 
.................... 	if((BCL2>60)&&(BCL2<750)) // Ritmo entre 20 ppm y 260 ppm
006E0:  MOV     876,W4
006E2:  MOV     #3C,W3
006E4:  CP      W3,W4
006E6:  BRA     C,6FA
006E8:  MOV     876,W4
006EA:  MOV     #2EE,W3
006EC:  CP      W3,W4
006EE:  BRA     LEU,6FA
.................... 	{
.................... 		pulsaciones = (int)(15000/BCL2);
006F0:  MOV     #3A98,W4
006F2:  MOV     876,W3
006F4:  REPEAT  #11
006F6:  DIV.U   W4,W3
006F8:  MOV     W0,135C
.................... 	}
.................... BCL=BCL+1;  // Actualiza la cuenta ente ciclos
006FA:  MOV     874,W4
006FC:  ADD     W4,#1,W0
006FE:  MOV     W0,874
.................... return pulsaciones;
00700:  PUSH    135C
00702:  POP     0
00704:  MOV     [--W15],W5
00706:  RETURN  
.................... }
.................... 
.................... 
.................... #endif // __ALGORITMO_H
.................... 
.................... #include "miFAT.h"
.................... // Definidos en sdcard.h - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... extern unsigned int8 dt[512];
.................... extern unsigned int32 LBA0;
.................... extern unsigned int8 sd_init();
.................... extern unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr);
.................... extern unsigned int8 sd_read_block( unsigned int32 address, unsigned char* ptr);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define MAX_ENTRIES_SECTOR_FAT16        256
.................... #define ENDFILE16                    0xFFFF
.................... #define MAX_ENTRIES_SECTOR_FAT32        128
.................... #define ENDFILE32                0x0FFFFFFF
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... typedef struct{
.................... 	union{
.................... 		unsigned int8 raw[32];
.................... 		struct fields{
.................... 			char name[8];
.................... 			char extension[3];
.................... 			unsigned int8 attrib;			///sï¿½lo lectura, oculto, de sistema, directorio...
.................... 			//unsigned int8 reserved[10];
.................... 			  unsigned int8  reserved;
.................... 	 		  unsigned int8  createTimeMs;
.................... 			  unsigned int16 create_hour;
.................... 			  unsigned int16 create_date;
.................... 			  unsigned int16 last_access;
.................... 			  unsigned int16 eaIndex;
.................... 			  unsigned int16 modif_hour;
.................... 			  unsigned int16 modif_date;
.................... 			  unsigned int16 first_cluster;	///primer cluster (direcciona tabla FAT y sector para escribir contenido)
.................... 			  unsigned int32 size;			///tamaï¿½o en bytes
.................... 		};
.................... 	};
.................... } fileEntry;
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... typedef struct{
.................... 	unsigned int32 currentCluster;
.................... 	unsigned int32 currentSector;
.................... 	unsigned int16 posInSector;      //posiciï¿½n actual al escribir en el sector
.................... 	unsigned int32 sectorAtFAT;      //sector de la 1ï¿½ FAT en el que tenemos el actual puntero de cierre de fichero
.................... 
.................... 	unsigned int32 sectorEntryFile; //direcciï¿½n del sector de entradas de fichero
.................... 	unsigned int8  EntryFile[512];  //sector donde estï¿½ la entrada (root) del fichero (para actualizar tamaï¿½o)
.................... 	unsigned int16 offsetEntry;     //offset en el sector de entradas del fichero
.................... 	unsigned int32 size;            //tamaï¿½o del fichero
.................... }_file;
.................... 
.................... _file file;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... typedef struct _diskinforec{
....................    unsigned int8  jmpBoot[3];   // bytes  0.. 2: Salto a la rutina de arranque
....................    unsigned int8  OEMName[8];   // bytes  3..10: Es una cadena "MSDOS5.0"
....................    unsigned int16 BytsPerSec;   // bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes)
....................    unsigned int8  SectPerClus;  // byte  13:    Numero de sectores contenidos en 1 cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes
....................    unsigned int16 RsrvdCnt;     // bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente
....................    unsigned int8  NumFATs;      // byte  16:    Numero de tablas FAT en el volumen. Habitualmente es 2
....................    unsigned int16 RootEntCnt;   // bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
....................    unsigned int16 TotSect16;    // bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0)
....................    unsigned int8  Media;        // byte  21:    Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0
....................    unsigned int16 FATsz16;      // bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0)
....................    unsigned int16 SectPerTrack; // bytes 24..25: Sectores por track
....................    unsigned int16 NumHeads;     // bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.)
....................    unsigned int32 HiddSec;      // bytes 28..31: Sectores ocultos que preceden a la particion (irrelevante en uSD)
....................    unsigned int32 TotSect32;    // bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta
....................    unsigned int32 FATsz32;      // bytes 36..39: Numero de sectores ocupados por una FAT
....................    unsigned int16 ExtFlags;     // bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0)
....................    unsigned int16 FSVer;        // bytes 42..43: Version del sistema de archivos (empleamos la 0.0)
....................    unsigned int32 RootClus;     // bytes 44..47: Indica el numero del 1er cluster del directorio raiz.
....................    unsigned int16 FSInfo;       // bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1)
....................    unsigned int16 BkBootSec;    // bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque
....................    unsigned int8  RsrvdSys[12]; // bytes 52..63: Bytes reservados para futuros usos del sistema
....................    unsigned int8  DrvNum;       // byte  64:     Numero de la unidad (para MSDOS pero irrelevante en uSD).
....................    unsigned int8  Reserved1;    // byte  65:     Windows NT para formatear un volumen pone este byte a 0
....................    unsigned int8  BootSig;      // byte  66:     Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows)
....................    unsigned int32 VolId;        // bytes 67..70: Numero de volumen (generado por el reloj del sistema).
....................    unsigned int8  VolLab[11];   // bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME     ". Nosotros podemos poner "NUUBO_SD    "
....................    unsigned int8  FilSysType[8];// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   "
....................    unsigned int8  spam[420];    // bytes 90..509:Zona de codigo (no lo empleamos y esta a 0)
....................    unsigned int16 firma;        // byte 510..511:Debe de vale 55 AA
.................... } diskinforec;
.................... 
.................... diskinforec DiskInfo;
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned  int8 FATType; // FAT16 o FAT32
.................... //variables clave: inicio de la FAT1 y la FAT2 y de las entradas de ficheros
.................... unsigned  int8 sect_x_cluster;
.................... unsigned int16 sect_fat_1;
.................... unsigned int16 sect_fat_2;
.................... unsigned int32 sect_ini_datos;
.................... unsigned int32 sect_x_fat;
.................... unsigned int32 sect_entry;
.................... unsigned int16 sect_reserv;
.................... 
.................... //unsigned int8 dFil[32];
.................... unsigned int32 sector_fat32[MAX_ENTRIES_SECTOR_FAT32]; // 128 x 4 = 512
.................... unsigned int16 sector_fat16[MAX_ENTRIES_SECTOR_FAT16]; // 256 x 2 = 512
.................... 
.................... //atributos
.................... #define __FILE		0x20
.................... #define _DIRECTORY	0x10
.................... #define _VOLUMEN	0x08
.................... #define _SYSTEM		0x04
.................... #define _HIDDEN		0x02
.................... #define READONLY	0x01
.................... 
.................... ///variables globales
.................... unsigned int16 year = 2020;
.................... unsigned int8 yearLo=   20;
.................... unsigned int8 month =   10;
.................... unsigned int8 day   =	15;
.................... unsigned int8 hour	=   12;
.................... unsigned int8 minute=   34;
.................... unsigned int8 second=   56;
.................... 
.................... ///funciones
.................... #define getHour() (int16)((int16)hour << 11) + (int16)((int16)minute << 5) + (int16) (second >> 1)		//5 bits: horas, 6 bits: minutos, 5 bits: segundos/2
.................... #define getDate() (((int16)year - 1980) << 9 ) + ((int16)month << 5) + (int16)day	//7 bits: aï¿½o (desde 1980), 4 bits: mes, 5 bits: dia
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... void initFAT(){
*
00C18:  MOV     W5,[W15++]
00C1A:  MOV     W6,[W15++]
00C1C:  MOV     W7,[W15++]
00C1E:  MOV     #2,W4
00C20:  MOV     W4,12EE
00C22:  CLR     12F0
....................    unsigned int32 startClusterOfRootDirectory = 2;
....................    unsigned int32 sctrs;
....................    unsigned  int8 *ptrSct;
....................    diskinforec *ptrDiskInfo;
.................... 
.................... 	sd_read_block(LBA0, dt);
00C24:  PUSH    A78
00C26:  POP     1346
00C28:  PUSH    A7A
00C2A:  POP     1348
00C2C:  MOV     #878,W4
00C2E:  MOV     W4,134A
00C30:  CALL    908
....................     						ptrDiskInfo=&DiskInfo;
*
00C34:  MOV     #C94,W4
00C36:  MOV     W4,12F8
....................     						ptrSct= &dt[0];
00C38:  MOV     #878,W4
00C3A:  MOV     W4,12F6
....................    	memcpy((*ptrDiskInfo).jmpBoot, (ptrSct +  0), 3); 			//DiskInfo.jmpBoot[3]	// bytes  0.. 2: Salto a la rutina de arranque
00C3C:  MOV     12F8,W5
00C3E:  MOV     W5,W6
00C40:  MOV     W6,W1
00C42:  MOV     12F6,W2
00C44:  REPEAT  #2
00C46:  MOV.B   [W2++],[W1++]
....................    	memcpy((*ptrDiskInfo).OEMName, (ptrSct +  3), 8); 			//DiskInfo.OEMName[8]	// bytes  3..10: Es una cadena, habitualmente "MSDOS5.0"
00C48:  MOV     12F8,W5
00C4A:  ADD     W5,#3,W6
00C4C:  MOV     12F6,W4
00C4E:  ADD     W4,#3,W7
00C50:  MOV     W6,W1
00C52:  MOV     W7,W2
00C54:  REPEAT  #7
00C56:  MOV.B   [W2++],[W1++]
....................    	DiskInfo.BytsPerSec = make16(dt[12],dt[11]);   				// bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes)
00C58:  MOV.B   883,W0L
00C5A:  MOV.B   W0L,CA0
00C5C:  MOV.B   884,W0L
00C5E:  MOV.B   W0L,CA1
.................... 	DiskInfo.SectPerClus = dt[13];								// byte  13:	 Numero de sectores contenidos en un cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes
00C60:  MOV.B   885,W0L
00C62:  MOV.B   W0L,CA2
.................... 	DiskInfo.RsrvdCnt = make16(dt[15],dt[14]);					// bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente
00C64:  MOV.B   886,W0L
00C66:  MOV.B   W0L,CA4
00C68:  MOV.B   887,W0L
00C6A:  MOV.B   W0L,CA5
....................    	DiskInfo.NumFATs = dt[16];									// byte  16:	 Numero de tablas FAT en el volumen. Habitualmente es 2
00C6C:  MOV.B   888,W0L
00C6E:  MOV.B   W0L,CA6
.................... 	DiskInfo.RootEntCnt = make16(dt[18],dt[17]);				// bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
00C70:  MOV.B   889,W0L
00C72:  MOV.B   W0L,CA8
00C74:  MOV.B   88A,W0L
00C76:  MOV.B   W0L,CA9
....................    	DiskInfo.TotSect16 = make16(dt[20],dt[19]);					// bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0)
00C78:  MOV.B   88B,W0L
00C7A:  MOV.B   W0L,CAA
00C7C:  MOV.B   88C,W0L
00C7E:  MOV.B   W0L,CAB
.................... 	DiskInfo.Media = dt[21];									// byte  21:	 Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0
00C80:  MOV.B   88D,W0L
00C82:  MOV.B   W0L,CAC
.................... 	DiskInfo.FATsz16 = make16(dt[23],dt[22]);					// bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0)
00C84:  MOV.B   88E,W0L
00C86:  MOV.B   W0L,CAE
00C88:  MOV.B   88F,W0L
00C8A:  MOV.B   W0L,CAF
.................... 	DiskInfo.SectPerTrack = make16(dt[25],dt[24]); 				// bytes 24..25: Sectores por track
00C8C:  MOV.B   890,W0L
00C8E:  MOV.B   W0L,CB0
00C90:  MOV.B   891,W0L
00C92:  MOV.B   W0L,CB1
....................    	DiskInfo.NumHeads = make16(dt[27],dt[26]);					// bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.)
00C94:  MOV.B   892,W0L
00C96:  MOV.B   W0L,CB2
00C98:  MOV.B   893,W0L
00C9A:  MOV.B   W0L,CB3
.................... 	DiskInfo.HiddSec = make32(dt[31],dt[30],dt[29],dt[28]);		// bytes 28..31: Sectores ocultos que preceden a la particion
00C9C:  MOV.B   897,W0L
00C9E:  MOV.B   W0L,CB7
00CA0:  MOV.B   896,W0L
00CA2:  MOV.B   W0L,CB6
00CA4:  MOV.B   895,W0L
00CA6:  MOV.B   W0L,CB5
00CA8:  MOV.B   894,W0L
00CAA:  MOV.B   W0L,CB4
.................... 	DiskInfo.TotSect32=make32(dt[35],dt[34],dt[33],dt[32]);		// bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta
00CAC:  MOV.B   89B,W0L
00CAE:  MOV.B   W0L,CBB
00CB0:  MOV.B   89A,W0L
00CB2:  MOV.B   W0L,CBA
00CB4:  MOV.B   899,W0L
00CB6:  MOV.B   W0L,CB9
00CB8:  MOV.B   898,W0L
00CBA:  MOV.B   W0L,CB8
.................... 	DiskInfo.FATsz32 = make32(dt[39],dt[38],dt[37],dt[36]);		// bytes 36..39: Numero de sectores ocupados por una FAT
00CBC:  MOV.B   89F,W0L
00CBE:  MOV.B   W0L,CBF
00CC0:  MOV.B   89E,W0L
00CC2:  MOV.B   W0L,CBE
00CC4:  MOV.B   89D,W0L
00CC6:  MOV.B   W0L,CBD
00CC8:  MOV.B   89C,W0L
00CCA:  MOV.B   W0L,CBC
.................... 	DiskInfo.ExtFlags = make16(dt[41],dt[40]); 					// bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0)
00CCC:  MOV.B   8A0,W0L
00CCE:  MOV.B   W0L,CC0
00CD0:  MOV.B   8A1,W0L
00CD2:  MOV.B   W0L,CC1
.................... 	DiskInfo.FSVer = make16(dt[43],dt[42]); 					// bytes 42..43: Version del sistema de archivos (empleamos la 0.0)
00CD4:  MOV.B   8A2,W0L
00CD6:  MOV.B   W0L,CC2
00CD8:  MOV.B   8A3,W0L
00CDA:  MOV.B   W0L,CC3
.................... 	DiskInfo.RootClus= make32(dt[47],dt[46],dt[45],dt[44]);		// bytes 44..47: Indica el numero del 1er cluster del directorio raiz.
00CDC:  MOV.B   8A7,W0L
00CDE:  MOV.B   W0L,CC7
00CE0:  MOV.B   8A6,W0L
00CE2:  MOV.B   W0L,CC6
00CE4:  MOV.B   8A5,W0L
00CE6:  MOV.B   W0L,CC5
00CE8:  MOV.B   8A4,W0L
00CEA:  MOV.B   W0L,CC4
.................... 	DiskInfo.FSInfo = make16(dt[49],dt[48]); 					// bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1)
00CEC:  MOV.B   8A8,W0L
00CEE:  MOV.B   W0L,CC8
00CF0:  MOV.B   8A9,W0L
00CF2:  MOV.B   W0L,CC9
.................... 	DiskInfo.BkBootSec = make16(dt[51],dt[50]); 				// bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque
00CF4:  MOV.B   8AA,W0L
00CF6:  MOV.B   W0L,CCA
00CF8:  MOV.B   8AB,W0L
00CFA:  MOV.B   W0L,CCB
.................... 	//  Estructura en el caso de FAT32 ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½
.................... 	memcpy((*ptrDiskInfo).RsrvdSys, (ptrSct +  52), 12);		//DiskInfo.RsrvdSys[12] 	// bytes 52..63: Bytes reservados para futuros usos del sistema
00CFC:  MOV     12F8,W5
00CFE:  MOV     #38,W4
00D00:  ADD     W5,W4,W6
00D02:  MOV     #34,W4
00D04:  MOV     12F6,W3
00D06:  ADD     W3,W4,W7
00D08:  MOV     W6,W1
00D0A:  MOV     W7,W2
00D0C:  REPEAT  #B
00D0E:  MOV.B   [W2++],[W1++]
.................... 	DiskInfo.DrvNum = dt[64];								 	// byte  64: 	 Numero de la unidad
00D10:  MOV.B   8B8,W0L
00D12:  MOV.B   W0L,CD8
.................... 	DiskInfo.Reserved1 = dt[65];								// byte  65: 	 Windows NT para formatear un volumen pone este byte a 0
00D14:  MOV.B   8B9,W0L
00D16:  MOV.B   W0L,CD9
.................... 	DiskInfo.BootSig = dt[66]; 									// byte  66: 	 Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows)
00D18:  MOV.B   8BA,W0L
00D1A:  MOV.B   W0L,CDA
.................... 	DiskInfo.VolId = make32(dt[70],dt[69],dt[68],dt[67]); 		// bytes 67..70: Numero de volumen (generado por el reloj del sistema).
00D1C:  MOV.B   8BE,W0L
00D1E:  MOV.B   W0L,CDF
00D20:  MOV.B   8BD,W0L
00D22:  MOV.B   W0L,CDE
00D24:  MOV.B   8BC,W0L
00D26:  MOV.B   W0L,CDD
00D28:  MOV.B   8BB,W0L
00D2A:  MOV.B   W0L,CDC
.................... 	memcpy((*ptrDiskInfo).VolLab, (ptrSct +  71), 11);			//DiskInfo.VolLab[11]	// bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME    "
00D2C:  MOV     12F8,W5
00D2E:  MOV     #4C,W4
00D30:  ADD     W5,W4,W6
00D32:  MOV     #47,W4
00D34:  MOV     12F6,W3
00D36:  ADD     W3,W4,W7
00D38:  MOV     W6,W1
00D3A:  MOV     W7,W2
00D3C:  REPEAT  #A
00D3E:  MOV.B   [W2++],[W1++]
.................... 	memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  82), 8);		//DiskInfo.FilSysType[8] 	// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   "
00D40:  MOV     12F8,W5
00D42:  MOV     #57,W4
00D44:  ADD     W5,W4,W6
00D46:  MOV     #52,W4
00D48:  MOV     12F6,W3
00D4A:  ADD     W3,W4,W7
00D4C:  MOV     W6,W1
00D4E:  MOV     W7,W2
00D50:  REPEAT  #7
00D52:  MOV.B   [W2++],[W1++]
.................... 	memcpy((*ptrDiskInfo).spam, (ptrSct +  90),420);			//DiskInfo.spam[420]		// bytes 90..509:Zona de codigo (en uSD no se emplea y suele estar a 0)
00D54:  MOV     12F8,W5
00D56:  MOV     #5F,W4
00D58:  ADD     W5,W4,W6
00D5A:  MOV     #5A,W4
00D5C:  MOV     12F6,W3
00D5E:  ADD     W3,W4,W7
00D60:  MOV     W6,W1
00D62:  MOV     W7,W2
00D64:  REPEAT  #1A3
00D66:  MOV.B   [W2++],[W1++]
.................... 	DiskInfo.firma = make16(dt[510],dt[511]);								// byte 510..511:Debe de vale 55 AA
00D68:  MOV.B   A77,W0L
00D6A:  MOV.B   W0L,E98
00D6C:  MOV.B   A76,W0L
00D6E:  MOV.B   W0L,E99
.................... 
....................    		FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'3''2'
00D70:  MOV     CEE,W4
00D72:  SUB.B   #30,W4L
00D74:  MOV.B   W4L,W0L
00D76:  MOV.B   W0L,0
00D78:  MOV.B   W0L,W4L
00D7A:  CLR.B   9
00D7C:  MUL.UU  W4,#A,W0
00D7E:  MOV     W0,W5
00D80:  MOV     CEE,W4
00D82:  LSR     W4,#8,W4
00D84:  ADD     W5,W4,W5
00D86:  MOV     #30,W4
00D88:  SUB.B   W5L,W4L,W0L
00D8A:  MOV.B   W0L,E9A
.................... 
....................    if(FATType == 32){
00D8C:  MOV     E9A,W4
00D8E:  XOR.B   #20,W4L
00D90:  BRA     NZ,DA6
.................... 						sect_x_fat  = DiskInfo.FATsz32;		// Sectores reservados para la FAT
00D92:  PUSH    CBC
00D94:  POP     EA4
00D96:  PUSH    CBE
00D98:  POP     EA6
.................... 						startClusterOfRootDirectory = DiskInfo.RootClus;
00D9A:  PUSH    CC4
00D9C:  POP     12EE
00D9E:  PUSH    CC6
00DA0:  POP     12F0
....................  	}else{
00DA2:  GOTO    DD6
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);	//DiskInfo.FilSysType[8] 	// bytes 54..61: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT16   "
*
00DA6:  MOV     12F8,W5
00DA8:  MOV     #57,W4
00DAA:  ADD     W5,W4,W6
00DAC:  MOV     #36,W4
00DAE:  MOV     12F6,W3
00DB0:  ADD     W3,W4,W7
00DB2:  MOV     W6,W1
00DB4:  MOV     W7,W2
00DB6:  REPEAT  #7
00DB8:  MOV.B   [W2++],[W1++]
.................... 						FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'1''6'
00DBA:  MOV     CEE,W4
00DBC:  SUB.B   #30,W4L
00DBE:  MOV.B   W4L,W0L
00DC0:  MOV.B   W0L,0
00DC2:  MOV.B   W0L,W4L
00DC4:  CLR.B   9
00DC6:  MUL.UU  W4,#A,W0
00DC8:  MOV     W0,W5
00DCA:  MOV     CEE,W4
00DCC:  LSR     W4,#8,W4
00DCE:  ADD     W5,W4,W5
00DD0:  MOV     #30,W4
00DD2:  SUB.B   W5L,W4L,W0L
00DD4:  MOV.B   W0L,E9A
.................... 	}
.................... 
.................... 	if(FATType == 16){
00DD6:  MOV     E9A,W4
00DD8:  CP.B    W4L,#10
00DDA:  BRA     NZ,E20
.................... 						DiskInfo.VolId = make32(dt[42],dt[41],dt[40],dt[39]);
00DDC:  MOV.B   8A2,W0L
00DDE:  MOV.B   W0L,CDF
00DE0:  MOV.B   8A1,W0L
00DE2:  MOV.B   W0L,CDE
00DE4:  MOV.B   8A0,W0L
00DE6:  MOV.B   W0L,CDD
00DE8:  MOV.B   89F,W0L
00DEA:  MOV.B   W0L,CDC
.................... 						memcpy((*ptrDiskInfo).VolLab, (ptrSct +  43), 11);
00DEC:  MOV     12F8,W5
00DEE:  MOV     #4C,W4
00DF0:  ADD     W5,W4,W6
00DF2:  MOV     #2B,W4
00DF4:  MOV     12F6,W3
00DF6:  ADD     W3,W4,W7
00DF8:  MOV     W6,W1
00DFA:  MOV     W7,W2
00DFC:  REPEAT  #A
00DFE:  MOV.B   [W2++],[W1++]
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);
00E00:  MOV     12F8,W5
00E02:  MOV     #57,W4
00E04:  ADD     W5,W4,W6
00E06:  MOV     #36,W4
00E08:  MOV     12F6,W3
00E0A:  ADD     W3,W4,W7
00E0C:  MOV     W6,W1
00E0E:  MOV     W7,W2
00E10:  REPEAT  #7
00E12:  MOV.B   [W2++],[W1++]
.................... 
.................... 						sect_x_fat  = DiskInfo.FATsz16;		// Sectores reservados para la FAT
00E14:  PUSH    CAE
00E16:  POP     EA4
00E18:  CLR     EA6
.................... 						startClusterOfRootDirectory = DiskInfo.RootEntCnt;
00E1A:  PUSH    CA8
00E1C:  POP     12EE
00E1E:  CLR     12F0
....................  					}
.................... 
....................   	sect_x_cluster = DiskInfo.SectPerClus;					// Cada cluster tiene este numero de sectores
00E20:  MOV.B   CA2,W0L
00E22:  MOV.B   W0L,E9B
.................... 
....................     			      sctrs  = LBA0;
00E24:  PUSH    A78
00E26:  POP     12F2
00E28:  PUSH    A7A
00E2A:  POP     12F4
.................... 				  	  sctrs += DiskInfo.RsrvdCnt;
00E2C:  MOV     12F2,W0
00E2E:  ADD     CA4,W0
00E30:  MOV     W0,12F2
00E32:  MOV     12F4,W4
00E34:  ADDC    W4,#0,W0
00E36:  MOV     W0,12F4
.................... 	sect_reserv 	= sctrs;								// sectores reservados por el sistema
00E38:  PUSH    12F2
00E3A:  POP     EAC
.................... 
....................     sect_fat_1  	= sctrs;               					// A partir de ahï¿½: FAT 1
00E3C:  PUSH    12F2
00E3E:  POP     E9C
.................... 				  	  sctrs += sect_x_fat;
00E40:  MOV     12F2,W0
00E42:  ADD     EA4,W0
00E44:  MOV     W0,12F2
00E46:  MOV     EA6,W4
00E48:  MOV     12F4,W3
00E4A:  ADDC    W3,W4,W0
00E4C:  MOV     W0,12F4
.................... 	sect_fat_2  	= sctrs;;								// A partir de ahï¿½: FAT 2 (copia de seguridad)
00E4E:  PUSH    12F2
00E50:  POP     E9E
.................... 				  	  sctrs += sect_x_fat;
00E52:  MOV     12F2,W0
00E54:  ADD     EA4,W0
00E56:  MOV     W0,12F2
00E58:  MOV     EA6,W4
00E5A:  MOV     12F4,W3
00E5C:  ADDC    W3,W4,W0
00E5E:  MOV     W0,12F4
.................... 	sect_entry  	= sctrs ;      							// A partir de ahï¿½ empieza el raï¿½z (la lista de ficheros)
00E60:  PUSH    12F2
00E62:  POP     EA8
00E64:  PUSH    12F4
00E66:  POP     EAA
.................... 					  sctrs += sect_x_cluster;
00E68:  MOV     E9A,W4
00E6A:  LSR     W4,#8,W4
00E6C:  MOV     12F2,W3
00E6E:  ADD     W3,W4,W0
00E70:  MOV     W0,12F2
00E72:  MOV     12F4,W3
00E74:  ADDC    W3,#0,W0
00E76:  MOV     W0,12F4
.................... 	sect_ini_datos 	= sctrs ;								// A partir de ahi los datos del fichero
00E78:  PUSH    12F2
00E7A:  POP     EA0
00E7C:  PUSH    12F4
00E7E:  POP     EA2
.................... 
....................     if(FATType == 16)										// RootEntCnt: Numero de entradas de 32 bytes al
00E80:  MOV     E9A,W4
00E82:  CP.B    W4L,#10
00E84:  BRA     NZ,E98
....................     sect_ini_datos = sect_entry+(DiskInfo.RootEntCnt>>4);	// directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
00E86:  MOV     CA8,W0
00E88:  LSR     W0,#4,W0
00E8A:  MOV     EA8,W4
00E8C:  ADD     W0,W4,W0
00E8E:  MOV     W0,EA0
00E90:  MOV     EAA,W4
00E92:  MOV     #0,W3
00E94:  ADDC    W3,W4,W0
00E96:  MOV     W0,EA2
00E98:  MOV     [--W15],W7
00E9A:  MOV     [--W15],W6
00E9C:  MOV     [--W15],W5
00E9E:  RETURN  
.................... 
.................... }//fin initFAT()
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void cargaConfig(unsigned int32 j);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 encontrar_fichero(){
....................    unsigned int8 FicheroEncontrado = 0;
....................    unsigned int32 i;
....................    unsigned int16 j,k=0;
....................    unsigned int32 SctStart = sect_entry;			//inicio Root
....................    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root
....................    unsigned int32 ClstIni  = ((FATType==16)?1:2);
.................... 
....................    unsigned int32 ClstNxt;
....................    unsigned int32 sctrClstr;
....................    unsigned int32 posSctr;
....................    unsigned int32 clstrSig;
.................... 
....................    for(i = SctStart; i < SctEnd; i++){
.................... 	      sd_read_block(i, dt);
.................... 		 for(j = 0; j < 512; j += 32){
.................... 										k=0;
.................... 										if(	(dt[j + 0] == 'C')&&
.................... 											(dt[j + 1] == 'O')&&
.................... 											(dt[j + 2] == 'N')&&
.................... 											(dt[j + 3] == 'F')&&
.................... 											(dt[j + 4] == 'I')&&
.................... 											(dt[j + 5] == 'G')&&
.................... 											(dt[j + 6] == ' ')&&
.................... 											(dt[j + 7] == ' ')&&
.................... 											(dt[j + 8] == 'T')&&
.................... 											(dt[j + 9] == 'X')&&
.................... 											(dt[j +10] == 'T')){
.................... 																 cargaConfig(j);
.................... 																 FicheroEncontrado = 1;
.................... 																 return FicheroEncontrado;
.................... 																}//fin if(CNF)
.................... 
.................... 		}//j
....................    }//i
....................    return FicheroEncontrado;
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void cargaConfig(unsigned int32 j){
....................    unsigned int32 direccion;
....................    unsigned int32 _sector;
.................... 
.................... 	if(FATType==16){
.................... 	   	direccion = make32(0,0,dt[j+27],dt[j+26]);
.................... 		_sector = ((unsigned int32)direccion - 2) * sect_x_cluster + sect_ini_datos;
.................... 	}
.................... 	if(FATType==32){
.................... 	   direccion = make32(dt[j+21],dt[j+20],dt[j+27],dt[j+26]); //en FAT32 se usa EAIndex + first cluster
.................... 	   _sector = ((unsigned int32)direccion - 3) * sect_x_cluster + sect_ini_datos;
....................    }
.................... 	sd_read_block(_sector, dt);
....................    // Ahora en el vector dt tengo los datos del fichero y puedo emplearlo
....................    // Por ejemplo: el texto que indica la hora y minutos del ensayo lo obtendria como:
....................    // hora   = (dt[140]-'0')*10 + dt[141]-'0' ;
....................    // minutos= (dt[143]-'0')*10 + dt[144]-'0' ;
....................    // ... Y con esos datos haria algo util
.................... 
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 inicializa_fichero(){
*
01202:  MOV     W5,[W15++]
01204:  MOV     W6,[W15++]
01206:  CLR.B   12EE
01208:  PUSH    EA8
0120A:  POP     12F6
0120C:  PUSH    EAA
0120E:  POP     12F8
01210:  PUSH    EA0
01212:  POP     12FA
01214:  PUSH    EA2
01216:  POP     12FC
01218:  MOV     E9A,W4
0121A:  CP.B    W4L,#10
0121C:  BRA     NZ,1226
0121E:  MOV     #0,W0
01220:  MOV     #0,W1
01222:  GOTO    122A
*
01226:  MOV     #1,W0
01228:  MOV     #0,W1
0122A:  MOV     W0,12FE
0122C:  MOV     W1,1300
....................    unsigned int8 FicheroIncializado = 0;
....................    unsigned int32 i;
....................    unsigned int16 j;
....................    unsigned int32 SctStart = sect_entry;			//inicio Root
....................    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root
....................    unsigned int32 ClstIni  = ((FATType==16)?0:1);
.................... 
....................    unsigned int32 ClstNxt;
....................    unsigned int32 sctrClstr;
....................    unsigned int32 posSctr;
....................    unsigned int32 clstrSig;
.................... 
....................    unsigned int32 startCluster;      //cluster donde empezarï¿½an los datos del fichero
....................    fileEntry newFile;
.................... 
....................    for(i = SctStart; i < SctEnd; i++){
0122E:  PUSH    12F6
01230:  POP     12F0
01232:  PUSH    12F8
01234:  POP     12F2
01236:  MOV     12F2,W0
01238:  MOV     12FC,W4
0123A:  CP      W4,W0
0123C:  BRA     NC,1568
0123E:  BRA     GTU,1248
01240:  MOV     12F0,W0
01242:  MOV     12FA,W4
01244:  CP      W4,W0
01246:  BRA     LEU,1568
.................... 	      sd_read_block(i, dt);
01248:  PUSH    12F0
0124A:  POP     1346
0124C:  PUSH    12F2
0124E:  POP     1348
01250:  MOV     #878,W4
01252:  MOV     W4,134A
01254:  CALL    908
.................... 		  for(j = 0; j < 512; j += 32){
*
01258:  CLR     12F4
0125A:  MOV     12F4,W4
0125C:  MOV     #200,W3
0125E:  CP      W3,W4
01260:  BRA     LEU,155E
.................... 			if((dt[j] == 0x00) || dt[j] == 0xFF){
01262:  MOV     #878,W4
01264:  MOV     12F4,W3
01266:  ADD     W3,W4,W0
01268:  CP0.B   [W0]
0126A:  BRA     Z,1278
0126C:  MOV     #878,W4
0126E:  MOV     12F4,W3
01270:  ADD     W3,W4,W0
01272:  MOV.B   [W0],W4L
01274:  XOR.B   #FF,W4L
01276:  BRA     NZ,1552
.................... 					   newFile.fields.name[0] = 		'L';
01278:  MOV.B   #4C,W0L
0127A:  MOV.B   W0L,1316
.................... 					   newFile.fields.name[1] = 		'A';
0127C:  MOV.B   #41,W0L
0127E:  MOV.B   W0L,1317
.................... 					   newFile.fields.name[2] = 		'T';
01280:  MOV.B   #54,W0L
01282:  MOV.B   W0L,1318
.................... 					   newFile.fields.name[3] = 		'I';
01284:  MOV.B   #49,W0L
01286:  MOV.B   W0L,1319
.................... 					   newFile.fields.name[4] = 		'D';
01288:  MOV.B   #44,W0L
0128A:  MOV.B   W0L,131A
.................... 					   newFile.fields.name[5] = 		'O';
0128C:  MOV.B   #4F,W0L
0128E:  MOV.B   W0L,131B
.................... 					   newFile.fields.name[6] = 		'S';
01290:  MOV.B   #53,W0L
01292:  MOV.B   W0L,131C
.................... 					   newFile.fields.name[7] = 		'_';
01294:  MOV.B   #5F,W0L
01296:  MOV.B   W0L,131D
.................... 					   newFile.fields.extension[0] = 	'T';
01298:  MOV.B   #54,W0L
0129A:  MOV.B   W0L,131E
.................... 					   newFile.fields.extension[1] = 	'X';
0129C:  MOV.B   #58,W0L
0129E:  MOV.B   W0L,131F
.................... 					   newFile.fields.extension[2] = 	'T';
012A0:  MOV.B   #54,W0L
012A2:  MOV.B   W0L,1320
.................... 					   newFile.fields.reserved = 0;
012A4:  CLR.B   1322
.................... 					   newFile.fields.createTimeMs = 0;
012A6:  CLR.B   1323
.................... 					   newFile.fields.create_hour = getHour();
012A8:  MOV.B   12B3,W0L
012AA:  MOV.B   W0L,W5L
012AC:  CLR.B   B
012AE:  SL      W5,#B,W5
012B0:  MOV.B   12B4,W0L
012B2:  MOV.B   W0L,C
012B4:  CLR.B   D
012B6:  SL      W6,#5,W0
012B8:  ADD     W0,W5,W5
012BA:  MOV.B   12B5,W0L
012BC:  CLR.B   1
012BE:  LSR     W0,#1,W0
012C0:  ADD     W0,W5,W0
012C2:  MOV     W0,1324
.................... 					   newFile.fields.create_date = getDate();
012C4:  MOV     12AE,W4
012C6:  MOV     #7BC,W3
012C8:  SUB     W4,W3,W5
012CA:  SL      W5,#9,W5
012CC:  MOV.B   12B1,W0L
012CE:  MOV.B   W0L,W6L
012D0:  CLR.B   D
012D2:  SL      W6,#5,W0
012D4:  ADD     W0,W5,W5
012D6:  MOV.B   12B2,W0L
012D8:  CLR.B   1
012DA:  ADD     W0,W5,W0
012DC:  MOV     W0,1326
.................... 					   newFile.fields.last_access = newFile.fields.create_date;
012DE:  PUSH    1326
012E0:  POP     1328
.................... 					   newFile.fields.eaIndex = 0;
012E2:  CLR     132A
.................... 					   newFile.fields.attrib = __FILE ;   //archivo normal + sï¿½lo lectura  | READONLY
012E4:  MOV.B   #20,W0L
012E6:  MOV.B   W0L,1321
.................... 					   newFile.fields.modif_hour = newFile.fields.create_hour;
012E8:  PUSH    1324
012EA:  POP     132C
.................... 					   newFile.fields.modif_date = newFile.fields.create_date;
012EC:  PUSH    1326
012EE:  POP     132E
.................... 					   newFile.fields.first_cluster = 0;
012F0:  CLR     1330
.................... 					   newFile.fields.size = 0;
012F2:  CLR     1332
012F4:  CLR     1334
.................... 
.................... 					   file.offsetEntry = j;
012F6:  PUSH    12F4
012F8:  POP     C8E
.................... 					   file.sectorEntryFile = i;
012FA:  PUSH    12F0
012FC:  POP     A8A
012FE:  PUSH    12F2
01300:  POP     A8C
.................... 					   sd_read_block(file.sectorEntryFile, file.EntryFile);
01302:  PUSH    A8A
01304:  POP     1346
01306:  PUSH    A8C
01308:  POP     1348
0130A:  MOV     #A8E,W4
0130C:  MOV     W4,134A
0130E:  CALL    908
.................... 
.................... 					   for(i = 0; i < 32; j++, i++)  dt[j] = newFile.raw[i];
*
01312:  CLR     12F0
01314:  CLR     12F2
01316:  MOV     12F2,W4
01318:  CP      W4,#0
0131A:  BRA     GTU,1342
0131C:  BRA     NC,1326
0131E:  MOV     12F0,W4
01320:  MOV     #20,W3
01322:  CP      W3,W4
01324:  BRA     LEU,1342
01326:  MOV     #878,W4
01328:  MOV     12F4,W3
0132A:  ADD     W3,W4,W5
0132C:  MOV     #1316,W4
0132E:  MOV     12F0,W3
01330:  ADD     W3,W4,W0
01332:  MOV.B   [W0],[W5]
01334:  MOV     12F4,W0
01336:  INC     12F4
01338:  INC     12F0
0133A:  BTSC.B  42.1
0133C:  INC     12F2
0133E:  GOTO    1316
.................... 					   for(i = 0; i < 512; i++)      file.EntryFile[i] = dt[i];
*
01342:  CLR     12F0
01344:  CLR     12F2
01346:  MOV     12F2,W4
01348:  CP      W4,#0
0134A:  BRA     GTU,136E
0134C:  BRA     NC,1356
0134E:  MOV     12F0,W4
01350:  MOV     #200,W3
01352:  CP      W3,W4
01354:  BRA     LEU,136E
01356:  MOV     #A8E,W0
01358:  ADD     12F0,W0
0135A:  MOV     W0,W5
0135C:  MOV     #878,W4
0135E:  MOV     12F0,W3
01360:  ADD     W3,W4,W0
01362:  MOV.B   [W0],[W5]
01364:  INC     12F0
01366:  BTSC.B  42.1
01368:  INC     12F2
0136A:  GOTO    1346
.................... 					   file.posInSector    = 0;   															//empezamos en un sector y cluster nuevos
*
0136E:  CLR     A84
.................... 					   if(FATType==16){
01370:  MOV     E9A,W4
01372:  CP.B    W4L,#10
01374:  BRA     NZ,13CC
.................... 					   startCluster = encontrarCluster(2);         											//busco cluster donde empezarï¿½a a almacenarse los datos
01376:  MOV     #2,W4
01378:  MOV     W4,1336
0137A:  CLR     1338
0137C:  CALL    EF4
*
01380:  MOV     W0,1312
01382:  MOV     W1,1314
.................... 					   file.currentCluster = startCluster;   												//que serï¿½ el cluster en el que escribiremos
01384:  PUSH    1312
01386:  POP     A7C
01388:  PUSH    1314
0138A:  POP     A7E
.................... 					   file.currentSector  = (file.currentCluster -  2) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster)
0138C:  MOV     A7C,W4
0138E:  SUB     W4,#2,W5
01390:  MOV     A7E,W4
01392:  SUBB    W4,#0,W6
01394:  MOV.B   E9B,W0L
01396:  MOV.B   W0L,W2L
01398:  CLR.B   5
0139A:  MOV     #0,W3
0139C:  MOV     W5,W0
0139E:  MOV     W6,W1
013A0:  CALL    109E
*
013A4:  MOV     W0,W5
013A6:  MOV     W1,W6
013A8:  MOV     W5,W0
013AA:  ADD     EA0,W0
013AC:  MOV     W0,A80
013AE:  MOV     EA2,W4
013B0:  ADDC    W6,W4,W0
013B2:  MOV     W0,A82
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 8) + sect_reserv;						//sector en la FAT donde marcar el cluster usado
013B4:  MOV.B   A7D,W0L
013B6:  MOV.B   W0L,W5L
013B8:  MOV.B   A7E,W0L
013BA:  MOV.B   W0L,B
013BC:  MOV.B   A7F,W0L
013BE:  MOV.B   W0L,W6L
013C0:  CLR.B   D
013C2:  MOV     W5,W0
013C4:  ADD     EAC,W0
013C6:  MOV     W0,A86
013C8:  ADDC    W6,#0,W0
013CA:  MOV     W0,A88
.................... 					   }
.................... 					   if(FATType==32){
013CC:  MOV     E9A,W4
013CE:  XOR.B   #20,W4L
013D0:  BRA     NZ,142C
.................... 					   startCluster = encontrarCluster(3);         											//busco cluster donde empezarï¿½a a almacenarse los datos
013D2:  MOV     #3,W4
013D4:  MOV     W4,1336
013D6:  CLR     1338
013D8:  CALL    EF4
*
013DC:  MOV     W0,1312
013DE:  MOV     W1,1314
.................... 					   file.currentCluster = startCluster;   												//que serï¿½ el cluster en el que escribiremos
013E0:  PUSH    1312
013E2:  POP     A7C
013E4:  PUSH    1314
013E6:  POP     A7E
.................... 					   file.currentSector  = (file.currentCluster -  3) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster)
013E8:  MOV     A7C,W4
013EA:  SUB     W4,#3,W5
013EC:  MOV     A7E,W4
013EE:  SUBB    W4,#0,W6
013F0:  MOV.B   E9B,W0L
013F2:  MOV.B   W0L,W2L
013F4:  CLR.B   5
013F6:  MOV     #0,W3
013F8:  MOV     W5,W0
013FA:  MOV     W6,W1
013FC:  CALL    109E
*
01400:  MOV     W0,W5
01402:  MOV     W1,W6
01404:  MOV     W5,W0
01406:  ADD     EA0,W0
01408:  MOV     W0,A80
0140A:  MOV     EA2,W4
0140C:  ADDC    W6,W4,W0
0140E:  MOV     W0,A82
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 7) + sect_reserv;						//sector en la FAT donde marcar el cluster usado
01410:  MOV     #7,W4
01412:  MOV     A7C,W5
01414:  MOV     A7E,W6
01416:  INC     W4,W4
01418:  DEC     W4,W4
0141A:  BRA     Z,1422
0141C:  LSR     W6,W6
0141E:  RRC     W5,W5
01420:  BRA     1418
01422:  MOV     W5,W0
01424:  ADD     EAC,W0
01426:  MOV     W0,A86
01428:  ADDC    W6,#0,W0
0142A:  MOV     W0,A88
.................... 					   }
.................... 					   file.EntryFile[file.offsetEntry + 27] = make8(file.currentCluster, 1); 					//1er cluster del archivo
0142C:  MOV     C8E,W4
0142E:  ADD     W4,#1B,W5
01430:  MOV     #A8E,W4
01432:  ADD     W5,W4,W6
01434:  MOV.B   A7D,W0L
01436:  MOV.B   W0L,[W6]
.................... 					   file.EntryFile[file.offsetEntry + 26] = make8(file.currentCluster, 0);
01438:  MOV     C8E,W4
0143A:  ADD     W4,#1A,W5
0143C:  MOV     #A8E,W4
0143E:  ADD     W5,W4,W6
01440:  MOV.B   A7C,W0L
01442:  MOV.B   W0L,[W6]
.................... 					   file.EntryFile[file.offsetEntry + 21] = make8(file.currentCluster, 3);
01444:  MOV     C8E,W4
01446:  ADD     W4,#15,W5
01448:  MOV     #A8E,W4
0144A:  ADD     W5,W4,W6
0144C:  MOV.B   A7F,W0L
0144E:  MOV.B   W0L,[W6]
.................... 					   file.EntryFile[file.offsetEntry + 20] = make8(file.currentCluster, 2);
01450:  MOV     C8E,W4
01452:  ADD     W4,#14,W5
01454:  MOV     #A8E,W4
01456:  ADD     W5,W4,W6
01458:  MOV.B   A7E,W0L
0145A:  MOV.B   W0L,[W6]
.................... 					   file.size = 0;																			//Inicialmente el tamaï¿½o es cero
0145C:  CLR     C90
0145E:  CLR     C92
.................... 
.................... 					   if(FATType==16){
01460:  MOV     E9A,W4
01462:  CP.B    W4L,#10
01464:  BRA     NZ,14D0
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile);
01466:  PUSH    A8A
01468:  POP     133A
0146A:  PUSH    A8C
0146C:  POP     133C
0146E:  MOV     #A8E,W4
01470:  MOV     W4,133E
01472:  CALL    10CE
.................... 						sd_read_block (file.sectorAtFAT, sector_fat16);
*
01476:  PUSH    A86
01478:  POP     1346
0147A:  PUSH    A88
0147C:  POP     1348
0147E:  MOV     #10AE,W4
01480:  MOV     W4,134A
01482:  CALL    908
.................... 						sector_fat16[file.currentCluster % MAX_ENTRIES_SECTOR_FAT16] = ENDFILE16;				//marco el cluster como usado
*
01486:  MOV     A7C,W5
01488:  AND     #FF,W5
0148A:  CLR     W6
0148C:  MOV     #1,W4
0148E:  MOV     W5,W0
01490:  MOV     W6,W1
01492:  INC     W4,W4
01494:  DEC     W4,W4
01496:  BRA     Z,149E
01498:  SL      W0,W0
0149A:  RLC     W1,W1
0149C:  BRA     1494
0149E:  MOV     #10AE,W4
014A0:  ADD     W0,W4,W5
014A2:  SETM.B  [W5]
014A4:  MOV.B   #FF,W0L
014A6:  MOV.B   W0L,[W5+#1]
.................... 						sd_write_block( file.sectorAtFAT, sector_fat16);
014A8:  PUSH    A86
014AA:  POP     133A
014AC:  PUSH    A88
014AE:  POP     133C
014B0:  MOV     #10AE,W4
014B2:  MOV     W4,133E
014B4:  CALL    10CE
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat16);   //FAT2					//ï¿½Ojo! la cosa puede ser mas complicada...
*
014B8:  MOV     A86,W0
014BA:  ADD     EA4,W0
014BC:  MOV     W0,W5
014BE:  MOV     A88,W0
014C0:  ADDC    EA6,W0
014C2:  MOV     W0,W6
014C4:  MOV     W5,133A
014C6:  MOV     W6,133C
014C8:  MOV     #10AE,W4
014CA:  MOV     W4,133E
014CC:  CALL    10CE
.................... 						}
.................... 					   if(FATType==32){
*
014D0:  MOV     E9A,W4
014D2:  XOR.B   #20,W4L
014D4:  BRA     NZ,1548
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile);
014D6:  PUSH    A8A
014D8:  POP     133A
014DA:  PUSH    A8C
014DC:  POP     133C
014DE:  MOV     #A8E,W4
014E0:  MOV     W4,133E
014E2:  CALL    10CE
.................... 						sd_read_block (file.sectorAtFAT,sector_fat32);
*
014E6:  PUSH    A86
014E8:  POP     1346
014EA:  PUSH    A88
014EC:  POP     1348
014EE:  MOV     #EAE,W4
014F0:  MOV     W4,134A
014F2:  CALL    908
.................... 						sector_fat32[file.currentCluster % MAX_ENTRIES_SECTOR_FAT32] = ENDFILE32;				//marco el cluster como usado
*
014F6:  MOV     A7C,W5
014F8:  AND     #7F,W5
014FA:  CLR     W6
014FC:  MOV     #2,W4
014FE:  MOV     W5,W0
01500:  MOV     W6,W1
01502:  INC     W4,W4
01504:  DEC     W4,W4
01506:  BRA     Z,150E
01508:  SL      W0,W0
0150A:  RLC     W1,W1
0150C:  BRA     1504
0150E:  MOV     #EAE,W4
01510:  ADD     W0,W4,W5
01512:  SETM.B  [W5]
01514:  MOV.B   #FF,W0L
01516:  MOV.B   W0L,[W5+#1]
01518:  MOV.B   #FF,W0L
0151A:  MOV.B   W0L,[W5+#2]
0151C:  MOV.B   #F,W0L
0151E:  MOV.B   W0L,[W5+#3]
.................... 						sd_write_block( file.sectorAtFAT, sector_fat32);
01520:  PUSH    A86
01522:  POP     133A
01524:  PUSH    A88
01526:  POP     133C
01528:  MOV     #EAE,W4
0152A:  MOV     W4,133E
0152C:  CALL    10CE
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat32);   //FAT2					//ï¿½Ojo! la cosa puede ser mas complicada...
*
01530:  MOV     A86,W0
01532:  ADD     EA4,W0
01534:  MOV     W0,W5
01536:  MOV     A88,W0
01538:  ADDC    EA6,W0
0153A:  MOV     W0,W6
0153C:  MOV     W5,133A
0153E:  MOV     W6,133C
01540:  MOV     #EAE,W4
01542:  MOV     W4,133E
01544:  CALL    10CE
.................... 						}
.................... 					   FicheroIncializado = 1;
*
01548:  MOV.B   #1,W0L
0154A:  MOV.B   W0L,12EE
.................... 					   return FicheroIncializado;
0154C:  MOV.B   12EE,W0L
0154E:  MOV.B   W0L,0
01550:  BRA     156C
.................... 					   }
01552:  MOV     #20,W4
01554:  MOV     12F4,W3
01556:  ADD     W3,W4,W0
01558:  MOV     W0,12F4
0155A:  GOTO    125A
.................... 
.................... 		}//j
*
0155E:  INC     12F0
01560:  BTSC.B  42.1
01562:  INC     12F2
01564:  GOTO    1236
....................    }//i
....................    return FicheroIncializado;
*
01568:  MOV.B   12EE,W0L
0156A:  MOV.B   W0L,0
0156C:  MOV     [--W15],W6
0156E:  MOV     [--W15],W5
01570:  RETURN  
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart){
*
00EF4:  MOV     W5,[W15++]
00EF6:  MOV     W6,[W15++]
....................    unsigned int32 cluster;
....................    unsigned int32 _sector;   //recorrer sectores
....................    unsigned int32 bytes;     //recorrer bytes en cada sector
.................... 
....................    cluster =  clusterStart;
00EF8:  PUSH    1336
00EFA:  POP     133A
00EFC:  PUSH    1338
00EFE:  POP     133C
....................    if(FATType==16)
00F00:  MOV     E9A,W4
00F02:  CP.B    W4L,#10
00F04:  BRA     NZ,F22
....................    _sector = (clusterStart >> 2) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante
00F06:  MOV     #2,W4
00F08:  MOV     1336,W5
00F0A:  MOV     1338,W6
00F0C:  INC     W4,W4
00F0E:  DEC     W4,W4
00F10:  BRA     Z,F18
00F12:  LSR     W6,W6
00F14:  RRC     W5,W5
00F16:  BRA     F0E
00F18:  MOV     W5,W0
00F1A:  ADD     E9C,W0
00F1C:  MOV     W0,133E
00F1E:  ADDC    W6,#0,W0
00F20:  MOV     W0,1340
....................    if(FATType==32)
00F22:  MOV     E9A,W4
00F24:  XOR.B   #20,W4L
00F26:  BRA     NZ,F44
....................    _sector = (clusterStart >> 3) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante
00F28:  MOV     #3,W4
00F2A:  MOV     1336,W5
00F2C:  MOV     1338,W6
00F2E:  INC     W4,W4
00F30:  DEC     W4,W4
00F32:  BRA     Z,F3A
00F34:  LSR     W6,W6
00F36:  RRC     W5,W5
00F38:  BRA     F30
00F3A:  MOV     W5,W0
00F3C:  ADD     E9C,W0
00F3E:  MOV     W0,133E
00F40:  ADDC    W6,#0,W0
00F42:  MOV     W0,1340
....................    bytes = (clusterStart % ((FATType==16) ? MAX_ENTRIES_SECTOR_FAT16 : MAX_ENTRIES_SECTOR_FAT32));
00F44:  MOV     E9A,W4
00F46:  CP.B    W4L,#10
00F48:  BRA     NZ,F52
00F4A:  MOV     #100,W0
00F4C:  MOV     #0,W1
00F4E:  GOTO    F56
*
00F52:  MOV     #80,W0
00F54:  MOV     #0,W1
00F56:  BSET.B  43.0
00F58:  MOV     W0,W2
00F5A:  MOV     W1,W3
00F5C:  MOV     1336,W0
00F5E:  MOV     1338,W1
00F60:  CALL    EA0
*
00F64:  MOV     W0,1342
00F66:  MOV     W1,1344
.................... 
....................    if(FATType==32){
00F68:  MOV     E9A,W4
00F6A:  XOR.B   #20,W4L
00F6C:  BRA     NZ,FFC
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT
00F6E:  MOV     1340,W4
00F70:  CP      W4,#0
00F72:  BRA     GTU,FF8
00F74:  BRA     NC,F7E
00F76:  MOV     133E,W0
00F78:  MOV     E9E,W4
00F7A:  CP      W4,W0
00F7C:  BRA     LEU,FF8
.................... 		  sd_read_block(_sector,sector_fat32); 							//leemos el sector
00F7E:  PUSH    133E
00F80:  POP     1346
00F82:  PUSH    1340
00F84:  POP     1348
00F86:  MOV     #EAE,W4
00F88:  MOV     W4,134A
00F8A:  CALL    908
....................     					      for(; bytes < MAX_ENTRIES_SECTOR_FAT32; bytes++){ //recorremos el sector para buscar un puntero a cluster libre
*
00F8E:  MOV     1344,W4
00F90:  CP      W4,#0
00F92:  BRA     GTU,FEA
00F94:  BRA     NC,F9E
00F96:  MOV     1342,W4
00F98:  MOV     #80,W3
00F9A:  CP      W3,W4
00F9C:  BRA     LEU,FEA
.................... 					         if(sector_fat32[bytes]== 0){
00F9E:  MOV     #2,W4
00FA0:  MOV     1342,W0
00FA2:  MOV     1344,W1
00FA4:  INC     W4,W4
00FA6:  DEC     W4,W4
00FA8:  BRA     Z,FB0
00FAA:  SL      W0,W0
00FAC:  RLC     W1,W1
00FAE:  BRA     FA6
00FB0:  MOV     #EAE,W4
00FB2:  ADD     W0,W4,W0
00FB4:  MOV     #A,W4
00FB6:  MOV     [W0++],[W4++]
00FB8:  MOV     [W0++],[W4++]
00FBA:  CP0     W5
00FBC:  BRA     NZ,FDA
00FBE:  CP0     W6
00FC0:  BRA     NZ,FDA
.................... 					            if(cluster < 3)               continue;  	//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando
00FC2:  MOV     133C,W4
00FC4:  CP      W4,#0
00FC6:  BRA     GTU,FD4
00FC8:  BRA     NC,FD0
00FCA:  MOV     133A,W4
00FCC:  CP      W4,#3
00FCE:  BRA     C,FD4
00FD0:  GOTO    FE0
.................... 					            return cluster;
*
00FD4:  MOV     133A,W0
00FD6:  MOV     133C,W1
00FD8:  BRA     1098
.................... 					         }//fin if
.................... 					         cluster++;
00FDA:  INC     133A
00FDC:  BTSC.B  42.1
00FDE:  INC     133C
00FE0:  INC     1342
00FE2:  BTSC.B  42.1
00FE4:  INC     1344
00FE6:  GOTO    F8E
.................... 					      }//fin for de recorrer bytes dentro de un sector
.................... 	      bytes = 0;
*
00FEA:  CLR     1342
00FEC:  CLR     1344
00FEE:  INC     133E
00FF0:  BTSC.B  42.1
00FF2:  INC     1340
00FF4:  GOTO    F6E
.................... 	   }//fin for de recorrer sectores
....................    }else
*
00FF8:  GOTO    1084
....................     if(FATType==16){
*
00FFC:  MOV     E9A,W4
00FFE:  CP.B    W4L,#10
01000:  BRA     NZ,1084
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT
01002:  MOV     1340,W4
01004:  CP      W4,#0
01006:  BRA     GTU,1084
01008:  BRA     NC,1012
0100A:  MOV     133E,W0
0100C:  MOV     E9E,W4
0100E:  CP      W4,W0
01010:  BRA     LEU,1084
.................... 		  sd_read_block(_sector,sector_fat16); 							//leemos el sector
01012:  PUSH    133E
01014:  POP     1346
01016:  PUSH    1340
01018:  POP     1348
0101A:  MOV     #10AE,W4
0101C:  MOV     W4,134A
0101E:  CALL    908
.................... 
.................... 					      for(; bytes < MAX_ENTRIES_SECTOR_FAT16; bytes++){ 	//recorremos el sector para buscar un puntero a cluster libre
*
01022:  MOV     1344,W4
01024:  CP      W4,#0
01026:  BRA     GTU,1076
01028:  BRA     NC,1032
0102A:  MOV     1342,W4
0102C:  MOV     #100,W3
0102E:  CP      W3,W4
01030:  BRA     LEU,1076
.................... 					         if(sector_fat16[bytes]== 0){
01032:  MOV     #1,W4
01034:  MOV     1342,W0
01036:  MOV     1344,W1
01038:  INC     W4,W4
0103A:  DEC     W4,W4
0103C:  BRA     Z,1044
0103E:  SL      W0,W0
01040:  RLC     W1,W1
01042:  BRA     103A
01044:  MOV     #10AE,W4
01046:  ADD     W0,W4,W0
01048:  MOV     [W0],W5
0104A:  CP0     W5
0104C:  BRA     NZ,1066
.................... 					            if(cluster < 2)               continue;		//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando
0104E:  MOV     133C,W4
01050:  CP      W4,#0
01052:  BRA     GTU,1060
01054:  BRA     NC,105C
01056:  MOV     133A,W4
01058:  CP      W4,#2
0105A:  BRA     C,1060
0105C:  GOTO    106C
.................... 					            return cluster;
*
01060:  MOV     133A,W0
01062:  MOV     133C,W1
01064:  BRA     1098
.................... 					         }//fin if
.................... 					         cluster++;
01066:  INC     133A
01068:  BTSC.B  42.1
0106A:  INC     133C
0106C:  INC     1342
0106E:  BTSC.B  42.1
01070:  INC     1344
01072:  GOTO    1022
.................... 					      }//fin for de recorrer bytes dentro de un sector
.................... 	      bytes = 0;
*
01076:  CLR     1342
01078:  CLR     1344
0107A:  INC     133E
0107C:  BTSC.B  42.1
0107E:  INC     1340
01080:  GOTO    1002
.................... 	   }//fin for de recorrer sectores
.................... 	}
....................    return ((FATType==16)?ENDFILE16:ENDFILE32);
*
01084:  MOV     E9A,W4
01086:  CP.B    W4L,#10
01088:  BRA     NZ,1092
0108A:  MOV     #FFFF,W0
0108C:  MOV     #0,W1
0108E:  GOTO    1096
*
01092:  MOV     #FFFF,W0
01094:  MOV     #FFF,W1
01096:  MOV.D   W0,W0
01098:  MOV     [--W15],W6
0109A:  MOV     [--W15],W5
0109C:  RETURN  
.................... }//fin encontrarCluster
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... extern int cont;
.................... void escribe_datos_en_fichero(){
*
01C68:  MOV     W5,[W15++]
01C6A:  MOV     W6,[W15++]
01C6C:  MOV     W7,[W15++]
....................    unsigned int32 relSector;
....................    unsigned int32 nextCluster;
....................    unsigned int32  oldCluster;
....................    unsigned int16 _hour, date;
.................... 
.................... 	sd_write_block(file.currentSector, dt);
01C6E:  PUSH    A80
01C70:  POP     133A
01C72:  PUSH    A82
01C74:  POP     133C
01C76:  MOV     #878,W4
01C78:  MOV     W4,133E
01C7A:  CALL    10CE
.................... 
.................... 
.................... 		if(cont>127)
*
01C7E:  MOV     12B6,W4
01C80:  MOV     #7F,W3
01C82:  CP      W3,W4
01C84:  BRA     GE,1C8C
.................... 		{
.................... 	 		file.currentSector++;	//actualizar las FATs
01C86:  INC     0A80
01C88:  BTSC.B  42.1
01C8A:  INC     0A82
.................... 		}
.................... 
.................... 
.................... 		if(FATType==16)
01C8C:  MOV     E9A,W4
01C8E:  CP.B    W4L,#10
01C90:  BRA     NZ,1CC2
.................... 	    relSector= file.currentSector - ((file.currentCluster -  2) * sect_x_cluster + sect_ini_datos);
01C92:  MOV     A7C,W4
01C94:  SUB     W4,#2,W5
01C96:  MOV     A7E,W4
01C98:  SUBB    W4,#0,W6
01C9A:  MOV.B   E9B,W0L
01C9C:  MOV.B   W0L,W2L
01C9E:  CLR.B   5
01CA0:  MOV     #0,W3
01CA2:  MOV     W5,W0
01CA4:  MOV     W6,W1
01CA6:  CALL    109E
*
01CAA:  MOV     W0,W5
01CAC:  MOV     W1,W6
01CAE:  MOV     W5,W0
01CB0:  ADD     EA0,W0
01CB2:  MOV     EA2,W4
01CB4:  ADDC    W6,W4,W1
01CB6:  MOV     A80,W4
01CB8:  SUB     W4,W0,W0
01CBA:  MOV     W0,12F0
01CBC:  MOV     A82,W4
01CBE:  SUBB    W4,W1,W0
01CC0:  MOV     W0,12F2
.................... 		if(FATType==32)
01CC2:  MOV     E9A,W4
01CC4:  XOR.B   #20,W4L
01CC6:  BRA     NZ,1CF8
.................... 	    relSector= file.currentSector - ((file.currentCluster -  3) * sect_x_cluster + sect_ini_datos);
01CC8:  MOV     A7C,W4
01CCA:  SUB     W4,#3,W5
01CCC:  MOV     A7E,W4
01CCE:  SUBB    W4,#0,W6
01CD0:  MOV.B   E9B,W0L
01CD2:  MOV.B   W0L,W2L
01CD4:  CLR.B   5
01CD6:  MOV     #0,W3
01CD8:  MOV     W5,W0
01CDA:  MOV     W6,W1
01CDC:  CALL    109E
*
01CE0:  MOV     W0,W5
01CE2:  MOV     W1,W6
01CE4:  MOV     W5,W0
01CE6:  ADD     EA0,W0
01CE8:  MOV     EA2,W4
01CEA:  ADDC    W6,W4,W1
01CEC:  MOV     A80,W4
01CEE:  SUB     W4,W0,W0
01CF0:  MOV     W0,12F0
01CF2:  MOV     A82,W4
01CF4:  SUBB    W4,W1,W0
01CF6:  MOV     W0,12F2
.................... 
.................... 	    if(((relSector % sect_x_cluster) == 0)&&(relSector!=0)){   											//ï¿½el siguiente sector estï¿½ en cluster nuevo?
01CF8:  BSET.B  43.0
01CFA:  MOV.B   E9B,W0L
01CFC:  MOV.B   W0L,W2L
01CFE:  CLR.B   5
01D00:  MOV     #0,W3
01D02:  MOV     12F0,W0
01D04:  MOV     12F2,W1
01D06:  CALL    EA0
*
01D0A:  MOV     W0,W5
01D0C:  MOV     W1,W6
01D0E:  CP0     W5
01D10:  BRA     NZ,1D9A
01D12:  CP0     W6
01D14:  BRA     NZ,1D9A
01D16:  CP0     12F0
01D18:  BRA     NZ,1D1E
01D1A:  CP0     12F2
01D1C:  BRA     Z,1D9A
.................... 	      oldCluster = 	file.currentCluster;
01D1E:  PUSH    A7C
01D20:  POP     12F8
01D22:  PUSH    A7E
01D24:  POP     12FA
.................... 	      nextCluster = encontrarCluster(oldCluster);   									//siguiente cluster
01D26:  PUSH    12F8
01D28:  POP     1336
01D2A:  PUSH    12FA
01D2C:  POP     1338
01D2E:  CALL    EF4
*
01D32:  MOV     W0,12F4
01D34:  MOV     W1,12F6
.................... 	      //escribirCluster(oldCluster, nextCluster);  										//marcar actual cluster para que apunte al siguiente
.................... 	      file.currentCluster = nextCluster;
01D36:  PUSH    12F4
01D38:  POP     A7C
01D3A:  PUSH    12F6
01D3C:  POP     A7E
.................... 		  if(FATType==16)
01D3E:  MOV     E9A,W4
01D40:  CP.B    W4L,#10
01D42:  BRA     NZ,1D6C
.................... 	      file.currentSector = (nextCluster - 2) * sect_x_cluster + sect_ini_datos;
01D44:  MOV     12F4,W4
01D46:  SUB     W4,#2,W5
01D48:  MOV     12F6,W4
01D4A:  SUBB    W4,#0,W6
01D4C:  MOV.B   E9B,W0L
01D4E:  MOV.B   W0L,W2L
01D50:  CLR.B   5
01D52:  MOV     #0,W3
01D54:  MOV     W5,W0
01D56:  MOV     W6,W1
01D58:  CALL    109E
*
01D5C:  MOV     W0,W5
01D5E:  MOV     W1,W6
01D60:  MOV     W5,W0
01D62:  ADD     EA0,W0
01D64:  MOV     W0,A80
01D66:  MOV     EA2,W4
01D68:  ADDC    W6,W4,W0
01D6A:  MOV     W0,A82
.................... 		  if(FATType==32)
01D6C:  MOV     E9A,W4
01D6E:  XOR.B   #20,W4L
01D70:  BRA     NZ,1D9A
.................... 	      file.currentSector = (nextCluster - 3) * sect_x_cluster + sect_ini_datos;
01D72:  MOV     12F4,W4
01D74:  SUB     W4,#3,W5
01D76:  MOV     12F6,W4
01D78:  SUBB    W4,#0,W6
01D7A:  MOV.B   E9B,W0L
01D7C:  MOV.B   W0L,W2L
01D7E:  CLR.B   5
01D80:  MOV     #0,W3
01D82:  MOV     W5,W0
01D84:  MOV     W6,W1
01D86:  CALL    109E
*
01D8A:  MOV     W0,W5
01D8C:  MOV     W1,W6
01D8E:  MOV     W5,W0
01D90:  ADD     EA0,W0
01D92:  MOV     W0,A80
01D94:  MOV     EA2,W4
01D96:  ADDC    W6,W4,W0
01D98:  MOV     W0,A82
.................... 	   }
.................... 
.................... 	   //actualizar el tamaï¿½o del fichero y fechas
.................... 	   file.size += 4; //512 estaba antes
01D9A:  MOV     C90,W4
01D9C:  ADD     W4,#4,W0
01D9E:  MOV     W0,C90
01DA0:  MOV     C92,W4
01DA2:  ADDC    W4,#0,W0
01DA4:  MOV     W0,C92
.................... 	   file.EntryFile[file.offsetEntry + 28] = make8(file.size, 0);   //tamaï¿½o
01DA6:  MOV     C8E,W4
01DA8:  ADD     W4,#1C,W5
01DAA:  MOV     #A8E,W4
01DAC:  ADD     W5,W4,W6
01DAE:  MOV.B   C90,W0L
01DB0:  MOV.B   W0L,[W6]
.................... 	   file.EntryFile[file.offsetEntry + 29] = make8(file.size, 1);
01DB2:  MOV     C8E,W4
01DB4:  ADD     W4,#1D,W5
01DB6:  MOV     #A8E,W4
01DB8:  ADD     W5,W4,W6
01DBA:  MOV.B   C91,W0L
01DBC:  MOV.B   W0L,[W6]
.................... 	   file.EntryFile[file.offsetEntry + 30] = make8(file.size, 2);
01DBE:  MOV     C8E,W4
01DC0:  ADD     W4,#1E,W5
01DC2:  MOV     #A8E,W4
01DC4:  ADD     W5,W4,W6
01DC6:  MOV.B   C92,W0L
01DC8:  MOV.B   W0L,[W6]
.................... 	   file.EntryFile[file.offsetEntry + 31] = make8(file.size, 3);
01DCA:  MOV     C8E,W4
01DCC:  ADD     W4,#1F,W5
01DCE:  MOV     #A8E,W4
01DD0:  ADD     W5,W4,W6
01DD2:  MOV.B   C93,W0L
01DD4:  MOV.B   W0L,[W6]
.................... 	   //ActualizaReloj();
.................... 	   _hour = getHour();
01DD6:  MOV.B   12B3,W0L
01DD8:  MOV.B   W0L,W5L
01DDA:  CLR.B   B
01DDC:  SL      W5,#B,W5
01DDE:  MOV.B   12B4,W0L
01DE0:  MOV.B   W0L,C
01DE2:  CLR.B   D
01DE4:  SL      W6,#5,W0
01DE6:  ADD     W0,W5,W5
01DE8:  MOV.B   12B5,W0L
01DEA:  CLR.B   1
01DEC:  LSR     W0,#1,W0
01DEE:  ADD     W0,W5,W0
01DF0:  MOV     W0,12FC
.................... 	   date = getDate();
01DF2:  MOV     12AE,W4
01DF4:  MOV     #7BC,W3
01DF6:  SUB     W4,W3,W5
01DF8:  SL      W5,#9,W5
01DFA:  MOV.B   12B1,W0L
01DFC:  MOV.B   W0L,W6L
01DFE:  CLR.B   D
01E00:  SL      W6,#5,W0
01E02:  ADD     W0,W5,W5
01E04:  MOV.B   12B2,W0L
01E06:  CLR.B   1
01E08:  ADD     W0,W5,W0
01E0A:  MOV     W0,12FE
.................... 	   file.EntryFile[file.offsetEntry + 24] = make8(date, 0);       //fecha modif
01E0C:  MOV     C8E,W4
01E0E:  ADD     W4,#18,W5
01E10:  MOV     #A8E,W4
01E12:  ADD     W5,W4,W6
01E14:  MOV.B   12FE,W0L
01E16:  MOV.B   W0L,[W6]
.................... 	   file.EntryFile[file.offsetEntry + 25] = make8(date, 1);
01E18:  MOV     C8E,W4
01E1A:  ADD     W4,#19,W5
01E1C:  MOV     #A8E,W4
01E1E:  ADD     W5,W4,W6
01E20:  MOV.B   12FF,W0L
01E22:  MOV.B   W0L,[W6]
.................... 	   file.EntryFile[file.offsetEntry + 22] = make8(_hour, 0);      //hora modif
01E24:  MOV     C8E,W4
01E26:  ADD     W4,#16,W5
01E28:  MOV     #A8E,W4
01E2A:  ADD     W5,W4,W6
01E2C:  MOV.B   12FC,W0L
01E2E:  MOV.B   W0L,[W6]
.................... 	   file.EntryFile[file.offsetEntry + 23] = make8(_hour, 1);
01E30:  MOV     C8E,W4
01E32:  ADD     W4,#17,W5
01E34:  MOV     #A8E,W4
01E36:  ADD     W5,W4,W6
01E38:  MOV.B   12FD,W0L
01E3A:  MOV.B   W0L,[W6]
.................... 	   file.EntryFile[file.offsetEntry + 18] = file.EntryFile[file.offsetEntry + 24];   //fecha ï¿½ltimo acceso
01E3C:  MOV     C8E,W4
01E3E:  ADD     W4,#12,W5
01E40:  MOV     #A8E,W4
01E42:  ADD     W5,W4,W6
01E44:  MOV     C8E,W4
01E46:  ADD     W4,#18,W7
01E48:  MOV     #A8E,W4
01E4A:  ADD     W7,W4,W0
01E4C:  MOV.B   [W0],[W6]
.................... 	   file.EntryFile[file.offsetEntry + 19] = file.EntryFile[file.offsetEntry + 25];
01E4E:  MOV     C8E,W4
01E50:  ADD     W4,#13,W5
01E52:  MOV     #A8E,W4
01E54:  ADD     W5,W4,W6
01E56:  MOV     C8E,W4
01E58:  ADD     W4,#19,W7
01E5A:  MOV     #A8E,W4
01E5C:  ADD     W7,W4,W0
01E5E:  MOV.B   [W0],[W6]
.................... 
.................... 	   sd_write_block(file.sectorEntryFile, file.EntryFile);  	// Actualiza root
01E60:  PUSH    A8A
01E62:  POP     133A
01E64:  PUSH    A8C
01E66:  POP     133C
01E68:  MOV     #A8E,W4
01E6A:  MOV     W4,133E
01E6C:  CALL    10CE
.................... 		 if(cont>127)
*
01E70:  MOV     12B6,W4
01E72:  MOV     #7F,W3
01E74:  CP      W3,W4
01E76:  BRA     GE,1E82
.................... 		 	{
....................  			//file.currentSector++;	//actualizar las FATs
....................  			memset(dt,0,512);
01E78:  MOV     #878,W1
01E7A:  MOV     #0,W2
01E7C:  REPEAT  #1FF
01E7E:  CLR.B   [W1++]
....................  			cont = 0;
01E80:  CLR     12B6
....................  			}
01E82:  MOV     [--W15],W7
01E84:  MOV     [--W15],W6
01E86:  MOV     [--W15],W5
01E88:  RETURN  
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void sd_init_global(){
....................   set_tris_b(0b1111111110011111);
*
01572:  MOV     #FF9F,W4
01574:  MOV     W4,2C8
....................   set_tris_c(0b1111111111011111);
01576:  MOV     #FFDF,W4
01578:  MOV     W4,2D0
....................   delay_ms(30);
0157A:  MOV     #1E,W0
0157C:  CALL    750
.................... 
....................   sd_init();	// Inicializa micro SD
*
01580:  CALL    9DC
.................... 
....................   initFAT();	// Carga los parametros del sistema de ficheros
*
01584:  CALL    C18
.................... 	inicializa_fichero();
*
01588:  CALL    1202
*
0158C:  RETURN  
.................... }
.................... 
.................... #include "sdcard.h"
.................... #bit  SPIRBF    = getenv("SFR:SPI1STAT").0
.................... #bit  SPITBF    = getenv("SFR:SPI1STAT").1
.................... #bit  SPIROV    = getenv("SFR:SPI1STAT").6
.................... #byte SPI1BUF   = getenv("SFR:SPI1BUF")
.................... #byte SPI1STAT  = getenv("SFR:SPI1STAT")
.................... #byte SPI1CON1  = getenv("SFR:SPI1CON1")
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define   CMD0              		0x40      //go to idle				//Commands
.................... #define   CMD1               		0x41      //initialization process
.................... #define   CMD8               		0x48      //verify interface
.................... #define   CMD17              		0x51      //read single block
.................... #define   CMD24              		0x58      //write single block
.................... #define   CMD55              		0x77      //escape for app specific command
.................... #define   CMD58              		0x7a      //read OCR
.................... #define   ACMD41             		0x69      //poll operation range
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define   R1_READY_STATE          	0x00      //sd ready				//Responses
.................... #define   R1_IDLE_STATE           	0x01      //card in idle state
.................... #define   R1_ILLEGAL_COMMAND      	0x04      //illegal command
.................... #define   DATA_START_BLOCK       	0xFE      //start token for read or write
.................... #define   DATA_RES_MASK          	0x1F      //mask for data response
.................... #define   DATA_RES_ACCEPTED      	0x05      //write accepted
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sdhc;
.................... extern unsigned int8 dt[512];            /// Buffer de escritura  en uSD
.................... unsigned int32 LBA0 = 0;
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... inline unsigned int8 xfer_spi(char envio){
....................    SPIROV = 0;
*
00826:  BCLR.B  240.6
*
0083C:  BCLR.B  240.6
*
0085A:  BCLR.B  240.6
*
0087A:  BCLR.B  240.6
*
0089A:  BCLR.B  240.6
*
008BA:  BCLR.B  240.6
*
008D2:  BCLR.B  240.6
*
008E6:  BCLR.B  240.6
*
0093C:  BCLR.B  240.6
*
00970:  BCLR.B  240.6
*
0098E:  BCLR.B  240.6
*
009A2:  BCLR.B  240.6
*
009B6:  BCLR.B  240.6
*
00A18:  BCLR.B  240.6
*
00A74:  BCLR.B  240.6
*
00A8A:  BCLR.B  240.6
*
00AA0:  BCLR.B  240.6
*
00AB6:  BCLR.B  240.6
*
00B54:  BCLR.B  240.6
*
00B6A:  BCLR.B  240.6
*
00B80:  BCLR.B  240.6
*
00B96:  BCLR.B  240.6
*
01104:  BCLR.B  240.6
*
0111A:  BCLR.B  240.6
*
01144:  BCLR.B  240.6
*
01160:  BCLR.B  240.6
*
01174:  BCLR.B  240.6
*
01188:  BCLR.B  240.6
*
011A8:  BCLR.B  240.6
*
011C8:  BCLR.B  240.6
*
011DC:  BCLR.B  240.6
....................    SPI1BUF= envio;
*
00828:  MOV.B   135A,W0L
0082A:  MOV.B   W0L,248
*
0083E:  MOV.B   135A,W0L
00840:  MOV.B   W0L,248
*
0085C:  MOV.B   135A,W0L
0085E:  MOV.B   W0L,248
*
0087C:  MOV.B   135A,W0L
0087E:  MOV.B   W0L,248
*
0089C:  MOV.B   135A,W0L
0089E:  MOV.B   W0L,248
*
008BC:  MOV.B   135A,W0L
008BE:  MOV.B   W0L,248
*
008D4:  MOV.B   135A,W0L
008D6:  MOV.B   W0L,248
*
008E8:  MOV.B   135A,W0L
008EA:  MOV.B   W0L,248
*
0093E:  MOV.B   135A,W0L
00940:  MOV.B   W0L,248
*
00972:  MOV.B   135A,W0L
00974:  MOV.B   W0L,248
*
00990:  MOV.B   135A,W0L
00992:  MOV.B   W0L,248
*
009A4:  MOV.B   135A,W0L
009A6:  MOV.B   W0L,248
*
009B8:  MOV.B   135A,W0L
009BA:  MOV.B   W0L,248
*
00A1A:  MOV.B   135A,W0L
00A1C:  MOV.B   W0L,248
*
00A76:  MOV.B   135A,W0L
00A78:  MOV.B   W0L,248
*
00A8C:  MOV.B   135A,W0L
00A8E:  MOV.B   W0L,248
*
00AA2:  MOV.B   135A,W0L
00AA4:  MOV.B   W0L,248
*
00AB8:  MOV.B   135A,W0L
00ABA:  MOV.B   W0L,248
*
00B56:  MOV.B   135A,W0L
00B58:  MOV.B   W0L,248
*
00B6C:  MOV.B   135A,W0L
00B6E:  MOV.B   W0L,248
*
00B82:  MOV.B   135A,W0L
00B84:  MOV.B   W0L,248
*
00B98:  MOV.B   135A,W0L
00B9A:  MOV.B   W0L,248
*
01106:  MOV.B   135A,W0L
01108:  MOV.B   W0L,248
*
0111C:  MOV.B   135A,W0L
0111E:  MOV.B   W0L,248
*
01146:  MOV.B   135A,W0L
01148:  MOV.B   W0L,248
*
01162:  MOV.B   135A,W0L
01164:  MOV.B   W0L,248
*
01176:  MOV.B   135A,W0L
01178:  MOV.B   W0L,248
*
0118A:  MOV.B   135A,W0L
0118C:  MOV.B   W0L,248
*
011AA:  MOV.B   135A,W0L
011AC:  MOV.B   W0L,248
*
011CA:  MOV.B   135A,W0L
011CC:  MOV.B   W0L,248
*
011DE:  MOV.B   135A,W0L
011E0:  MOV.B   W0L,248
....................    while( SPITBF);
*
0082C:  BTSC.B  240.1
0082E:  BRA     82C
*
00842:  BTSC.B  240.1
00844:  BRA     842
*
00860:  BTSC.B  240.1
00862:  BRA     860
*
00880:  BTSC.B  240.1
00882:  BRA     880
*
008A0:  BTSC.B  240.1
008A2:  BRA     8A0
*
008C0:  BTSC.B  240.1
008C2:  BRA     8C0
*
008D8:  BTSC.B  240.1
008DA:  BRA     8D8
*
008EC:  BTSC.B  240.1
008EE:  BRA     8EC
*
00942:  BTSC.B  240.1
00944:  BRA     942
*
00976:  BTSC.B  240.1
00978:  BRA     976
*
00994:  BTSC.B  240.1
00996:  BRA     994
*
009A8:  BTSC.B  240.1
009AA:  BRA     9A8
*
009BC:  BTSC.B  240.1
009BE:  BRA     9BC
*
00A1E:  BTSC.B  240.1
00A20:  BRA     A1E
*
00A7A:  BTSC.B  240.1
00A7C:  BRA     A7A
*
00A90:  BTSC.B  240.1
00A92:  BRA     A90
*
00AA6:  BTSC.B  240.1
00AA8:  BRA     AA6
*
00ABC:  BTSC.B  240.1
00ABE:  BRA     ABC
*
00B5A:  BTSC.B  240.1
00B5C:  BRA     B5A
*
00B70:  BTSC.B  240.1
00B72:  BRA     B70
*
00B86:  BTSC.B  240.1
00B88:  BRA     B86
*
00B9C:  BTSC.B  240.1
00B9E:  BRA     B9C
*
0110A:  BTSC.B  240.1
0110C:  BRA     110A
*
01120:  BTSC.B  240.1
01122:  BRA     1120
*
0114A:  BTSC.B  240.1
0114C:  BRA     114A
*
01166:  BTSC.B  240.1
01168:  BRA     1166
*
0117A:  BTSC.B  240.1
0117C:  BRA     117A
*
0118E:  BTSC.B  240.1
01190:  BRA     118E
*
011AE:  BTSC.B  240.1
011B0:  BRA     11AE
*
011CE:  BTSC.B  240.1
011D0:  BRA     11CE
*
011E2:  BTSC.B  240.1
011E4:  BRA     11E2
....................    while(!SPIRBF);
*
00830:  BTSS.B  240.0
00832:  BRA     830
*
00846:  BTSS.B  240.0
00848:  BRA     846
*
00864:  BTSS.B  240.0
00866:  BRA     864
*
00884:  BTSS.B  240.0
00886:  BRA     884
*
008A4:  BTSS.B  240.0
008A6:  BRA     8A4
*
008C4:  BTSS.B  240.0
008C6:  BRA     8C4
*
008DC:  BTSS.B  240.0
008DE:  BRA     8DC
*
008F0:  BTSS.B  240.0
008F2:  BRA     8F0
*
00946:  BTSS.B  240.0
00948:  BRA     946
*
0097A:  BTSS.B  240.0
0097C:  BRA     97A
*
00998:  BTSS.B  240.0
0099A:  BRA     998
*
009AC:  BTSS.B  240.0
009AE:  BRA     9AC
*
009C0:  BTSS.B  240.0
009C2:  BRA     9C0
*
00A22:  BTSS.B  240.0
00A24:  BRA     A22
*
00A7E:  BTSS.B  240.0
00A80:  BRA     A7E
*
00A94:  BTSS.B  240.0
00A96:  BRA     A94
*
00AAA:  BTSS.B  240.0
00AAC:  BRA     AAA
*
00AC0:  BTSS.B  240.0
00AC2:  BRA     AC0
*
00B5E:  BTSS.B  240.0
00B60:  BRA     B5E
*
00B74:  BTSS.B  240.0
00B76:  BRA     B74
*
00B8A:  BTSS.B  240.0
00B8C:  BRA     B8A
*
00BA0:  BTSS.B  240.0
00BA2:  BRA     BA0
*
0110E:  BTSS.B  240.0
01110:  BRA     110E
*
01124:  BTSS.B  240.0
01126:  BRA     1124
*
0114E:  BTSS.B  240.0
01150:  BRA     114E
*
0116A:  BTSS.B  240.0
0116C:  BRA     116A
*
0117E:  BTSS.B  240.0
01180:  BRA     117E
*
01192:  BTSS.B  240.0
01194:  BRA     1192
*
011B2:  BTSS.B  240.0
011B4:  BRA     11B2
*
011D2:  BTSS.B  240.0
011D4:  BRA     11D2
*
011E6:  BTSS.B  240.0
011E8:  BRA     11E6
....................    return SPI1BUF;
*
00834:  MOV.B   248,W0L
00836:  MOV.B   W0L,0
*
0084A:  MOV.B   248,W0L
0084C:  MOV.B   W0L,0
*
00868:  MOV.B   248,W0L
0086A:  MOV.B   W0L,0
0086C:  MOV     [--W15],W5
*
00888:  MOV.B   248,W0L
0088A:  MOV.B   W0L,0
0088C:  MOV     [--W15],W5
*
008A8:  MOV.B   248,W0L
008AA:  MOV.B   W0L,0
008AC:  MOV     [--W15],W5
*
008C8:  MOV.B   248,W0L
008CA:  MOV.B   W0L,0
008CC:  MOV     [--W15],W5
*
008E0:  MOV.B   248,W0L
008E2:  MOV.B   W0L,0
*
008F4:  MOV.B   248,W0L
008F6:  MOV.B   W0L,0
*
0094A:  MOV.B   248,W0L
0094C:  MOV.B   W0L,0
*
0097E:  MOV.B   248,W0L
00980:  MOV.B   W0L,0
00982:  MOV     [--W15],W5
*
0099C:  MOV.B   248,W0L
0099E:  MOV.B   W0L,0
*
009B0:  MOV.B   248,W0L
009B2:  MOV.B   W0L,0
*
009C4:  MOV.B   248,W0L
009C6:  MOV.B   W0L,0
*
00A26:  MOV.B   248,W0L
00A28:  MOV.B   W0L,0
*
00A82:  MOV.B   248,W0L
00A84:  MOV.B   W0L,0
*
00A98:  MOV.B   248,W0L
00A9A:  MOV.B   W0L,0
*
00AAE:  MOV.B   248,W0L
00AB0:  MOV.B   W0L,0
*
00AC4:  MOV.B   248,W0L
00AC6:  MOV.B   W0L,0
*
00B62:  MOV.B   248,W0L
00B64:  MOV.B   W0L,0
*
00B78:  MOV.B   248,W0L
00B7A:  MOV.B   W0L,0
*
00B8E:  MOV.B   248,W0L
00B90:  MOV.B   W0L,0
*
00BA4:  MOV.B   248,W0L
00BA6:  MOV.B   W0L,0
*
01112:  MOV.B   248,W0L
01114:  MOV.B   W0L,0
*
01128:  MOV.B   248,W0L
0112A:  MOV.B   W0L,0
*
01152:  MOV.B   248,W0L
01154:  MOV.B   W0L,0
01156:  MOV     [--W15],W5
*
0116E:  MOV.B   248,W0L
01170:  MOV.B   W0L,0
*
01182:  MOV.B   248,W0L
01184:  MOV.B   W0L,0
*
01196:  MOV.B   248,W0L
01198:  MOV.B   W0L,0
*
011B6:  MOV.B   248,W0L
011B8:  MOV.B   W0L,0
*
011D6:  MOV.B   248,W0L
011D8:  MOV.B   W0L,0
*
011EA:  MOV.B   248,W0L
011EC:  MOV.B   W0L,0
.................... }//fin xfer_spi
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 Commnd(char befF, int32 SD_Adress, char befH){
*
00822:  MOV     W5,[W15++]
....................    unsigned int8 iC1;
....................    xfer_spi(0xFF);
00824:  SETM.B  135A
....................    xfer_spi(befF);
*
00838:  MOV.B   1350,W0L
0083A:  MOV.B   W0L,135A
....................    xfer_spi(make8(SD_Adress, 3));
*
0084E:  MOV.B   1355,W0L
00850:  MOV.B   W0L,W5L
00852:  MOV     W5,[W15++]
00854:  PUSH    135A
00856:  MOV.B   W5L,[W15-#2]
00858:  POP     135A
....................    xfer_spi(make8(SD_Adress, 2));
*
0086E:  MOV.B   1354,W0L
00870:  MOV.B   W0L,A
00872:  MOV     W5,[W15++]
00874:  PUSH    135A
00876:  MOV.B   W5L,[W15-#2]
00878:  POP     135A
....................    xfer_spi(make8(SD_Adress, 1));
*
0088E:  MOV.B   1353,W0L
00890:  MOV.B   W0L,W5L
00892:  MOV     W5,[W15++]
00894:  PUSH    135A
00896:  MOV.B   W5L,[W15-#2]
00898:  POP     135A
....................    xfer_spi(make8(SD_Adress, 0));
*
008AE:  MOV.B   1352,W0L
008B0:  MOV.B   W0L,A
008B2:  MOV     W5,[W15++]
008B4:  PUSH    135A
008B6:  MOV.B   W5L,[W15-#2]
008B8:  POP     135A
....................    xfer_spi(befH);
*
008CE:  MOV.B   1351,W0L
008D0:  MOV.B   W0L,135A
....................     do{iC1 = xfer_spi(0xFF);
*
008E4:  SETM.B  135A
*
008F8:  MOV.B   W0L,1356
....................    }while(iC1 == 0xFF);
008FA:  MOV     1356,W4
008FC:  XOR.B   #FF,W4L
008FE:  BRA     Z,8E4
....................    return iC1;
00900:  MOV.B   1356,W0L
00902:  MOV.B   W0L,0
00904:  MOV     [--W15],W5
00906:  RETURN  
.................... }//fin Commnd
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_init(){
*
009DC:  MOV     W5,[W15++]
*
009F0:  MOV.B   #1,W0L
009F2:  MOV.B   W0L,12EE
009F4:  CLR     1304
009F6:  CLR     1306
....................  unsigned  int8 R[17]={0}, versionSD= 1, crc;
*
009DE:  CLR     12F0
009E0:  CLR     12F2
009E2:  CLR     12F4
009E4:  CLR     12F6
009E6:  CLR     12F8
009E8:  CLR     12FA
009EA:  CLR     12FC
009EC:  CLR     12FE
009EE:  CLR.B   1300
....................  unsigned int16 iI;
....................  unsigned int32 arg=0;
.................... 
....................  setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_16);
*
009F8:  BCLR.B  241.7
009FA:  BCLR.B  240.6
009FC:  MOV     #13D,W4
009FE:  MOV     W4,242
00A00:  BSET.B  241.7
.................... 
....................  memset(dt,0,512);
00A02:  MOV     #878,W1
00A04:  MOV     #0,W2
00A06:  REPEAT  #1FF
00A08:  CLR.B   [W1++]
....................  // CMD0 - GO_IDLE_STATE  (R1)ï¿½ ï¿½ Card Reset  ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 	do{	output_high(CS);   	// tarjeta deshabilitada
00A0A:  BCLR.B  2D0.5
00A0C:  BSET.B  2D4.5
.................... 		for (iI = 0; iI < 10; iI++)  	xfer_spi(0xFF);
00A0E:  CLR     1302
00A10:  MOV     1302,W4
00A12:  CP      W4,#A
00A14:  BRA     C,A30
00A16:  SETM.B  135A
*
00A2A:  INC     1302
00A2C:  GOTO    A10
.................... 		output_low(CS); 	// tarjeta habilitada
*
00A30:  BCLR.B  2D0.5
00A32:  BCLR.B  2D4.5
.................... 		R[0] = Commnd( CMD0 , 0x00000000 , 0x95); //go to idle
00A34:  MOV.B   #40,W0L
00A36:  MOV.B   W0L,1350
00A38:  MOV.B   #95,W0L
00A3A:  MOV.B   W0L,1351
00A3C:  CLR     1352
00A3E:  CLR     1354
00A40:  CALL    822
*
00A44:  MOV.B   W0L,12F0
.................... 	}while( R[0] != R1_IDLE_STATE);
00A46:  MOV     12F0,W4
00A48:  CP.B    W4L,#1
00A4A:  BRA     NZ,A0A
....................   // CMD8 - SEND_IF_COND (R7)  ï¿½ Send Interface Condition Commandï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // Argument 00 - 00 - 01 (Voltage supplied = 2.7-3.6V) - AA (Check pattern)
....................   // Response: illegal command -> Version 1
....................   // Response: echo-back 	   -> Version 2
.................... 	R[0] = Commnd(CMD8, 0x000001AA, 0x87);
00A4C:  MOV.B   #48,W0L
00A4E:  MOV.B   W0L,1350
00A50:  MOV.B   #87,W0L
00A52:  MOV.B   W0L,1351
00A54:  MOV     #1AA,W4
00A56:  MOV     W4,1352
00A58:  CLR     1354
00A5A:  CALL    822
*
00A5E:  MOV.B   W0L,12F0
....................     if(R[0]& R1_ILLEGAL_COMMAND){	  			versionSD = 1;
00A60:  MOV.B   12F0,W0L
00A62:  CLR.B   1
00A64:  AND     W0,#4,W0
00A66:  CP0     W0
00A68:  BRA     Z,A72
00A6A:  MOV.B   #1,W0L
00A6C:  MOV.B   W0L,12EE
....................    			}else{	R[1] = xfer_spi(0xFF);
00A6E:  GOTO    ADE
*
00A72:  SETM.B  135A
*
00A86:  MOV.B   W0L,12F1
.................... 					R[2] = xfer_spi(0xFF);
00A88:  SETM.B  135A
*
00A9C:  MOV.B   W0L,12F2
.................... 					R[3] = xfer_spi(0xFF);
00A9E:  SETM.B  135A
*
00AB2:  MOV.B   W0L,12F3
.................... 					R[4] = xfer_spi(0xFF);
00AB4:  SETM.B  135A
*
00AC8:  MOV.B   W0L,12F4
.................... 				    if(R[4]!=0xAA){	output_high(CS); return 1; }		//error
00ACA:  MOV     12F4,W4
00ACC:  XOR.B   #AA,W4L
00ACE:  BRA     Z,ADA
00AD0:  BCLR.B  2D0.5
00AD2:  BSET.B  2D4.5
00AD4:  MOV.B   #1,W0L
00AD6:  MOV.B   W0L,0
00AD8:  BRA     C14
....................       											versionSD = 2;
00ADA:  MOV.B   #2,W0L
00ADC:  MOV.B   W0L,12EE
....................    			}
.................... 
....................   // ACMD41 - SD_SEND_OP_ COND (R1) ï¿½ ï¿½ Initialization Command   ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // If host supports SDHC or SDXC: HCS (Host Capacity Support) is set to 1 (arg= 0x40000000)
....................   // If host only support SDSC:     HCS (Host Capacity Support) is set to 0 (arg= 0)
....................    arg = (versionSD == 2) ? 0x40000000 : 0;
00ADE:  MOV     12EE,W4
00AE0:  CP.B    W4L,#2
00AE2:  BRA     NZ,AEC
00AE4:  MOV     #0,W0
00AE6:  MOV     #4000,W1
00AE8:  GOTO    AF0
*
00AEC:  MOV     #0,W0
00AEE:  MOV     #0,W1
00AF0:  MOV     W0,1304
00AF2:  MOV     W1,1306
....................    crc = (versionSD == 2) ? 0x77 : 0xFF;
00AF4:  MOV     12EE,W4
00AF6:  CP.B    W4L,#2
00AF8:  BRA     NZ,B00
00AFA:  MOV.B   #77,W0L
00AFC:  GOTO    B02
*
00B00:  SETM.B  W0
00B02:  MOV.B   W0L,12EF
.................... 
.................... 
....................    do{            Commnd(CMD55,    0, 0x65);	// El proceso puede llegar a durar hasta 1 segundo
00B04:  MOV.B   #77,W0L
00B06:  MOV.B   W0L,1350
00B08:  MOV.B   #65,W0L
00B0A:  MOV.B   W0L,1351
00B0C:  CLR     1352
00B0E:  CLR     1354
00B10:  CALL    822
....................            R[0] = Commnd(ACMD41, arg, crc);		// Application-Specific Command ï¿½ APP_CMD (CMD55)
*
00B14:  MOV.B   #69,W0L
00B16:  MOV.B   W0L,1350
00B18:  MOV.B   12EF,W0L
00B1A:  MOV.B   W0L,1351
00B1C:  PUSH    1304
00B1E:  POP     1352
00B20:  PUSH    1306
00B22:  POP     1354
00B24:  CALL    822
*
00B28:  MOV.B   W0L,12F0
.................... 		   delay_ms(4);
00B2A:  REPEAT  #1662
00B2C:  NOP     
00B2E:  REPEAT  #3FFF
00B30:  NOP     
....................    }while(R[0] != R1_READY_STATE);
00B32:  CP0.B   12F0
00B34:  BRA     NZ,B04
.................... 
....................   if(versionSD == 2){
00B36:  MOV     12EE,W4
00B38:  CP.B    W4L,#2
00B3A:  BRA     NZ,BD0
.................... 
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // CMD58 - READ_OCR (R3) ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // Bit 30 - Card Capacity Status bit: 	0 indicates that the card is SDSC.
....................   //										1 indicates that the card is SDHC or SDXC
.................... 	R[0] = Commnd(CMD58, 0x00000000, 0xFF);
00B3C:  MOV.B   #7A,W0L
00B3E:  MOV.B   W0L,1350
00B40:  MOV.B   #FF,W0L
00B42:  MOV.B   W0L,1351
00B44:  CLR     1352
00B46:  CLR     1354
00B48:  CALL    822
*
00B4C:  MOV.B   W0L,12F0
....................     if(R[0] == R1_READY_STATE){	R[1] = xfer_spi(0xFF);
00B4E:  CP0.B   12F0
00B50:  BRA     NZ,BC6
00B52:  SETM.B  135A
*
00B66:  MOV.B   W0L,12F1
.................... 								R[2] = xfer_spi(0xFF);
00B68:  SETM.B  135A
*
00B7C:  MOV.B   W0L,12F2
.................... 								R[3] = xfer_spi(0xFF);
00B7E:  SETM.B  135A
*
00B92:  MOV.B   W0L,12F3
.................... 								R[4] = xfer_spi(0xFF);
00B94:  SETM.B  135A
*
00BA8:  MOV.B   W0L,12F4
.................... 								sdhc = ((R[1]& 0xC0) == 0xC0) ? 1 : 0;
00BAA:  MOV.B   12F1,W0L
00BAC:  CLR.B   1
00BAE:  MOV.B   W0L,W5L
00BB0:  AND     #C0,W5
00BB2:  MOV     #C0,W4
00BB4:  CP      W4,W5
00BB6:  BRA     NZ,BBE
00BB8:  MOV.B   #1,W0L
00BBA:  GOTO    BC0
*
00BBE:  CLR.B   W0
00BC0:  MOV.B   W0L,12B8
....................    			}else{				output_high(CS); return 1; }		//error
00BC2:  GOTO    BD0
*
00BC6:  BCLR.B  2D0.5
00BC8:  BSET.B  2D4.5
00BCA:  MOV.B   #1,W0L
00BCC:  MOV.B   W0L,0
00BCE:  BRA     C14
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 
....................   }// versionSD == 2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
....................   setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_1);
00BD0:  BCLR.B  241.7
00BD2:  BCLR.B  240.6
00BD4:  MOV     #13F,W4
00BD6:  MOV     W4,242
00BD8:  BSET.B  241.7
.................... 
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 	sd_read_block(0, dt);	//Lee el sector fisico 0 para obtener el LBA0
00BDA:  CLR     1346
00BDC:  CLR     1348
00BDE:  MOV     #878,W4
00BE0:  MOV     W4,134A
00BE2:  CALL    908
.................... 	if(dt[510]==0x55)
*
00BE6:  MOV     A76,W4
00BE8:  XOR.B   #55,W4L
00BEA:  BRA     NZ,C0E
.................... 	if(dt[511]==0xAA){ 		// Efectivamente parece que estoy en sct 0
00BEC:  MOV     A76,W4
00BEE:  LSR     W4,#8,W4
00BF0:  XOR.B   #AA,W4L
00BF2:  BRA     NZ,C0E
.................... 							// Tabla de particiones
.................... 								LBA0 = make32(dt[457],dt[456],dt[455],dt[454]);
00BF4:  MOV.B   A41,W0L
00BF6:  MOV.B   W0L,A7B
00BF8:  MOV.B   A40,W0L
00BFA:  MOV.B   W0L,A7A
00BFC:  MOV.B   A3F,W0L
00BFE:  MOV.B   W0L,A79
00C00:  MOV.B   A3E,W0L
00C02:  MOV.B   W0L,A78
.................... 								if(dt[0]==0xEB) // MBR
00C04:  MOV     878,W4
00C06:  XOR.B   #EB,W4L
00C08:  BRA     NZ,C0E
....................  								LBA0 = 0;
00C0A:  CLR     A78
00C0C:  CLR     A7A
.................... 						  }//55AA
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 
....................   output_high(CS);   									// tarjeta deshabilitada
00C0E:  BCLR.B  2D0.5
00C10:  BSET.B  2D4.5
....................   return 0;
00C12:  CLR.B   0
00C14:  MOV     [--W15],W5
00C16:  RETURN  
.................... }//char sd_init()- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr){
*
010CE:  MOV     W5,[W15++]
....................    unsigned int16 iW;
.................... 
....................    if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores
010D0:  CP0.B   12B8
010D2:  BRA     NZ,10E2
010D4:  MOV     #9,W4
010D6:  INC     W4,W4
010D8:  DEC     W4,W4
010DA:  BRA     Z,10E2
010DC:  SL      133A
010DE:  RLC     133C
010E0:  BRA     10D8
....................    output_low(CS);
010E2:  BCLR.B  2D0.5
010E4:  BCLR.B  2D4.5
.................... 
.................... 		iW = Commnd(CMD24, address, 0xFF);
010E6:  MOV.B   #58,W0L
010E8:  MOV.B   W0L,1350
010EA:  MOV.B   #FF,W0L
010EC:  MOV.B   W0L,1351
010EE:  PUSH    133A
010F0:  POP     1352
010F2:  PUSH    133C
010F4:  POP     1354
010F6:  CALL    822
*
010FA:  MOV.B   W0L,1340
010FC:  CLR.B   1341
....................     if( iW == R1_READY_STATE){
010FE:  CP0     1340
01100:  BRA     NZ,11F6
....................              								              		xfer_spi(0xFF);
01102:  SETM.B  135A
....................                               									xfer_spi(DATA_START_BLOCK);   // Data start token
*
01116:  MOV.B   #FE,W0L
01118:  MOV.B   W0L,135A
....................                            			for(iW = 0; iW < 512; iW++)  xfer_spi(ptr[iW]);
*
0112C:  CLR     1340
0112E:  MOV     1340,W4
01130:  MOV     #200,W3
01132:  CP      W3,W4
01134:  BRA     LEU,115E
01136:  MOV     1340,W0
01138:  ADD     133E,W0
0113A:  MOV.B   [W0],W5L
0113C:  MOV     W5,[W15++]
0113E:  PUSH    135A
01140:  MOV.B   W5L,[W15-#2]
01142:  POP     135A
*
01158:  INC     1340
0115A:  GOTO    112E
....................                            							xfer_spi(0xFF);   // Dummy bytes
*
0115E:  SETM.B  135A
....................                           							xfer_spi(0xFF);   // en lugar del CRC16
*
01172:  SETM.B  135A
.................... 
....................                         do{       iW = xfer_spi(0xFF);
*
01186:  SETM.B  135A
*
0119A:  MOV.B   W0L,1340
0119C:  CLR.B   1341
....................                         }while( (iW & DATA_RES_MASK) != DATA_RES_ACCEPTED);
0119E:  MOV     1340,W0
011A0:  AND     W0,#1F,W5
011A2:  CP      W5,#5
011A4:  BRA     NZ,1186
.................... 
....................                         do{       iW = xfer_spi(0xFF); delay_us(100);
011A6:  SETM.B  135A
*
011BA:  MOV.B   W0L,1340
011BC:  CLR.B   1341
011BE:  REPEAT  #226
011C0:  NOP     
....................                         }while(   iW == 0 );
011C2:  CP0     1340
011C4:  BRA     Z,11A6
.................... 
.................... 						xfer_spi(0xFF);
011C6:  SETM.B  135A
.................... 						xfer_spi(0xFF);
*
011DA:  SETM.B  135A
.................... 
....................    						output_high(CS);   return 0; //correcto
*
011EE:  BCLR.B  2D0.5
011F0:  BSET.B  2D4.5
011F2:  CLR.B   0
011F4:  BRA     11FE
.................... 						}
....................    						output_high(CS);   return 1; //error
011F6:  BCLR.B  2D0.5
011F8:  BSET.B  2D4.5
011FA:  MOV.B   #1,W0L
011FC:  MOV.B   W0L,0
011FE:  MOV     [--W15],W5
01200:  RETURN  
.................... }//fin sd_write_block
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr){
*
00908:  MOV     W5,[W15++]
....................    unsigned int16 jR;
....................    unsigned int8  iR;
.................... 
....................     if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores
0090A:  CP0.B   12B8
0090C:  BRA     NZ,91C
0090E:  MOV     #9,W4
00910:  INC     W4,W4
00912:  DEC     W4,W4
00914:  BRA     Z,91C
00916:  SL      1346
00918:  RLC     1348
0091A:  BRA     912
....................     output_low(CS);
0091C:  BCLR.B  2D0.5
0091E:  BCLR.B  2D4.5
.................... 
....................        iR  = Commnd(CMD17, address, 0xFF);
00920:  MOV.B   #51,W0L
00922:  MOV.B   W0L,1350
00924:  MOV.B   #FF,W0L
00926:  MOV.B   W0L,1351
00928:  PUSH    1346
0092A:  POP     1352
0092C:  PUSH    1348
0092E:  POP     1354
00930:  CALL    822
*
00934:  MOV.B   W0L,134C
....................     if(iR == R1_READY_STATE){
00936:  CP0.B   134C
00938:  BRA     NZ,9D0
.................... 								do{     iR  = xfer_spi(0xFF);
0093A:  SETM.B  135A
*
0094E:  MOV.B   W0L,134C
.................... 								}while( iR != DATA_START_BLOCK);
00950:  MOV     134C,W4
00952:  XOR.B   #FE,W4L
00954:  BRA     NZ,93A
.................... 
.................... 								if(iR == DATA_START_BLOCK){
00956:  MOV     134C,W4
00958:  XOR.B   #FE,W4L
0095A:  BRA     NZ,9C8
.................... 								for(jR = 0; jR < 512; jR++)
0095C:  CLR     134E
0095E:  MOV     134E,W4
00960:  MOV     #200,W3
00962:  CP      W3,W4
00964:  BRA     LEU,98C
.................... 								         ptr[jR] = xfer_spi(0xFF);
00966:  MOV     134E,W0
00968:  ADD     134A,W0
0096A:  MOV     W0,W5
0096C:  MOV     W5,[W15++]
0096E:  SETM.B  135A
*
00984:  MOV.B   W0L,[W5]
00986:  INC     134E
00988:  GOTO    95E
.................... 								xfer_spi(0xFF);
*
0098C:  SETM.B  135A
.................... 								xfer_spi(0xFF);
*
009A0:  SETM.B  135A
.................... 								xfer_spi(0xFF);
*
009B4:  SETM.B  135A
....................   								}
.................... 
....................    							output_high(CS);      return 0;
*
009C8:  BCLR.B  2D0.5
009CA:  BSET.B  2D4.5
009CC:  CLR.B   0
009CE:  BRA     9D8
.................... 							}
.................... 							output_high(CS);      return 1;
009D0:  BCLR.B  2D0.5
009D2:  BSET.B  2D4.5
009D4:  MOV.B   #1,W0L
009D6:  MOV.B   W0L,0
009D8:  MOV     [--W15],W5
009DA:  RETURN  
.................... }//fin sd_read_block
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... int cont = 0;
.................... char cadena[32];
.................... int jj;
.................... //Escritura en el fichero LATIDOS
.................... void escritura_sd(int ppm){
*
01E8A:  MOV     W5,[W15++]
01E8C:  MOV     W6,[W15++]
....................  sprintf(cadena,"%03d\n",ppm); //Escribe ppm en el archivo LATIDOS
01E8E:  MOV     #12BA,W4
01E90:  MOV     W4,12DC
01E92:  MOV     12EE,W0
01E94:  MOV     #8003,W4
01E96:  CALL    1A12
*
01E9A:  MOV.B   #A,W0L
01E9C:  CALL    1A04
....................  output_toggle(H1);
*
01EA0:  BCLR.B  2C9.6
01EA2:  BTG.B   2CD.6
.................... 
....................  for(jj=0;jj<4;jj++)
01EA4:  CLR     12DA
01EA6:  MOV     12DA,W4
01EA8:  CP      W4,#4
01EAA:  BRA     GE,1EC6
....................  {
....................    dt[jj+(cont*4)] = cadena[jj];
01EAC:  MOV     12B6,W4
01EAE:  MUL.UU  W4,#4,W0
01EB0:  MOV     12DA,W4
01EB2:  ADD     W0,W4,W5
01EB4:  MOV     #878,W4
01EB6:  ADD     W5,W4,W6
01EB8:  MOV     #12BA,W4
01EBA:  MOV     12DA,W3
01EBC:  ADD     W3,W4,W0
01EBE:  MOV.B   [W0],[W6]
01EC0:  INC     12DA
01EC2:  GOTO    1EA6
....................  }
.................... 
.................... cont++;
*
01EC6:  INC     12B6
.................... escribe_datos_en_fichero();
01EC8:  CALL    1C68
*
01ECC:  MOV     [--W15],W6
01ECE:  MOV     [--W15],W5
01ED0:  RETURN  
.................... //memset(dt,0,512);
.................... }
.................... 
.................... #include "BLUETOOTH.h"
.................... #ifndef Bluetooth_h
.................... #define Bluetooth_h
.................... #include "Header.h"
.................... #ifndef Header_h
.................... #define Header_h
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses HS
.................... #fuses PR
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock= 11059200)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON( pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define III            PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		   PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDO1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDI1 =     PIN_B7  //                    (43)
.................... #define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use rs232(UART1,baud=115200,STREAM=BT)
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void init_BT(void); //inits and enables uart isr
.................... void enviar_datos(unsigned int16 ppm);
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void init_BT(void)
.................... {
....................   	fprintf(BT,"$$$");	     delay_ms(500); // command mode
*
00760:  BTSC.B  223.1
00762:  BRA     760
00764:  MOV     #24,W4
00766:  MOV     W4,224
00768:  BTSC.B  223.1
0076A:  BRA     768
0076C:  MOV     #24,W4
0076E:  MOV     W4,224
00770:  BTSC.B  223.1
00772:  BRA     770
00774:  MOV     #24,W4
00776:  MOV     W4,224
00778:  MOV     #1F4,W0
0077A:  CALL    750
....................   	fprintf(BT,"SF,1\r");      delay_ms(500); // factory defaults
*
0077E:  MOV     #0,W1
00780:  MOV     W1,W0
00782:  CLR.B   1
00784:  CALL    200
*
00788:  INC     W1,W1
0078A:  BTSC.B  223.1
0078C:  BRA     78A
0078E:  MOV     W0,224
00790:  MOV     #4,W0
00792:  CPSGT   W1,W0
00794:  BRA     780
00796:  MOV     #1F4,W0
00798:  CALL    750
....................   	fprintf(BT,"SA,0\r");      delay_ms(500); // authentication 'Open'
*
0079C:  MOV     #0,W1
0079E:  MOV     W1,W0
007A0:  CLR.B   1
007A2:  CALL    212
*
007A6:  INC     W1,W1
007A8:  BTSC.B  223.1
007AA:  BRA     7A8
007AC:  MOV     W0,224
007AE:  MOV     #4,W0
007B0:  CPSGT   W1,W0
007B2:  BRA     79E
007B4:  MOV     #1F4,W0
007B6:  CALL    750
....................   	fprintf(BT,"R,1\r");       delay_ms(5000); // Run device
*
007BA:  MOV     #0,W1
007BC:  MOV     W1,W0
007BE:  CLR.B   1
007C0:  CALL    224
*
007C4:  INC     W1,W1
007C6:  BTSC.B  223.1
007C8:  BRA     7C6
007CA:  MOV     W0,224
007CC:  MOV     #3,W0
007CE:  CPSGT   W1,W0
007D0:  BRA     7BC
007D2:  MOV     #1388,W0
007D4:  CALL    750
....................     fprintf(BT,"$Representacion grafica,Funcion,datos 1\n");
*
007D8:  MOV     #0,W1
007DA:  MOV     W1,W0
007DC:  CLR.B   1
007DE:  CALL    236
*
007E2:  INC     W1,W1
007E4:  BTSC.B  223.1
007E6:  BRA     7E4
007E8:  MOV     W0,224
007EA:  MOV     #27,W0
007EC:  CPSGT   W1,W0
007EE:  BRA     7DA
....................     fprintf(BT,"&0,250,0,1,0\n"); //X
007F0:  MOV     #0,W1
007F2:  MOV     W1,W0
007F4:  CLR.B   1
007F6:  CALL    26C
*
007FA:  INC     W1,W1
007FC:  BTSC.B  223.1
007FE:  BRA     7FC
00800:  MOV     W0,224
00802:  MOV     #C,W0
00804:  CPSGT   W1,W0
00806:  BRA     7F2
....................     fprintf(BT,"#0,250,0,1,0\n"); //Y
00808:  MOV     #0,W1
0080A:  MOV     W1,W0
0080C:  CLR.B   1
0080E:  CALL    286
*
00812:  INC     W1,W1
00814:  BTSC.B  223.1
00816:  BRA     814
00818:  MOV     W0,224
0081A:  MOV     #C,W0
0081C:  CPSGT   W1,W0
0081E:  BRA     80A
00820:  RETURN  
.................... 
.................... }
.................... 
.................... void enviar_datos(unsigned int16 ppm)
.................... {
.................... 	COM:
.................... 	while(!input(COMM));
*
01C42:  BSET.B  2C1.1
01C44:  NOP     
01C46:  BTSS.B  2C3.1
01C48:  BRA     1C42
....................  		fprintf(BT, "%03d\n", ppm);
01C4A:  MOV     12EE,W0
01C4C:  MOV     #8003,W4
01C4E:  CALL    1B42
*
01C52:  BTSC.B  223.1
01C54:  BRA     1C52
01C56:  MOV     #A,W4
01C58:  MOV     W4,224
.................... 		if(!input(COMM))
01C5A:  BSET.B  2C1.1
01C5C:  NOP     
01C5E:  BTSC.B  2C3.1
01C60:  BRA     1C66
.................... 		goto COM;
01C62:  GOTO    1C42
*
01C66:  RETURN  
.................... }
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... #include "BEEP.h"
.................... /**
....................  @file    BEEP.h
....................  @author  Julio Gomis-Tena
....................  @brief   Generate n "beeps" of variable frequency
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __BEEP_H
.................... #define __BEEP_H
.................... #include "Header.h"
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #pin_select OC2 = BUZZER
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void); //Inicializa las frecuencias de los beeps y la separaciÃ³n entre ellos
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP(unsigned int8); //Realiza n beeps
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void)		//4kHz -> T/2= 125us
.................... {
.................... 	setup_timer3(TMR_INTERNAL|TMR_DIV_BY_1, 737); // 5kHz. Frecuencia de los beeps
.................... 	set_compare_time(2, 0);
.................... 	setup_compare(2, COMPARE_OFF);
.................... 
.................... 		// (11059200/2)/256/432 = 50 Hz  <-> 100ms
.................... 	setup_timer4(TMR_INTERNAL|TMR_DIV_BY_8, 1843);
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 N_beep;
.................... 
.................... void BEEP(unsigned int8 n)
.................... {
.................... 	if(n<127)
.................... 		N_beep = 2*n;
.................... 	else
.................... 		N_beep = 255;
.................... 
.................... 	enable_interrupts(INT_TIMER4);
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #INT_TIMER4
.................... void isr_TIMER4()			// Cada 100 ms. Espaciado entre beeps. Habra que asociarlo a una interrupcion por software
.................... {
.................... 		if((N_beep%2)==1)
.................... 		{
.................... 			setup_compare(2, COMPARE_TOGGLE | COMPARE_TIMER3);
.................... 		}
.................... 		else
.................... 		{
.................... 			setup_compare(2, COMPARE_OFF);
.................... 			OFF(BUZZER);
.................... 		}
.................... 
.................... 		if( N_beep>0 )
.................... 		{
.................... 		   	N_beep-=1;
.................... 		}
.................... 		else
.................... 		{
.................... 			disable_interrupts(INT_TIMER4);
.................... 		}
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif // __BEEP_H
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... unsigned int8 dt[512];
.................... unsigned int16 ppm;
.................... int1 datos_flag;
.................... extern int cont;
.................... 
.................... #INT_TIMER2
.................... 
.................... void timer2_isr()
*
00708:  PUSH    42
0070A:  PUSH    36
0070C:  PUSH    32
0070E:  MOV     W0,[W15++]
00710:  MOV     #2,W0
00712:  REPEAT  #C
00714:  MOV     [W0++],[W15++]
.................... {
.................... 	ppm=algoritmo();
00716:  CALL    618
*
0071A:  MOV     W0,12DE
.................... }
.................... 
0071C:  BCLR.B  84.7
0071E:  MOV     #1A,W0
00720:  REPEAT  #C
00722:  MOV     [--W15],[W0--]
00724:  MOV     [--W15],W0
00726:  POP     32
00728:  POP     36
0072A:  POP     42
0072C:  RETFIE  
.................... #INT_TIMER5
.................... void timer5_isr()
0072E:  PUSH    42
00730:  PUSH    36
00732:  PUSH    32
00734:  MOV     W0,[W15++]
00736:  MOV     #2,W0
00738:  REPEAT  #C
0073A:  MOV     [W0++],[W15++]
.................... {
.................... 
.................... 	datos_flag=1;
0073C:  BSET.B  85B.1
0073E:  BCLR.B  87.4
00740:  MOV     #1A,W0
00742:  REPEAT  #C
00744:  MOV     [--W15],[W0--]
00746:  MOV     [--W15],W0
00748:  POP     32
0074A:  POP     36
0074C:  POP     42
0074E:  RETFIE  
.................... }
.................... 
.................... void main(void)
*
01F0E:  MOV     #3F50,W15
01F10:  MOV     #3FFF,W0
01F12:  MOV     W0,20
01F14:  NOP     
01F16:  MOV     #4444,W0
01F18:  MOV     W0,A6
01F1A:  MOV     #4444,W0
01F1C:  MOV     W0,B0
01F1E:  BSET.B  81.7
01F20:  DISI    #6
01F22:  MOV     #742,W1
01F24:  MOV     #46,W2
01F26:  MOV     #57,W3
01F28:  MOV.B   W2L,[W1]
01F2A:  MOV.B   W3L,[W1]
01F2C:  BCLR.B  742.6
01F2E:  MOV     #3F14,W0
01F30:  MOV     W0,6A4
01F32:  MOV     #607,W0
01F34:  MOV     W0,6A8
01F36:  MOV     #700,W0
01F38:  MOV     W0,6C4
01F3A:  MOV     #8,W0
01F3C:  MOV     W0,6C6
01F3E:  MOV     #300,W0
01F40:  MOV     W0,6D2
01F42:  MOV     #13,W0
01F44:  MOV     W0,6D6
01F46:  DISI    #6
01F48:  MOV     #742,W1
01F4A:  MOV     #46,W2
01F4C:  MOV     #57,W3
01F4E:  MOV.B   W2L,[W1]
01F50:  MOV.B   W3L,[W1]
01F52:  BSET.B  742.6
01F54:  BCLR.B  2CD.1
01F56:  BSET.B  207.7
01F58:  BSET.B  207.5
01F5A:  BSET.B  206.6
01F5C:  BCLR.B  207.3
01F5E:  BCLR.B  206.7
01F60:  BCLR.B  207.0
01F62:  BSET.B  207.1
01F64:  BCLR.B  207.2
01F66:  CLR     20A
01F68:  MOV     #36,W4
01F6A:  MOV     W4,204
01F6C:  MOV     #7E4,W4
01F6E:  MOV     W4,12AE
01F70:  MOV.B   #14,W0L
01F72:  MOV.B   W0L,12B0
01F74:  MOV.B   #A,W0L
01F76:  MOV.B   W0L,12B1
01F78:  MOV.B   #F,W0L
01F7A:  MOV.B   W0L,12B2
01F7C:  MOV.B   #C,W0L
01F7E:  MOV.B   W0L,12B3
01F80:  MOV.B   #22,W0L
01F82:  MOV.B   W0L,12B4
01F84:  MOV.B   #38,W0L
01F86:  MOV.B   W0L,12B5
01F88:  CLR     A78
01F8A:  CLR     A7A
01F8C:  CLR     12B6
01F8E:  CLR     12DC
01F90:  MOV     #8000,W4
01F92:  MOV     W4,220
01F94:  MOV     #400,W4
01F96:  MOV     W4,222
01F98:  BCLR.B  220.3
01F9A:  MOV     #2,W4
01F9C:  MOV     W4,228
01F9E:  SETM    32C
01FA0:  CLR     12EC
.................... {
....................   //DeclaraciÃ³n e inicializaciÃ³n de variables
.................... 
....................   char ppm_string[9];
.................... 
.................... 	// Flags del programa
....................   int1 peligro_flag, altas, bajas;
.................... 
....................   unsigned int16 ppm_anterior=0;
.................... 
.................... 
.................... 	peligro_flag=0;
01FA2:  BCLR.B  12E0.0
.................... 	altas=0;
01FA4:  BCLR.B  12E0.1
.................... 	bajas=0;
01FA6:  BCLR.B  12E0.2
.................... 
....................   //para debugging. Eliminar al final
.................... 
.................... 
....................   // -----------------------------------------
.................... 
....................   // 1. InicializaciÃ³n de mÃ³dulos (BT, LCD)
....................   // 2. Menu de bienvenida y espera a BTOK
.................... 	// 3. Inicializar ADC y rutina del algoritmo
....................   // 4. Bucle de programa. Finalizar al pulsar BTOK
.................... 	//			4.1 Un ISR temporizado calcula las ppm
....................   //      4.2 Generar alarmas si es necesario
....................   //      4.3 Mostrar por pantalla
....................   //      4.4 EnvÃ­o de datos
.................... 
.................... 
....................   //1.
.................... 
.................... 
....................   init_BT();
01FA8:  CALL    760
.................... 	sd_init_global();
*
01FAC:  CALL    1572
.................... 	lcdi2cinit();
*
01FB0:  CALL    15DA
....................   BEEP_Init();
*
01FB4:  CALL    166A
.................... 
.................... 
....................   //2. Menu bienvenida
....................   initmenu();
*
01FB8:  CALL    1700
....................   while(input(BTOK))
*
01FBC:  BSET.B  2C0.7
01FBE:  NOP     
01FC0:  BTSS.B  2C2.7
01FC2:  BRA     1FCE
....................   {
....................     delay_ms(50);
01FC4:  MOV     #32,W0
01FC6:  CALL    750
*
01FCA:  GOTO    1FBC
....................   }
....................   while(!input(BTOK)) // para evitar rebotes y finalizar el programa
*
01FCE:  BSET.B  2C0.7
01FD0:  NOP     
01FD2:  BTSC.B  2C2.7
01FD4:  BRA     1FE0
....................   {
....................     delay_ms(50);
01FD6:  MOV     #32,W0
01FD8:  CALL    750
*
01FDC:  GOTO    1FCE
....................   }
.................... 
.................... 
....................   //3. Inicializar algoritmo, adc y timer2 a 250 Hz
....................   adcinit();
*
01FE0:  CALL    1788
.................... 
.................... 
.................... 
....................   setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8, 2765); // 11059200/2/8/1843 = 4 ms
*
01FE4:  CLR     110
01FE6:  MOV     #ACD,W4
01FE8:  MOV     W4,10C
01FEA:  MOV     #8010,W4
01FEC:  MOV     W4,110
.................... 	setup_timer5(TMR_INTERNAL | TMR_DIV_BY_256, 21600); //1s 11059200/2/8/14395 = 50Hz
01FEE:  CLR     120
01FF0:  MOV     #5460,W4
01FF2:  MOV     W4,11C
01FF4:  MOV     #8030,W4
01FF6:  MOV     W4,120
....................   init_algoritmo();
01FF8:  CALL    17A0
.................... 	enable_interrupts(INT_TIMER5);
*
01FFC:  BSET.B  97.4
.................... 	memset(dt,0,512);
01FFE:  MOV     #878,W1
02000:  MOV     #0,W2
02002:  REPEAT  #1FF
02004:  CLR.B   [W1++]
.................... 
....................   //Mostrar pantalla de frecuencia
....................   display_frecuencia();
02006:  CALL    17E0
....................   delay_ms(4); // que al menos se ejecute el algoritmo una vez para no tener valores raros
*
0200A:  REPEAT  #1662
0200C:  NOP     
0200E:  REPEAT  #3FFF
02010:  NOP     
.................... 
....................   //4. Bucle del programa
....................   while(input(BTOK))
02012:  BSET.B  2C0.7
02014:  NOP     
02016:  BTSS.B  2C2.7
02018:  BRA     2120
....................   {
.................... 
.................... 		//Comprobar si hay electrodo suelto
.................... 		if(input(H2) || input(L3)) // COnectar pin del electrodo
0201A:  BSET.B  2C9.4
0201C:  NOP     
0201E:  BTSC.B  2CB.4
02020:  BRA     202A
02022:  BSET.B  2C9.3
02024:  NOP     
02026:  BTSS.B  2CB.3
02028:  BRA     2088
.................... 		{
.................... 			display_electrodo_suelto();
0202A:  CALL    1890
.................... 			disable_interrupts(INT_TIMER2);
*
0202E:  BCLR.B  94.7
02030:  NOP     
.................... 			disable_interrupts(INT_TIMER5);
02032:  BCLR.B  97.4
02034:  NOP     
.................... 			while(input(H2) || input(L3))
02036:  BSET.B  2C9.4
02038:  NOP     
0203A:  BTSC.B  2CB.4
0203C:  BRA     2046
0203E:  BSET.B  2C9.3
02040:  NOP     
02042:  BTSS.B  2CB.3
02044:  BRA     2050
.................... 			{
.................... 				delay_ms(100);
02046:  MOV     #64,W0
02048:  CALL    750
*
0204C:  GOTO    2036
.................... 			}
.................... 			display_electrodo_recuperado();
*
02050:  CALL    18CC
.................... 			while(input(BTOK))
*
02054:  BSET.B  2C0.7
02056:  NOP     
02058:  BTSS.B  2C2.7
0205A:  BRA     2066
.................... 		  {
.................... 		    delay_ms(50);
0205C:  MOV     #32,W0
0205E:  CALL    750
*
02062:  GOTO    2054
.................... 		  }
.................... 		  while(!input(BTOK)) // para evitar rebotes y finalizar el programa
*
02066:  BSET.B  2C0.7
02068:  NOP     
0206A:  BTSC.B  2C2.7
0206C:  BRA     2078
.................... 		  {
.................... 		    delay_ms(50);
0206E:  MOV     #32,W0
02070:  CALL    750
*
02074:  GOTO    2066
.................... 		  }
.................... 			display_frecuencia();
*
02078:  CALL    17E0
.................... 			enable_interrupts(INT_TIMER2); // restaura ciclo de funcionamiento normal
*
0207C:  BSET.B  94.7
.................... 			enable_interrupts(INT_TIMER5);
0207E:  BSET.B  97.4
.................... 			delay_ms(4);
02080:  REPEAT  #1662
02082:  NOP     
02084:  REPEAT  #3FFF
02086:  NOP     
.................... 		}
.................... 
....................     //4.1 Generar alarmas si es necesario
....................     if(ppm>=250)
02088:  MOV     12DE,W4
0208A:  MOV     #FA,W3
0208C:  CP      W3,W4
0208E:  BRA     GTU,20A2
....................     {
.................... 			if(!altas)	display_alarma_alto();
02090:  BTSC.B  12E0.1
02092:  BRA     2098
02094:  CALL    1982
.................... 			altas=1;
*
02098:  BSET.B  12E0.1
.................... 			bajas=0;
0209A:  BCLR.B  12E0.2
.................... 			peligro_flag=1;
0209C:  BSET.B  12E0.0
.................... 			ppm_anterior=ppm;
0209E:  PUSH    12DE
020A0:  POP     12EC
.................... 		}
.................... 		if(ppm<=35)
020A2:  MOV     12DE,W4
020A4:  MOV     #23,W3
020A6:  CP      W3,W4
020A8:  BRA     NC,20C0
....................     {
.................... 			if(!bajas)	display_alarma_bajo();
020AA:  BTSC.B  12E0.2
020AC:  BRA     20B2
020AE:  CALL    19C6
.................... 			altas=0;
*
020B2:  BCLR.B  12E0.1
.................... 			bajas=1;
020B4:  BSET.B  12E0.2
.................... 			peligro_flag=1;
020B6:  BSET.B  12E0.0
.................... 			ppm_anterior=ppm;
020B8:  PUSH    12DE
020BA:  POP     12EC
.................... 			output_toggle(BUZZER);
020BC:  BCLR.B  2D0.6
020BE:  BTG.B   2D4.6
.................... 		}
.................... 
.................... 		//4.2 Mostrar por pantalla en funcionamiento normal
.................... 		if(!peligro_flag)
020C0:  BTSC.B  12E0.0
020C2:  BRA     2104
.................... 		{
.................... 			OFF(BUZZER);
020C4:  BCLR.B  2D0.6
020C6:  BCLR.B  2D4.6
.................... 			if(ppm!=ppm_anterior) // mostrar por pantalla si ha cambiado el valor
020C8:  MOV     12DE,W0
020CA:  CP      12EC
020CC:  BRA     Z,2104
.................... 			{
.................... 				display_frecuencia();
020CE:  CALL    17E0
.................... 				sprintf(ppm_string,"%d  ",ppm); // crear cadena con espacios para borrar el valor anterior
*
020D2:  MOV     #12E2,W4
020D4:  MOV     W4,12DC
020D6:  MOV     12DE,W0
020D8:  MOV     #0,W4
020DA:  CALL    1A12
*
020DE:  MOV.B   #20,W0L
020E0:  CALL    1A04
*
020E4:  MOV.B   #20,W0L
020E6:  CALL    1A04
.................... 				LCD_cursor_at(0,16);
*
020EA:  CLR.B   132A
020EC:  MOV.B   #10,W0L
020EE:  MOV.B   W0L,132B
020F0:  CALL    1684
.................... 				LCD_write(ppm_string);
*
020F4:  MOV     #12E2,W4
020F6:  MOV     W4,132A
020F8:  CALL    16A4
.................... 				ppm_anterior=ppm; 							// actualizar pulsaciones anteriores
*
020FC:  PUSH    12DE
020FE:  POP     12EC
.................... 				bajas=0;
02100:  BCLR.B  12E0.2
.................... 				altas=0;
02102:  BCLR.B  12E0.1
.................... 			}
.................... 		}
.................... 
.................... 
....................     //4.3 Enviar datos y escribir cada x segundos
....................     if(datos_flag)
02104:  BTSS.B  85B.1
02106:  BRA     211A
....................     {
....................       enviar_datos(ppm);
02108:  PUSH    12DE
0210A:  POP     12EE
0210C:  CALL    1C42
.................... 			escritura_sd(ppm);
*
02110:  PUSH    12DE
02112:  POP     12EE
02114:  CALL    1E8A
.................... 			datos_flag=0;
*
02118:  BCLR.B  85B.1
.................... 		}
.................... 		peligro_flag=0; // actualizar flag
0211A:  BCLR.B  12E0.0
0211C:  GOTO    2012
....................     //fin del bucle
....................   }
.................... 
.................... 	//fin de programa
.................... 	display_final();
*
02120:  CALL    1ED2
.................... 	disable_interrupts(INT_TIMER2);
*
02124:  BCLR.B  94.7
02126:  NOP     
.................... 	disable_interrupts(INT_TIMER5);
02128:  BCLR.B  97.4
0212A:  NOP     
.................... }
0212C:  BRA     212C

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: 0000  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: 0000  
   Word  3L: 0007   NOWRT NOPROTECT
          H: 0000  
   Word  4L: 0002   PR NOIESO
          H: 0000  
   Word  5L: 0062   HS OSCIO IOL1WAY CKSNOFSM
          H: 0000  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: 0000  
   Word  7L: 00F7   PUT128 NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: 0000  
   Word  8L: 0043   ICSP1 NOJTAG DEBUG
          H: 0000  

   Some fuses have been forced to be compatible with the ICD debugger.
