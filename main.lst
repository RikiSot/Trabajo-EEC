CCS PCD C Compiler, Version 5.091, 43599               26-ene.-21 22:23

               Filename:   F:\Industriales\Especialidad\SDM\Trabajo-EEC\main.lst

               ROM used:   8110 bytes (9%)
                           Largest free fragment is 57426
               RAM used:   2883 (18%) at main() level
                           2996 (18%) worst case
               Stack used: 90 locations (34 in main + 56 for interrupts)
               Stack size: 176

00000:  GOTO    1DFC
*
00022:  DATA    08,07,00
*
0004A:  DATA    A0,02,00
0004C:  DATA    2E,07,00
.................... /**
....................  @file    main.c
....................  @author  Ricardo Gomez, Klaudija Ziliute
.................... 
....................  @brief   main EEC
.................... */
.................... 
.................... /* SECTION 1: Included header files to compile this file           */
.................... #include "33FJ128MC804.h"
.................... 
.................... #ifndef LIB_h
.................... #define LIB_h
.................... 
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device DSPIC33FJ128MC804
*
00200:  CLR     32
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    53,46,00
0020E:  DATA    2C,31,00
00210:  DATA    0D,00,00
00212:  CLR     32
00214:  MOV     #21E,W3
00216:  ADD     W3,W0,W0
00218:  TBLRDL.B[W0],W0L
0021A:  CLR.B   1
0021C:  RETURN  
0021E:  DATA    53,41,00
00220:  DATA    2C,30,00
00222:  DATA    0D,00,00
00224:  CLR     32
00226:  MOV     #230,W3
00228:  ADD     W3,W0,W0
0022A:  TBLRDL.B[W0],W0L
0022C:  CLR.B   1
0022E:  RETURN  
00230:  DATA    52,2C,00
00232:  DATA    31,0D,00
00234:  DATA    00,00,00
00236:  CLR     32
00238:  MOV     #242,W3
0023A:  ADD     W3,W0,W0
0023C:  TBLRDL.B[W0],W0L
0023E:  CLR.B   1
00240:  RETURN  
00242:  DATA    24,52,00
00244:  DATA    65,70,00
00246:  DATA    72,65,00
00248:  DATA    73,65,00
0024A:  DATA    6E,74,00
0024C:  DATA    61,63,00
0024E:  DATA    69,6F,00
00250:  DATA    6E,20,00
00252:  DATA    67,72,00
00254:  DATA    61,66,00
00256:  DATA    69,63,00
00258:  DATA    61,2C,00
0025A:  DATA    46,75,00
0025C:  DATA    6E,63,00
0025E:  DATA    69,6F,00
00260:  DATA    6E,2C,00
00262:  DATA    64,61,00
00264:  DATA    74,6F,00
00266:  DATA    73,20,00
00268:  DATA    31,0A,00
0026A:  DATA    00,00,00
0026C:  CLR     32
0026E:  MOV     #278,W3
00270:  ADD     W3,W0,W0
00272:  TBLRDL.B[W0],W0L
00274:  CLR.B   1
00276:  RETURN  
00278:  DATA    26,30,00
0027A:  DATA    2C,32,00
0027C:  DATA    35,30,00
0027E:  DATA    2C,30,00
00280:  DATA    2C,31,00
00282:  DATA    2C,30,00
00284:  DATA    0A,00,00
00286:  CLR     32
00288:  MOV     #292,W3
0028A:  ADD     W3,W0,W0
0028C:  TBLRDL.B[W0],W0L
0028E:  CLR.B   1
00290:  RETURN  
00292:  DATA    23,30,00
00294:  DATA    2C,32,00
00296:  DATA    35,30,00
00298:  DATA    2C,30,00
0029A:  DATA    2C,31,00
0029C:  DATA    2C,30,00
0029E:  DATA    0A,00,00
*
002EA:  MOV     W5,[W15++]
002EC:  MOV     W6,[W15++]
002EE:  MOV     #8E,W1
002F0:  CP0     W0
002F2:  BRA     Z,318
002F4:  BTSC    W0.F
002F6:  BRA     300
002F8:  BCLR.B  42.0
002FA:  RLC     W0,W0
002FC:  DEC     W1,W1
002FE:  BRA     2F4
00300:  SWAP    W1
00302:  BCLR.B  42.0
00304:  RRC     W1,W1
00306:  BCLR    W0.F
00308:  SWAP    W0
0030A:  XOR.B   W0L,W1L,W1L
0030C:  AND.B   #0,W0L
0030E:  BRA     31E
00310:  MOV.B   W1L,W0L
00312:  BSET    W1.7
00314:  AND.B   #0,W1L
00316:  BRA     31E
00318:  CLR     W0
0031A:  CLR     W1
0031C:  BRA     31E
0031E:  MOV     [--W15],W6
00320:  MOV     [--W15],W5
00322:  RETURN  
00324:  MOV     W5,[W15++]
00326:  MOV     W6,[W15++]
00328:  MOV     W7,[W15++]
0032A:  XOR     W1,W3,W4
0032C:  BTSS    W4.F
0032E:  BRA     33C
00330:  BCLR.B  42.0
00332:  BCLR.B  42.1
00334:  BTSS    W1.F
00336:  BRA     384
00338:  BSET.B  42.0
0033A:  BRA     384
0033C:  MOV     W1,W4
0033E:  MOV     W0,W5
00340:  MOV     W3,W6
00342:  MOV     W2,W7
00344:  RLC     W1,W1
00346:  SWAP    W1
00348:  RLC     W3,W3
0034A:  SWAP    W3
0034C:  SUB.B   W3L,W1L,W1L
0034E:  BRA     Z,35A
00350:  BTSS    W4.F
00352:  BRA     384
00354:  MOV     #1,W0
00356:  XOR.B   42
00358:  BRA     384
0035A:  MOV.B   W4L,W1L
0035C:  MOV.B   W6L,W3L
0035E:  BCLR    W1.7
00360:  BCLR    W3.7
00362:  SUB.B   W3L,W1L,W1L
00364:  BRA     Z,370
00366:  BTSS    W4.F
00368:  BRA     384
0036A:  MOV     #1,W0
0036C:  XOR.B   42
0036E:  BRA     384
00370:  SUB     W7,W5,W1
00372:  BRA     Z,37E
00374:  BTSS    W4.F
00376:  BRA     384
00378:  MOV     #1,W0
0037A:  XOR.B   42
0037C:  BRA     384
0037E:  BCLR.B  42.0
00380:  BRA     384
00382:  BRA     384
00384:  MOV     [--W15],W7
00386:  MOV     [--W15],W6
00388:  MOV     [--W15],W5
0038A:  RETURN  
*
003A4:  MOV     W5,[W15++]
003A6:  MOV     #C,W5
003A8:  REPEAT  #4
003AA:  MOV     [W5++],[W15++]
003AC:  CLR     W9
003AE:  XOR     W1,W3,W9
003B0:  MOV     W1,W6
003B2:  MOV     W0,W5
003B4:  MOV     W3,W8
003B6:  MOV     W2,W7
003B8:  RLC     W1,W1
003BA:  SWAP    W1
003BC:  ZE      W1,W1
003BE:  CP0     W1
003C0:  BRA     Z,45E
003C2:  RLC     W3,W3
003C4:  SWAP    W3
003C6:  ZE      W3,W3
003C8:  CP0     W3
003CA:  BRA     Z,45E
003CC:  CLR     W0
003CE:  SUB.B   W1L,W3L,W0L
003D0:  BRA     NC,3D8
003D2:  ADD.B   #7F,W0L
003D4:  BRA     C,45E
003D6:  BRA     3DE
003D8:  SUB.B   #81,W0L
003DA:  BRA     NC,45E
003DC:  BRA     Z,45E
003DE:  MOV     W5,W1
003E0:  MOV     W6,W2
003E2:  BSET    W2.7
003E4:  AND     #FF,W2
003E6:  AND     #FF,W8
003E8:  BSET    W8.7
003EA:  MOV     #19,W10
003EC:  CLR     W3
003EE:  CLR     W4
003F0:  SUB     W1,W7,W1
003F2:  SUBB    W2,W8,W2
003F4:  BRA     N,3FA
003F6:  BRA     C,400
003F8:  BRA     NZ,402
003FA:  ADD     W1,W7,W1
003FC:  ADDC    W2,W8,W2
003FE:  BRA     402
00400:  BSET    W4.0
00402:  DEC     W10,W10
00404:  BRA     Z,414
00406:  BCLR.B  42.0
00408:  RLC     W1,W1
0040A:  RLC     W2,W2
0040C:  BCLR.B  42.0
0040E:  RLC     W4,W4
00410:  RLC     W3,W3
00412:  BRA     3F0
00414:  CLR     W10
00416:  BTSC    W3.8
00418:  BRA     41C
0041A:  BRA     428
0041C:  BCLR.B  42.0
0041E:  RRC     W3,W3
00420:  BCLR    W3.7
00422:  RRC     W4,W4
00424:  RLC     W10,W10
00426:  BRA     42C
00428:  DEC     W0,W0
0042A:  BRA     Z,45E
0042C:  BTSC    W10.F
0042E:  BRA     NC,43A
00430:  RLC     W1,W1
00432:  RLC     W2,W2
00434:  SUB     W1,W7,W1
00436:  SUBB    W2,W8,W2
00438:  BRA     NC,44C
0043A:  INC     W4,W4
0043C:  BRA     NZ,44C
0043E:  INC     W3,W3
00440:  BRA     NZ,44C
00442:  INC     W0,W0
00444:  BRA     Z,45E
00446:  BRA     44C
00448:  DEC     W0,W0
0044A:  BRA     Z,45E
0044C:  SWAP    W0
0044E:  RRC     W0,W1
00450:  BSET    W1.F
00452:  BTSS    W9.F
00454:  BCLR    W1.F
00456:  BCLR    W3.7
00458:  XOR.B   W3L,W1L,W1L
0045A:  MOV     W4,W0
0045C:  BRA     464
0045E:  MOV     #0,W0
00460:  MOV     #0,W1
00462:  BRA     464
00464:  MOV     #14,W5
00466:  REPEAT  #4
00468:  MOV     [--W15],[W5--]
0046A:  MOV     [--W15],W5
0046C:  RETURN  
0046E:  MOV     W5,[W15++]
00470:  MOV     #C,W5
00472:  REPEAT  #3
00474:  MOV     [W5++],[W15++]
00476:  CLR     W9
00478:  MOV     #8000,W8
0047A:  BTSC.B  43.0
0047C:  XOR     W8,W3,W3
0047E:  CP0     W0
00480:  BRA     NZ,488
00482:  MOV     #7FFF,W10
00484:  AND     W1,W10,W10
00486:  BTSS.B  42.1
00488:  MOV     W1,W10
0048A:  XOR     W3,W10,W11
0048C:  MOV     W1,W6
0048E:  MOV     W3,W7
00490:  MOV     W3,W12
00492:  BCLR.B  42.1
00494:  BCLR.B  42.0
00496:  RLC     W6,W6
00498:  SWAP    W6
0049A:  AND     #FF,W6
0049C:  CP0     W6
0049E:  BRA     Z,5E2
004A0:  BCLR.B  42.1
004A2:  BCLR.B  42.0
004A4:  RLC     W7,W7
004A6:  SWAP    W7
004A8:  AND     #FF,W7
004AA:  CP0     W7
004AC:  BRA     Z,5EC
004AE:  BCLR.B  42.1
004B0:  BCLR.B  42.0
004B2:  CP      W7,W6
004B4:  BRA     Z,5EE
004B6:  BRA     N,5FE
004B8:  BCLR    W9.0
004BA:  BSET    W9.1
004BC:  SUB     W7,W6,W8
004BE:  MOV     W7,W6
004C0:  AND     #FF,W1
004C2:  BSET    W1.7
004C4:  AND     #FF,W3
004C6:  BSET    W3.7
004C8:  MOV     #28,W7
004CA:  CP      W7,W8
004CC:  BRA     N,4F0
004CE:  BCLR.B  42.1
004D0:  BCLR.B  42.0
004D2:  RRC     W1,W1
004D4:  RRC     W0,W0
004D6:  DEC     W8,W8
004D8:  BRA     NZ,4CE
004DA:  BRA     4F6
004DC:  MOV     #28,W7
004DE:  CP      W7,W8
004E0:  BRA     N,4F4
004E2:  BCLR.B  42.1
004E4:  BCLR.B  42.0
004E6:  RRC     W3,W3
004E8:  RRC     W2,W2
004EA:  DEC     W8,W8
004EC:  BRA     NZ,4E2
004EE:  BRA     50E
004F0:  MOV     W2,W0
004F2:  MOV     W3,W1
004F4:  BRA     57C
004F6:  BTSS    W11.F
004F8:  BRA     51C
004FA:  BTSC    W9.4
004FC:  MOV     W12,W11
004FE:  NEG     W0,W0
00500:  BRA     Z,506
00502:  COM.B   W1L,W1L
00504:  BRA     508
00506:  NEG     W1,W1
00508:  BTSC    W9.4
0050A:  BRA     562
0050C:  BRA     51C
0050E:  BTSS    W11.F
00510:  BRA     51C
00512:  NEG     W2,W2
00514:  BRA     Z,51A
00516:  COM.B   W3L,W3L
00518:  BRA     51C
0051A:  NEG     W3,W3
0051C:  AND     #FF,W5
0051E:  BCLR.B  42.1
00520:  BCLR.B  42.0
00522:  ADD     W0,W2,W0
00524:  ADDC.B  W1L,W3L,W1L
00526:  BTSC.B  42.0
00528:  BSET    W9.3
0052A:  BTSC    W9.0
0052C:  BRA     540
0052E:  BTSC    W9.1
00530:  BRA     534
00532:  BRA     54A
00534:  BTSC    W11.F
00536:  BRA     562
00538:  BTSC    W9.3
0053A:  BRA     58E
0053C:  BSET    W9.6
0053E:  BRA     57C
00540:  BTSC    W11.F
00542:  BRA     562
00544:  BTSC    W9.3
00546:  BRA     58E
00548:  BRA     57C
0054A:  BCLR    W9.2
0054C:  BTSC    W11.F
0054E:  BRA     558
00550:  MOV     W10,W11
00552:  BTSC    W9.3
00554:  BRA     58E
00556:  BRA     5C4
00558:  BSET    W9.4
0055A:  XOR.B   #80,W1L
0055C:  BTSC    W1.7
0055E:  BRA     4FA
00560:  MOV     W10,W11
00562:  AND     #FF,W1
00564:  IOR      W0,  W1,W7
00566:  BRA     Z,57C
00568:  BTSC    W1.7
0056A:  BRA     57C
0056C:  BCLR.B  42.1
0056E:  BCLR.B  42.0
00570:  RLC     W0,W0
00572:  RLC     W1,W1
00574:  DEC     W6,W6
00576:  BTSC.B  42.1
00578:  BRA     5DC
0057A:  BRA     568
0057C:  BTSC    W9.0
0057E:  MOV     W10,W11
00580:  BTSC    W9.1
00582:  MOV     W12,W11
00584:  BTSS    W9.5
00586:  BRA     5BC
00588:  BTSC    W10.F
0058A:  BSET    W0.8
0058C:  BRA     5C4
0058E:  BSET.B  42.0
00590:  RRC.B   W1L,W1L
00592:  RRC     W0,W0
00594:  BTSC.B  42.0
00596:  BSET    W9.5
00598:  INC     W6,W6
0059A:  BRA     Z,5DC
0059C:  BTSS    W9.5
0059E:  BRA     5B0
005A0:  INC     W0,W0
005A2:  BRA     NZ,5B0
005A4:  INC.B   W1L,W1L
005A6:  BRA     NZ,5B0
005A8:  RRC.B   W1L,W1L
005AA:  RRC     W0,W0
005AC:  INC     W6,W6
005AE:  BRA     Z,5DC
005B0:  BTSC    W9.0
005B2:  MOV     W10,W11
005B4:  BTSC    W9.1
005B6:  MOV     W12,W11
005B8:  BTSC.B  42.1
005BA:  BRA     5DC
005BC:  BTSC    W9.6
005BE:  MOV     W10,W11
005C0:  BTSC    W9.7
005C2:  MOV     W12,W11
005C4:  IOR      W0,  W1,W2
005C6:  BRA     Z,60E
005C8:  BCLR    W1.7
005CA:  SWAP    W6
005CC:  BCLR.B  42.1
005CE:  BCLR.B  42.0
005D0:  RRC     W6,W6
005D2:  XOR     W6,W1,W1
005D4:  BSET    W1.F
005D6:  BTSS    W11.F
005D8:  BCLR    W1.F
005DA:  BRA     60E
005DC:  MOV     #0,W0
005DE:  MOV     #0,W1
005E0:  BRA     60E
005E2:  BTSC    W10.F
005E4:  XOR     W8,W3,W3
005E6:  MOV     W2,W0
005E8:  MOV     W3,W1
005EA:  BRA     60E
005EC:  BRA     60E
005EE:  AND     #FF,W3
005F0:  BSET    W3.7
005F2:  AND     #FF,W1
005F4:  BSET    W1.7
005F6:  BTSC    W11.F
005F8:  BCLR    W3.7
005FA:  BSET    W9.2
005FC:  BRA     50E
005FE:  SUB     W6,W7,W8
00600:  AND     #FF,W1
00602:  BSET    W1.7
00604:  AND     #FF,W3
00606:  BSET    W3.7
00608:  BCLR    W9.1
0060A:  BSET    W9.0
0060C:  BRA     4DC
0060E:  MOV     #12,W5
00610:  REPEAT  #3
00612:  MOV     [--W15],[W5--]
00614:  MOV     [--W15],W5
00616:  RETURN  
*
0106A:  MOV     W5,[W15++]
0106C:  MOV     #C,W5
0106E:  REPEAT  #3
01070:  MOV     [W5++],[W15++]
01072:  MOV     #0,W9
01074:  BTSC.B  43.0
01076:  MOV     #1,W9
01078:  MOV     W9,[W15++]
0107A:  CLR     W4
0107C:  CLR     W5
0107E:  CLR     W6
01080:  CLR     W7
01082:  XOR     W2,W3,W8
01084:  BRA     Z,10A8
01086:  MOV     #20,W8
01088:  BCLR.B  42.0
0108A:  RLC     W0,W0
0108C:  RLC     W1,W1
0108E:  RLC     W4,W4
01090:  RLC     W5,W5
01092:  CP      W5,W3
01094:  BRA     NZ,1098
01096:  CPB     W4,W2
01098:  BRA     NC,10A0
0109A:  SUB     W4,W2,W4
0109C:  SUBB    W5,W3,W5
0109E:  BSET.B  42.0
010A0:  RLC     W6,W6
010A2:  RLC     W7,W7
010A4:  DEC     W8,W8
010A6:  BRA     NZ,1088
010A8:  MOV     W7,W1
010AA:  MOV     W6,W0
010AC:  MOV     [--W15],W9
010AE:  CP0     W9
010B0:  BRA     Z,10B4
010B2:  MOV.D   W4,W0
010B4:  MOV     #12,W5
010B6:  REPEAT  #3
010B8:  MOV     [--W15],[W5--]
010BA:  MOV     [--W15],W5
010BC:  RETURN  
*
01268:  MOV     W5,[W15++]
0126A:  MOV     #C,W5
0126C:  REPEAT  #3
0126E:  MOV     [W5++],[W15++]
01270:  MUL.UU  W0,W2,W4
01272:  MUL.UU  W0,W3,W6
01274:  BCLR.B  42.0
01276:  ADD     W6,W5,W5
01278:  ADDC    W7,#0,W8
0127A:  MUL.UU  W1,W2,W6
0127C:  ADDC    W6,W5,W5
0127E:  ADDC    W7,W8,W8
01280:  MUL.UU  W1,W3,W6
01282:  ADD     W6,W8,W8
01284:  ADDC    #0,W7
01286:  MOV     W7,W3
01288:  MOV     W8,W2
0128A:  MOV     W5,W1
0128C:  MOV     W4,W0
0128E:  MOV     #12,W5
01290:  REPEAT  #3
01292:  MOV     [--W15],[W5--]
01294:  MOV     [--W15],W5
01296:  RETURN  
*
018CA:  MOV     W1,[W15++]
018CC:  MOV     12DC,W1
018CE:  MOV.B   W0L,[W1++]
018D0:  CLR.B   [W1]
018D2:  MOV     [--W15],W1
018D4:  INC     12DC
018D6:  RETURN  
018D8:  MOV     W5,[W15++]
018DA:  MOV     #C,W5
018DC:  REPEAT  #3
018DE:  MOV     [W5++],[W15++]
018E0:  BTSS    W0.F
018E2:  BRA     1902
018E4:  NEG     W0,W0
018E6:  BSET    W4.8
018E8:  BTSS    W4.F
018EA:  BRA     1902
018EC:  MOV     W0,[W15++]
018EE:  MOV     #2D,W0
018F0:  MOV     W4,[W15++]
018F2:  MOV     W0,[W15++]
018F4:  MOV     [--W15],W0
018F6:  CALL    18CA
*
018FA:  MOV     [--W15],W4
018FC:  MOV     [--W15],W0
018FE:  BCLR    W4.8
01900:  DEC.B   0008
01902:  CLR     W5
01904:  MOV     W0,W7
01906:  MOV     W4,W9
01908:  BCLR    W4.F
0190A:  CP0.B   W4L
0190C:  BRA     NZ,191A
0190E:  BTSC    W9.F
01910:  BRA     1916
01912:  MOV     #0,W5
01914:  BRA     1944
01916:  MOV     #0,W5
01918:  BRA     1944
0191A:  BTSS    W9.8
0191C:  SUB.B   W4L,#6,W5L
0191E:  BTSC    W9.8
01920:  SUB.B   W4L,#7,W5L
01922:  BRA     NC,1942
01924:  MOV     #30,W0
01926:  BTSS    W9.F
01928:  MOV     #20,W0
0192A:  MOV     W0,[W15++]
0192C:  MOV     W4,[W15++]
0192E:  MOV     W0,[W15++]
01930:  MOV     [--W15],W0
01932:  CALL    18CA
*
01936:  MOV     [--W15],W4
01938:  MOV     [--W15],W0
0193A:  DEC     W5,W5
0193C:  BRA     NN,192A
0193E:  MOV     #5,W5
01940:  BRA     1944
01942:  MOV     W4,W5
01944:  MOV     #6,W4
01946:  BTSC    W5.8
01948:  INC     W4,W4
0194A:  BSET    W5.E
0194C:  BTSC    W9.F
0194E:  BSET    W5.F
01950:  MOV     #2710,W8
01952:  REPEAT  #11
01954:  DIV.U   W7,W8
01956:  CALL    19AA
*
0195A:  MOV     W1,W7
0195C:  MOV     #3E8,W8
0195E:  REPEAT  #11
01960:  DIV.U   W7,W8
01962:  CALL    19AA
*
01966:  MOV     W1,W7
01968:  MOV     #64,W8
0196A:  REPEAT  #11
0196C:  DIV.U   W7,W8
0196E:  CALL    19AA
*
01972:  MOV     W1,W7
01974:  MOV     #A,W8
01976:  REPEAT  #11
01978:  DIV.U   W7,W8
0197A:  CALL    19AA
*
0197E:  BTSS    W9.8
01980:  BRA     1996
01982:  MOV     #2D,W0
01984:  MOV     W1,[W15++]
01986:  MOV     W4,[W15++]
01988:  MOV     W0,[W15++]
0198A:  MOV     [--W15],W0
0198C:  CALL    18CA
*
01990:  MOV     [--W15],W4
01992:  MOV     [--W15],W1
01994:  BCLR    W9.8
01996:  MOV     #30,W0
01998:  ADD.B   W1L,W0L,W0L
0199A:  MOV     W0,2A
0199C:  MOV     W4,[W15++]
0199E:  MOV     W0,[W15++]
019A0:  MOV     [--W15],W0
019A2:  CALL    18CA
*
019A6:  MOV     [--W15],W4
019A8:  BRA     19FE
019AA:  MOV     #30,W6
019AC:  CP0     W0
019AE:  BRA     NZ,19CC
019B0:  BTSS    W5.E
019B2:  BRA     19EA
019B4:  DEC     W4,W4
019B6:  CP.B    W4L,W5L
019B8:  BRA     Z,19BE
019BA:  BTSC.B  42.0
019BC:  RETURN  
019BE:  CP0     W0
019C0:  BRA     NZ,19CC
019C2:  BTSS    W5.E
019C4:  BRA     19EA
019C6:  BTSS    W5.F
019C8:  MOV     #20,W6
019CA:  BRA     19EA
019CC:  BCLR    W5.E
019CE:  BTSS    W9.8
019D0:  BRA     19EA
019D2:  MOV     W0,W10
019D4:  MOV     #2D,W0
019D6:  MOV     W1,[W15++]
019D8:  MOV     W4,[W15++]
019DA:  MOV     W0,[W15++]
019DC:  MOV     [--W15],W0
019DE:  CALL    18CA
*
019E2:  MOV     [--W15],W4
019E4:  MOV     [--W15],W1
019E6:  BCLR    W9.8
019E8:  MOV     W10,W0
019EA:  ADD.B   W6L,W0L,W0L
019EC:  MOV     W1,[W15++]
019EE:  MOV     W4,[W15++]
019F0:  MOV     W0,[W15++]
019F2:  MOV     [--W15],W0
019F4:  CALL    18CA
*
019F8:  MOV     [--W15],W4
019FA:  MOV     [--W15],W1
019FC:  RETURN  
019FE:  MOV     #12,W5
01A00:  REPEAT  #3
01A02:  MOV     [--W15],[W5--]
01A04:  MOV     [--W15],W5
01A06:  RETURN  
01A08:  MOV     W5,[W15++]
01A0A:  MOV     #C,W5
01A0C:  REPEAT  #3
01A0E:  MOV     [W5++],[W15++]
01A10:  BTSS    W0.F
01A12:  BRA     1A2C
01A14:  NEG     W0,W0
01A16:  BSET    W4.8
01A18:  BTSS    W4.F
01A1A:  BRA     1A2C
01A1C:  MOV     W0,[W15++]
01A1E:  MOV     #2D,W0
01A20:  BTSC.B  223.1
01A22:  BRA     1A20
01A24:  MOV     W0,224
01A26:  MOV     [--W15],W0
01A28:  BCLR    W4.8
01A2A:  DEC.B   0008
01A2C:  CLR     W5
01A2E:  MOV     W0,W7
01A30:  MOV     W4,W9
01A32:  BCLR    W4.F
01A34:  CP0.B   W4L
01A36:  BRA     NZ,1A44
01A38:  BTSC    W9.F
01A3A:  BRA     1A40
01A3C:  MOV     #0,W5
01A3E:  BRA     1A68
01A40:  MOV     #0,W5
01A42:  BRA     1A68
01A44:  BTSS    W9.8
01A46:  SUB.B   W4L,#6,W5L
01A48:  BTSC    W9.8
01A4A:  SUB.B   W4L,#7,W5L
01A4C:  BRA     NC,1A66
01A4E:  MOV     #30,W0
01A50:  BTSS    W9.F
01A52:  MOV     #20,W0
01A54:  MOV     W0,[W15++]
01A56:  BTSC.B  223.1
01A58:  BRA     1A56
01A5A:  MOV     W0,224
01A5C:  MOV     [--W15],W0
01A5E:  DEC     W5,W5
01A60:  BRA     NN,1A54
01A62:  MOV     #5,W5
01A64:  BRA     1A68
01A66:  MOV     W4,W5
01A68:  MOV     #6,W4
01A6A:  BTSC    W5.8
01A6C:  INC     W4,W4
01A6E:  BSET    W5.E
01A70:  BTSC    W9.F
01A72:  BSET    W5.F
01A74:  MOV     #2710,W8
01A76:  REPEAT  #11
01A78:  DIV.U   W7,W8
01A7A:  CALL    1ABE
*
01A7E:  MOV     W1,W7
01A80:  MOV     #3E8,W8
01A82:  REPEAT  #11
01A84:  DIV.U   W7,W8
01A86:  CALL    1ABE
*
01A8A:  MOV     W1,W7
01A8C:  MOV     #64,W8
01A8E:  REPEAT  #11
01A90:  DIV.U   W7,W8
01A92:  CALL    1ABE
*
01A96:  MOV     W1,W7
01A98:  MOV     #A,W8
01A9A:  REPEAT  #11
01A9C:  DIV.U   W7,W8
01A9E:  CALL    1ABE
*
01AA2:  BTSS    W9.8
01AA4:  BRA     1AB0
01AA6:  MOV     #2D,W0
01AA8:  BTSC.B  223.1
01AAA:  BRA     1AA8
01AAC:  MOV     W0,224
01AAE:  BCLR    W9.8
01AB0:  MOV     #30,W0
01AB2:  ADD.B   W1L,W0L,W0L
01AB4:  MOV     W0,2A
01AB6:  BTSC.B  223.1
01AB8:  BRA     1AB6
01ABA:  MOV     W0,224
01ABC:  BRA     1AFE
01ABE:  MOV     #30,W6
01AC0:  CP0     W0
01AC2:  BRA     NZ,1AE0
01AC4:  BTSS    W5.E
01AC6:  BRA     1AF4
01AC8:  DEC     W4,W4
01ACA:  CP.B    W4L,W5L
01ACC:  BRA     Z,1AD2
01ACE:  BTSC.B  42.0
01AD0:  RETURN  
01AD2:  CP0     W0
01AD4:  BRA     NZ,1AE0
01AD6:  BTSS    W5.E
01AD8:  BRA     1AF4
01ADA:  BTSS    W5.F
01ADC:  MOV     #20,W6
01ADE:  BRA     1AF4
01AE0:  BCLR    W5.E
01AE2:  BTSS    W9.8
01AE4:  BRA     1AF4
01AE6:  MOV     W0,W10
01AE8:  MOV     #2D,W0
01AEA:  BTSC.B  223.1
01AEC:  BRA     1AEA
01AEE:  MOV     W0,224
01AF0:  BCLR    W9.8
01AF2:  MOV     W10,W0
01AF4:  ADD.B   W6L,W0L,W0L
01AF6:  BTSC.B  223.1
01AF8:  BRA     1AF6
01AFA:  MOV     W0,224
01AFC:  RETURN  
01AFE:  MOV     #12,W5
01B00:  REPEAT  #3
01B02:  MOV     [--W15],[W5--]
01B04:  MOV     [--W15],W5
01B06:  RETURN  
.................... 
.................... #list
.................... 
.................... #endif
.................... 
.................... #include <common.h>
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "Header.h"
.................... #ifndef Header_h
.................... #define Header_h
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses HS
.................... #fuses PR
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock= 11059200)
*
00750:  CP0     W0
00752:  BTSC.B  42.1
00754:  BRA     75E
00756:  REPEAT  #1595
00758:  NOP     
0075A:  DEC     W0,W0
0075C:  BRA     NZ,756
0075E:  RETURN  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON( pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define III            PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		   PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDO1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDI1 =     PIN_B7  //                    (43)
.................... #define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "Header.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "algoritmo.h"
.................... #include "miFAT.h"
.................... #include "sdcard.h"
.................... #include "BLUETOOTH.h"
.................... #include "BEEP.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void) //por comprobar en la placa
.................... {
....................     output_high(BTCM);
*
009D4:  BCLR.B  2C1.0
009D6:  BSET.B  2C5.0
....................     setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_31);
009D8:  MOV     #9F00,W4
009DA:  MOV     W4,324
009DC:  MOV     #86E0,W4
009DE:  MOV     W4,320
....................     setup_adc_ports(sAN4, VSS_VDD);
009E0:  MOV     #FFEF,W4
009E2:  MOV     W4,32C
009E4:  CLR     322
....................     set_adc_channel(4);
009E6:  MOV     #4,W4
009E8:  MOV     W4,328
009EA:  RETURN  
.................... //   setup_timer3(TMR_INTERNAL, 18425); //  200 Hz. Ty/2/18425
.................... //   ADC1CON2 = 0b0000000000000000; // voltage reference en ADC1CON2
.................... //   ADC1CON3 = 0b1000000000000000; // select the analog conversion clock <7:0> y <15> para enable Tad
.................... //   AD1PCFGL = 0b1111111111111110; // AN1 entrada analogica - RB1 - PGC en placa
.................... //   AD1CHS0  = 0b0000000100000001; // AN1 entrada seleccionada para el CH0
.................... //   AD1PCFGL = 0b0000000011110111; // AN4 entrada analogica - RB1 - PGC en placa
.................... //   AD1CHS0  = 0b0000010000000100; // AN4 entrada seleccionada para el CH0
.................... //
.................... //   ADC1CON1 = 0b1011010101000110; // 12 bits - Signed Integer - <7:5> 010 Timer3 for ADC1 - <15> Sampling inmediatly after EOC <9:0> unsigned int
.................... 
.................... }
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "lcd.h"
.................... /**
....................  @file    lcd.h
....................  @author  Ricardo G�mez
....................  @brief   LCD management
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __LCD_H
.................... #define __LCD_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "Header.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "algoritmo.h"
.................... #include "miFAT.h"
.................... #include "sdcard.h"
.................... #include "BLUETOOTH.h"
.................... #include "BEEP.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... /* SECTION 1: Included header files to compile this file           */
.................... 
.................... /* SECTION 2: Public macros                                        */
.................... 
.................... #define _CLEAR_DISPLAY 				0x01
.................... #define _8BIT_4LINES_NORMAL_RE1_IS0		0x3A
.................... #define _8BIT_4LINES_REVERSE_RE1_IS0		0x3B
.................... #define _8BIT_4LINES_RE0_IS1			0x39
.................... #define _8BIT_4LINES_RE0_IS0			0x38
.................... 
.................... #define _BS1_1					0x1E
.................... #define _POWER_DOWN_DISABLE			0x02
.................... #define _SEGMENT_NORMAL_WAY			0x05
.................... #define _NW					0x09
.................... 
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_ON		0x0F
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_OFF		0x0E
.................... #define _DISPLAY_ON_CURSOR_OFF_BLINK_OFF	0x0C
.................... #define _BS0_1					0x1C
.................... #define _INTERNAL_DIVIDER			0x13
.................... #define _CONTRAST				0x77
.................... #define _POWER_ICON_CONTRAST			0x5C
.................... #define _FOLLOWER_CONTROL			0x6E
.................... 
.................... #define ADDRESS_DDRAM				0x80
.................... 
.................... 
.................... /* SECTION 3: Public types                                         */
.................... 
.................... 
.................... /* SECTION 4: Public variables :: declarations, extern mandatory   */
.................... 
.................... 
.................... /* SECTION 5: Public functions :: declarations, extern optional
....................    Rule exception (callbacks)  :: declarations, extern recommended */
.................... void display_valueADC_title(void);
.................... void LCD_command(unsigned int8);
.................... void lcdi2cinit(void);
.................... void LCD_write(char*);
.................... void initmenu(void);                                      //Inicializa el menu principal
.................... void display_frecuencia(void);       // Muestra frecuencia
.................... void LCD_cursor_at(unsigned int8 line, unsigned int8 column);
.................... void display_alarma_alto(void); // Limpia pantalla y escribe mensaje de alarma
.................... void display_alarma_bajo(void);
.................... void display_final(void);
.................... void display_electrodo_suelto(void);
.................... void display_electrodo_recuperado(void);
.................... 
.................... 
.................... void lcdi2cinit(void)
.................... {
.................... 
....................   OFF(SD);
*
00826:  BCLR.B  2D0.1
00828:  BCLR.B  2D4.1
....................   delay_ms(200);
0082A:  MOV     #C8,W0
0082C:  CALL    750
....................   ON(PIN_C1);
*
00830:  BCLR.B  2D0.1
00832:  BSET.B  2D4.1
.................... 
....................   //leds output en open drain
....................   output_float(PIN_B8);
00834:  BSET.B  2C9.0
....................   output_float(PIN_B9);
00836:  BSET.B  2C9.1
.................... 
....................   //pullups
....................   set_pullup(TRUE, PIN_B8);
00838:  BSET.B  6A.6
....................   set_pullup(TRUE, PIN_B9);
0083A:  BSET.B  6A.5
.................... 
.................... 
....................   //dspic as master, velocidad, nombre de la conexion
....................   #use i2c(Master, Fast=10000, i2c1)
*
007DA:  MOV     #FFFF,W0
007DC:  BTSS.B  208.3
007DE:  BRA     7EA
007E0:  BTSC.B  209.6
007E2:  BRA     7E0
007E4:  MOV     W1,202
007E6:  BTSC.B  209.6
007E8:  BRA     7E6
007EA:  MOV     #0,W0
007EC:  BTSC.B  209.7
007EE:  INC     W0,W0
007F0:  RETURN  
.................... 
....................   LCD_command(_CLEAR_DISPLAY);
*
0083C:  MOV.B   #1,W0L
0083E:  MOV.B   W0L,132E
00840:  CALL    7F2
....................   LCD_command(_8BIT_4LINES_NORMAL_RE1_IS0);
*
00844:  MOV.B   #3A,W0L
00846:  MOV.B   W0L,132E
00848:  CALL    7F2
....................   LCD_command(_BS1_1);
*
0084C:  MOV.B   #1E,W0L
0084E:  MOV.B   W0L,132E
00850:  CALL    7F2
....................   LCD_command(_POWER_DOWN_DISABLE);
*
00854:  MOV.B   #2,W0L
00856:  MOV.B   W0L,132E
00858:  CALL    7F2
....................   LCD_command(_SEGMENT_NORMAL_WAY);
*
0085C:  MOV.B   #5,W0L
0085E:  MOV.B   W0L,132E
00860:  CALL    7F2
....................   LCD_command(_NW);
*
00864:  MOV.B   #9,W0L
00866:  MOV.B   W0L,132E
00868:  CALL    7F2
....................   LCD_command(_8BIT_4LINES_RE0_IS1);
*
0086C:  MOV.B   #39,W0L
0086E:  MOV.B   W0L,132E
00870:  CALL    7F2
....................   LCD_command(_DISPLAY_ON_CURSOR_ON_BLINK_OFF);
*
00874:  MOV.B   #E,W0L
00876:  MOV.B   W0L,132E
00878:  CALL    7F2
....................   LCD_command(_BS0_1);
*
0087C:  MOV.B   #1C,W0L
0087E:  MOV.B   W0L,132E
00880:  CALL    7F2
....................   LCD_command(_INTERNAL_DIVIDER);
*
00884:  MOV.B   #13,W0L
00886:  MOV.B   W0L,132E
00888:  CALL    7F2
....................   LCD_command(_CONTRAST);
*
0088C:  MOV.B   #77,W0L
0088E:  MOV.B   W0L,132E
00890:  CALL    7F2
....................   LCD_command(_POWER_ICON_CONTRAST);
*
00894:  MOV.B   #5C,W0L
00896:  MOV.B   W0L,132E
00898:  CALL    7F2
....................   LCD_command(_FOLLOWER_CONTROL);
*
0089C:  MOV.B   #6E,W0L
0089E:  MOV.B   W0L,132E
008A0:  CALL    7F2
....................   LCD_command(_8BIT_4LINES_RE0_IS0);
*
008A4:  MOV.B   #38,W0L
008A6:  MOV.B   W0L,132E
008A8:  CALL    7F2
....................   LCD_command(_DISPLAY_ON_CURSOR_OFF_BLINK_OFF);
*
008AC:  MOV.B   #C,W0L
008AE:  MOV.B   W0L,132E
008B0:  CALL    7F2
*
008B4:  RETURN  
.................... 
.................... }
.................... 
.................... void LCD_command(unsigned int8 cmd)
.................... {
....................   i2c_start();
*
007F2:  BTSS.B  208.3
007F4:  BRA     7FE
007F6:  BSET.B  206.1
007F8:  BTSC.B  206.1
007FA:  BRA     7F8
007FC:  BRA     804
007FE:  BSET.B  206.0
00800:  BTSC.B  206.0
00802:  BRA     800
....................   i2c_write(0x78);
00804:  MOV.B   #78,W1L
00806:  CALL    7DA
....................   i2c_write(0x00);
*
0080A:  CLR.B   W1
0080C:  CALL    7DA
....................   i2c_write(cmd);
*
00810:  MOV.B   132E,W0L
00812:  MOV.B   W0L,2
00814:  CALL    7DA
....................   i2c_stop();
*
00818:  MOV     #1F,W0
0081A:  AND     206,W0
0081C:  BRA     NZ,818
0081E:  BSET.B  206.2
00820:  BTSC.B  206.2
00822:  BRA     820
00824:  RETURN  
.................... }
.................... 
.................... void LCD_write(char* cd)
*
008F0:  MOV     W5,[W15++]
008F2:  MOV     W6,[W15++]
008F4:  CLR.B   132A
.................... {
....................   unsigned int8 c=0;
....................   i2c_start();
008F6:  BTSS.B  208.3
008F8:  BRA     902
008FA:  BSET.B  206.1
008FC:  BTSC.B  206.1
008FE:  BRA     8FC
00900:  BRA     908
00902:  BSET.B  206.0
00904:  BTSC.B  206.0
00906:  BRA     904
....................   i2c_write(0x78);
00908:  MOV.B   #78,W1L
0090A:  CALL    7DA
....................   i2c_write(0x40);
*
0090E:  MOV.B   #40,W1L
00910:  CALL    7DA
....................   while(cd[c]!=0)
*
00914:  MOV     132A,W4
00916:  CLR.B   9
00918:  MOV     W4,W0
0091A:  ADD     1328,W0
0091C:  MOV.B   [W0],W5L
0091E:  SE      W5,W5
00920:  CP0     W5
00922:  BRA     Z,93A
....................   {
....................     i2c_write(cd[c]);
00924:  MOV     132A,W4
00926:  CLR.B   9
00928:  MOV     W4,W0
0092A:  ADD     1328,W0
0092C:  MOV.B   [W0],W5L
0092E:  MOV.B   W5L,W1L
00930:  CALL    7DA
....................     c++;
*
00934:  INC.B   132A
00936:  GOTO    914
....................   }
....................   i2c_stop();
*
0093A:  MOV     #1F,W0
0093C:  AND     206,W0
0093E:  BRA     NZ,93A
00940:  BSET.B  206.2
00942:  BTSC.B  206.2
00944:  BRA     942
00946:  MOV     [--W15],W6
00948:  MOV     [--W15],W5
0094A:  RETURN  
.................... }
.................... 
.................... void LCD_cursor_at(unsigned int8 line, unsigned int8 column)
*
008D0:  MOV     W5,[W15++]
.................... {
....................   LCD_command(0x80 | (line*0x20+column));
008D2:  MOV.B   1328,W0L
008D4:  CLR.B   1
008D6:  SL      W0,#5,W5
008D8:  MOV     1328,W4
008DA:  LSR     W4,#8,W4
008DC:  ADD     W5,W4,W0
008DE:  MOV     W0,W5
008E0:  IOR     #80,W5
008E2:  PUSH    132E
008E4:  MOV.B   W5L,[W15-#2]
008E6:  POP     132E
008E8:  CALL    7F2
*
008EC:  MOV     [--W15],W5
008EE:  RETURN  
.................... }
.................... 
.................... void initmenu(void)
.................... {
.................... 	char cabecera[]="----WELCOME-----";
*
0094C:  MOV     #2D2D,W4
0094E:  MOV     W4,12EE
00950:  MOV     #2D2D,W4
00952:  MOV     W4,12F0
00954:  MOV     #4557,W4
00956:  MOV     W4,12F2
00958:  MOV     #434C,W4
0095A:  MOV     W4,12F4
0095C:  MOV     #4D4F,W4
0095E:  MOV     W4,12F6
00960:  MOV     #2D45,W4
00962:  MOV     W4,12F8
00964:  MOV     #2D2D,W4
00966:  MOV     W4,12FA
00968:  MOV     #2D2D,W4
0096A:  MOV     W4,12FC
0096C:  CLR.B   12FE
.................... 	char boton[]="-------------";
0096E:  MOV     #2D2D,W4
00970:  MOV     W4,1300
00972:  MOV     #2D2D,W4
00974:  MOV     W4,1302
00976:  MOV     #2D2D,W4
00978:  MOV     W4,1304
0097A:  MOV     #2D2D,W4
0097C:  MOV     W4,1306
0097E:  MOV     #2D2D,W4
00980:  MOV     W4,1308
00982:  MOV     #2D2D,W4
00984:  MOV     W4,130A
00986:  MOV     #2D,W4
00988:  MOV     W4,130C
.................... 	char palabra1[]="PRESS OK";
0098A:  MOV     #5250,W4
0098C:  MOV     W4,130E
0098E:  MOV     #5345,W4
00990:  MOV     W4,1310
00992:  MOV     #2053,W4
00994:  MOV     W4,1312
00996:  MOV     #4B4F,W4
00998:  MOV     W4,1314
0099A:  CLR.B   1316
.................... 	//char palabra2[]="OPCION 2";
.................... 	//char palabra3[]="OPCION 3";
.................... 	//char palabra4[]="OPCION 4";
.................... 
.................... 	LCD_cursor_at(0,0);
0099C:  CLR.B   1328
0099E:  CLR.B   1329
009A0:  CALL    8D0
.................... 	LCD_write(cabecera);
*
009A4:  MOV     #12EE,W4
009A6:  MOV     W4,1328
009A8:  CALL    8F0
.................... 	LCD_cursor_at(1,0);
*
009AC:  MOV.B   #1,W0L
009AE:  MOV.B   W0L,1328
009B0:  CLR.B   1329
009B2:  CALL    8D0
.................... 	LCD_write(boton);
*
009B6:  MOV     #1300,W4
009B8:  MOV     W4,1328
009BA:  CALL    8F0
.................... 	LCD_cursor_at(2,1);
*
009BE:  MOV.B   #2,W0L
009C0:  MOV.B   W0L,1328
009C2:  MOV.B   #1,W0L
009C4:  MOV.B   W0L,1329
009C6:  CALL    8D0
.................... 	LCD_write(palabra1);
*
009CA:  MOV     #130E,W4
009CC:  MOV     W4,1328
009CE:  CALL    8F0
*
009D2:  RETURN  
.................... }
.................... 
.................... void errorfichero(void)
.................... {
.................... 	char cabecera[]="------ERROR------";
.................... 	char boton[]="NO CONFIG.TXT DETE";
.................... 	char palabra1[]="PRESS RESET";
.................... 	//char palabra2[]="OPCION 2";
.................... 	//char palabra3[]="OPCION 3";
.................... 	//char palabra4[]="OPCION 4";
.................... 
.................... 	LCD_cursor_at(0,0);
.................... 	LCD_write(cabecera);
.................... 	LCD_cursor_at(1,0);
.................... 	LCD_write(boton);
.................... 	LCD_cursor_at(2,1);
.................... 	LCD_write(palabra1);
.................... }
.................... 
.................... void display_frecuencia(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
*
01798:  MOV.B   #1,W0L
0179A:  MOV.B   W0L,132E
0179C:  CALL    7F2
.................... 	char cabecera[]="FRECUENCIA PPM: ";
*
017A0:  MOV     #5246,W4
017A2:  MOV     W4,12EE
017A4:  MOV     #4345,W4
017A6:  MOV     W4,12F0
017A8:  MOV     #4555,W4
017AA:  MOV     W4,12F2
017AC:  MOV     #434E,W4
017AE:  MOV     W4,12F4
017B0:  MOV     #4149,W4
017B2:  MOV     W4,12F6
017B4:  MOV     #5020,W4
017B6:  MOV     W4,12F8
017B8:  MOV     #4D50,W4
017BA:  MOV     W4,12FA
017BC:  MOV     #203A,W4
017BE:  MOV     W4,12FC
017C0:  CLR.B   12FE
....................   char palabra1[]="-------------------";
017C2:  MOV     #2D2D,W4
017C4:  MOV     W4,1300
017C6:  MOV     #2D2D,W4
017C8:  MOV     W4,1302
017CA:  MOV     #2D2D,W4
017CC:  MOV     W4,1304
017CE:  MOV     #2D2D,W4
017D0:  MOV     W4,1306
017D2:  MOV     #2D2D,W4
017D4:  MOV     W4,1308
017D6:  MOV     #2D2D,W4
017D8:  MOV     W4,130A
017DA:  MOV     #2D2D,W4
017DC:  MOV     W4,130C
017DE:  MOV     #2D2D,W4
017E0:  MOV     W4,130E
017E2:  MOV     #2D2D,W4
017E4:  MOV     W4,1310
017E6:  MOV     #2D,W4
017E8:  MOV     W4,1312
....................   char palabra2[]="BTOK PARA FINALIZAR";
017EA:  MOV     #5442,W4
017EC:  MOV     W4,1314
017EE:  MOV     #4B4F,W4
017F0:  MOV     W4,1316
017F2:  MOV     #5020,W4
017F4:  MOV     W4,1318
017F6:  MOV     #5241,W4
017F8:  MOV     W4,131A
017FA:  MOV     #2041,W4
017FC:  MOV     W4,131C
017FE:  MOV     #4946,W4
01800:  MOV     W4,131E
01802:  MOV     #414E,W4
01804:  MOV     W4,1320
01806:  MOV     #494C,W4
01808:  MOV     W4,1322
0180A:  MOV     #415A,W4
0180C:  MOV     W4,1324
0180E:  MOV     #52,W4
01810:  MOV     W4,1326
.................... 	LCD_cursor_at(0,0);
01812:  CLR.B   1328
01814:  CLR.B   1329
01816:  CALL    8D0
....................   LCD_write(cabecera);
*
0181A:  MOV     #12EE,W4
0181C:  MOV     W4,1328
0181E:  CALL    8F0
....................   LCD_cursor_at(1,0);
*
01822:  MOV.B   #1,W0L
01824:  MOV.B   W0L,1328
01826:  CLR.B   1329
01828:  CALL    8D0
....................   LCD_write(palabra1);
*
0182C:  MOV     #1300,W4
0182E:  MOV     W4,1328
01830:  CALL    8F0
....................   LCD_cursor_at(2,0);
*
01834:  MOV.B   #2,W0L
01836:  MOV.B   W0L,1328
01838:  CLR.B   1329
0183A:  CALL    8D0
....................   LCD_write(palabra2);
*
0183E:  MOV     #1314,W4
01840:  MOV     W4,1328
01842:  CALL    8F0
*
01846:  RETURN  
.................... }
.................... 
.................... void display_valueADC_title(void)
.................... {
....................   char cabecera[]="VALOR ADC: ";
....................   //char palabra2[]="OPCION 2";
....................   //char palabra3[]="OPCION 3";
....................   //char palabra4[]="OPCION 4";
.................... 
....................   LCD_cursor_at(0,0);
....................   LCD_write(cabecera);
.................... }
.................... 
.................... void display_alarma_bajo(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
*
0188C:  MOV.B   #1,W0L
0188E:  MOV.B   W0L,132E
01890:  CALL    7F2
....................   LCD_cursor_at(0,0);
*
01894:  CLR.B   1328
01896:  CLR.B   1329
01898:  CALL    8D0
....................   char peligro[]="PULSACIONES BAJAS";
*
0189C:  MOV     #5550,W4
0189E:  MOV     W4,12EE
018A0:  MOV     #534C,W4
018A2:  MOV     W4,12F0
018A4:  MOV     #4341,W4
018A6:  MOV     W4,12F2
018A8:  MOV     #4F49,W4
018AA:  MOV     W4,12F4
018AC:  MOV     #454E,W4
018AE:  MOV     W4,12F6
018B0:  MOV     #2053,W4
018B2:  MOV     W4,12F8
018B4:  MOV     #4142,W4
018B6:  MOV     W4,12FA
018B8:  MOV     #414A,W4
018BA:  MOV     W4,12FC
018BC:  MOV     #53,W4
018BE:  MOV     W4,12FE
....................   LCD_write(peligro);
018C0:  MOV     #12EE,W4
018C2:  MOV     W4,1328
018C4:  CALL    8F0
*
018C8:  RETURN  
.................... }
.................... 
.................... void display_alarma_alto(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
*
01848:  MOV.B   #1,W0L
0184A:  MOV.B   W0L,132E
0184C:  CALL    7F2
....................   LCD_cursor_at(0,0);
*
01850:  CLR.B   1328
01852:  CLR.B   1329
01854:  CALL    8D0
....................   char peligro[]="PULSACIONES ELEVADAS";
*
01858:  MOV     #5550,W4
0185A:  MOV     W4,12EE
0185C:  MOV     #534C,W4
0185E:  MOV     W4,12F0
01860:  MOV     #4341,W4
01862:  MOV     W4,12F2
01864:  MOV     #4F49,W4
01866:  MOV     W4,12F4
01868:  MOV     #454E,W4
0186A:  MOV     W4,12F6
0186C:  MOV     #2053,W4
0186E:  MOV     W4,12F8
01870:  MOV     #4C45,W4
01872:  MOV     W4,12FA
01874:  MOV     #5645,W4
01876:  MOV     W4,12FC
01878:  MOV     #4441,W4
0187A:  MOV     W4,12FE
0187C:  MOV     #5341,W4
0187E:  MOV     W4,1300
01880:  CLR.B   1302
....................   LCD_write(peligro);
01882:  MOV     #12EE,W4
01884:  MOV     W4,1328
01886:  CALL    8F0
*
0188A:  RETURN  
.................... }
.................... 
.................... void display_final(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
*
01DC0:  MOV.B   #1,W0L
01DC2:  MOV.B   W0L,132E
01DC4:  CALL    7F2
....................   LCD_cursor_at(0,0);
*
01DC8:  CLR.B   1328
01DCA:  CLR.B   1329
01DCC:  CALL    8D0
....................   char fin[]="Fin del programa";
*
01DD0:  MOV     #6946,W4
01DD2:  MOV     W4,12EE
01DD4:  MOV     #206E,W4
01DD6:  MOV     W4,12F0
01DD8:  MOV     #6564,W4
01DDA:  MOV     W4,12F2
01DDC:  MOV     #206C,W4
01DDE:  MOV     W4,12F4
01DE0:  MOV     #7270,W4
01DE2:  MOV     W4,12F6
01DE4:  MOV     #676F,W4
01DE6:  MOV     W4,12F8
01DE8:  MOV     #6172,W4
01DEA:  MOV     W4,12FA
01DEC:  MOV     #616D,W4
01DEE:  MOV     W4,12FC
01DF0:  CLR.B   12FE
....................   LCD_write(fin);
01DF2:  MOV     #12EE,W4
01DF4:  MOV     W4,1328
01DF6:  CALL    8F0
*
01DFA:  RETURN  
.................... }
.................... 
.................... void display_electrodo_suelto(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
....................   LCD_cursor_at(0,0);
....................   char fin[]="ELECTRODO SUELTO";
....................   LCD_write(fin);
.................... }
.................... 
.................... void display_electrodo_recuperado(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
.................... 	char cabecera[]="Contacto restaurado";
....................   char palabra1[]="-------------------";
....................   char palabra2[]="BTOK PARA CONTINUAR";
.................... 	LCD_cursor_at(0,0);
....................   LCD_write(cabecera);
....................   LCD_cursor_at(1,0);
....................   LCD_write(palabra1);
....................   LCD_cursor_at(2,0);
....................   LCD_write(palabra2);
.................... }
.................... 
.................... 
.................... #endif // __LCD_H
.................... // Do not write below this line!
.................... 
.................... #include "algoritmo.h"
.................... /**
....................  @file    ALGORITMO.h
....................  @author  Ricardo Gomez, Klaudija Ziliute
....................  @brief   PanTompkins header file
.................... */
.................... 
.................... 
.................... #ifndef __ALGORITMO_H
.................... #define __ALGORITMO_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "Header.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "algoritmo.h"
.................... #include "miFAT.h"
.................... #include "sdcard.h"
.................... #include "BLUETOOTH.h"
.................... #include "BEEP.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void) //por comprobar en la placa
.................... {
....................     output_high(BTCM);
....................     setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_31);
....................     setup_adc_ports(sAN4, VSS_VDD);
....................     set_adc_channel(4);
.................... //   setup_timer3(TMR_INTERNAL, 18425); //  200 Hz. Ty/2/18425
.................... //   ADC1CON2 = 0b0000000000000000; // voltage reference en ADC1CON2
.................... //   ADC1CON3 = 0b1000000000000000; // select the analog conversion clock <7:0> y <15> para enable Tad
.................... //   AD1PCFGL = 0b1111111111111110; // AN1 entrada analogica - RB1 - PGC en placa
.................... //   AD1CHS0  = 0b0000000100000001; // AN1 entrada seleccionada para el CH0
.................... //   AD1PCFGL = 0b0000000011110111; // AN4 entrada analogica - RB1 - PGC en placa
.................... //   AD1CHS0  = 0b0000010000000100; // AN4 entrada seleccionada para el CH0
.................... //
.................... //   ADC1CON1 = 0b1011010101000110; // 12 bits - Signed Integer - <7:5> 010 Timer3 for ADC1 - <15> Sampling inmediatly after EOC <9:0> unsigned int
.................... 
.................... }
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "BEEP.h"
.................... /**
....................  @file    BEEP.h
....................  @author  Julio Gomis-Tena
....................  @brief   Generate n "beeps" of variable frequency
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __BEEP_H
.................... #define __BEEP_H
.................... #include "Header.h"
.................... #ifndef Header_h
.................... #define Header_h
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses HS
.................... #fuses PR
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock= 11059200)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON( pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define III            PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		   PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDO1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDI1 =     PIN_B7  //                    (43)
.................... #define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #pin_select OC2 = BUZZER
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void); //Inicializa las frecuencias de los beeps y la separación entre ellos
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP(unsigned int8); //Realiza n beeps
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void)		//4kHz -> T/2= 125us
.................... {
.................... 	setup_timer3(TMR_INTERNAL|TMR_DIV_BY_1, 737); // 5kHz. Frecuencia de los beeps
*
008B6:  CLR     112
008B8:  MOV     #2E1,W4
008BA:  MOV     W4,10E
008BC:  MOV     #8000,W4
008BE:  MOV     W4,112
.................... 	set_compare_time(2, 0);
008C0:  CLR     188
.................... 	setup_compare(2, COMPARE_OFF);
008C2:  CLR     18A
.................... 
.................... 		// (11059200/2)/256/432 = 50 Hz  <-> 100ms
.................... 	setup_timer4(TMR_INTERNAL|TMR_DIV_BY_8, 1843);
008C4:  CLR     11E
008C6:  MOV     #733,W4
008C8:  MOV     W4,11A
008CA:  MOV     #8010,W4
008CC:  MOV     W4,11E
008CE:  RETURN  
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 N_beep;
.................... 
.................... void BEEP(unsigned int8 n)
.................... {
.................... 	if(n<127)
*
0038C:  MOV     135E,W4
0038E:  MOV     #7F,W3
00390:  CP.B    W3L,W4L
00392:  BRA     LEU,39E
.................... 		N_beep = 2*n;
00394:  MOV.B   135E,W0L
00396:  MOV.B   W0L,85A
00398:  SL.B    85A
0039A:  GOTO    3A0
.................... 	else
.................... 		N_beep = 255;
*
0039E:  SETM.B  85A
.................... 
.................... 	enable_interrupts(INT_TIMER4);
003A0:  BSET.B  97.3
003A2:  RETURN  
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #INT_TIMER4
.................... void isr_TIMER4()			// Cada 100 ms. Espaciado entre beeps. Habra que asociarlo a una interrupcion por software
*
002A0:  PUSH    42
002A2:  PUSH    36
002A4:  PUSH    32
002A6:  MOV     W0,[W15++]
002A8:  MOV     #2,W0
002AA:  REPEAT  #C
002AC:  MOV     [W0++],[W15++]
.................... {
.................... 		if((N_beep%2)==1)
002AE:  MOV.B   85A,W0L
002B0:  CLR.B   1
002B2:  AND     W0,#1,W5
002B4:  CP      W5,#1
002B6:  BRA     NZ,2C0
.................... 		{
.................... 			setup_compare(2, COMPARE_TOGGLE | COMPARE_TIMER3);
002B8:  MOV     #B,W4
002BA:  MOV     W4,18A
.................... 		}
002BC:  GOTO    2C6
.................... 		else
.................... 		{
.................... 			setup_compare(2, COMPARE_OFF);
*
002C0:  CLR     18A
.................... 			OFF(BUZZER);
002C2:  BCLR.B  2D0.6
002C4:  BCLR.B  2D4.6
.................... 		}
.................... 
.................... 		if( N_beep>0 )
002C6:  CP0.B   85A
002C8:  BRA     Z,2D4
.................... 		{
.................... 		   	N_beep-=1;
002CA:  MOV     85A,W4
002CC:  SUB.B   W4L,#1,W0L
002CE:  MOV.B   W0L,85A
.................... 		}
002D0:  GOTO    2D8
.................... 		else
.................... 		{
.................... 			disable_interrupts(INT_TIMER4);
*
002D4:  BCLR.B  97.3
002D6:  NOP     
.................... 		}
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
002D8:  BCLR.B  87.3
002DA:  MOV     #1A,W0
002DC:  REPEAT  #C
002DE:  MOV     [--W15],[W0--]
002E0:  MOV     [--W15],W0
002E2:  POP     32
002E4:  POP     36
002E6:  POP     42
002E8:  RETFIE  
.................... #endif // __BEEP_H
.................... 
.................... 
.................... 
.................... int algoritmo(void);
.................... void init_algoritmo(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... unsigned int16 yECG[6];
.................... unsigned int16 der, maximo, maximo_ant;
.................... float umbral;
.................... unsigned int16 k;
.................... int1 flag;
.................... unsigned int16 BCL, BCL2; // contador interno (1 BCL=4ms)
.................... 
.................... 
.................... void init_algoritmo()
*
01758:  MOV     W5,[W15++]
.................... {
.................... 	BCL=0;
0175A:  CLR     874
.................... 	k=0;
0175C:  CLR     872
.................... 	umbral=0;
0175E:  CLR     86E
01760:  CLR     870
.................... 	flag=0;
01762:  BCLR.B  85B.0
.................... 	maximo=0;
01764:  CLR     86A
.................... 	maximo_ant=0;
01766:  CLR     86C
.................... 	for(int e=0; e<6; e++)
01768:  CLR     12EE
0176A:  MOV     12EE,W4
0176C:  CP      W4,#6
0176E:  BRA     GE,1792
.................... 	{
.................... 		yECG[e]=read_adc();
01770:  MOV     12EE,W4
01772:  MUL.UU  W4,#2,W0
01774:  MOV     #85C,W4
01776:  ADD     W0,W4,W5
01778:  BCLR.B  320.0
0177A:  BSET.B  320.1
0177C:  BTSS.B  320.0
0177E:  BRA     177C
01780:  MOV     300,W4
01782:  MOV     W4,[W5+#0]
.................... 		delay_ms(4);
01784:  REPEAT  #1662
01786:  NOP     
01788:  REPEAT  #3FFF
0178A:  NOP     
0178C:  INC     12EE
0178E:  GOTO    176A
.................... 	}
.................... 	enable_interrupts(INT_TIMER2);
*
01792:  BSET.B  94.7
01794:  MOV     [--W15],W5
01796:  RETURN  
.................... }
.................... 
.................... // Bucle principal del programa. Debe ejecutarse cada 4ms (250Hz).
.................... int algoritmo(void)
*
00618:  MOV     W5,[W15++]
.................... {
.................... 	int pulsaciones;
.................... 	yECG[5] = yECG[4];		// Hace 20 ms
0061A:  PUSH    864
0061C:  POP     866
.................... 	yECG[4] = yECG[3];		// Hace 16 ms
0061E:  PUSH    862
00620:  POP     864
.................... 	yECG[3] = yECG[2]; 		// Hace 12 ms
00622:  PUSH    860
00624:  POP     862
.................... 	yECG[2] = yECG[1]; 		// Hace 8 ms
00626:  PUSH    85E
00628:  POP     860
.................... 	yECG[1] = yECG[0]; 		// Hace 4 ms
0062A:  PUSH    85C
0062C:  POP     85E
.................... 	yECG[0] = read_adc(); // Ahora
0062E:  BCLR.B  320.0
00630:  BSET.B  320.1
00632:  BTSS.B  320.0
00634:  BRA     632
00636:  PUSH    300
00638:  POP     85C
.................... 
.................... 	//Valor absoluto de la derivada
.................... 	der = (yECG[5] > yECG[0]) ? (yECG[5] - yECG[0]) : (yECG[0] - yECG[5]);
0063A:  MOV     85C,W0
0063C:  MOV     866,W4
0063E:  CP      W4,W0
00640:  BRA     LEU,64C
00642:  MOV     866,W4
00644:  MOV     85C,W3
00646:  SUB     W4,W3,W0
00648:  GOTO    652
*
0064C:  MOV     85C,W4
0064E:  MOV     866,W3
00650:  SUB     W4,W3,W0
00652:  MOV     W0,868
.................... 
.................... 	if(der > maximo) maximo = der;
00654:  MOV     86A,W0
00656:  MOV     868,W4
00658:  CP      W4,W0
0065A:  BRA     LEU,660
0065C:  PUSH    868
0065E:  POP     86A
.................... 
.................... 	if(flag == 0)
00660:  BTSC.B  85B.0
00662:  BRA     688
.................... 	{
.................... 		if(der > umbral)
00664:  MOV     868,W0
00666:  CALL    2EA
*
0066A:  MOV     W0,W2
0066C:  MOV     W1,W3
0066E:  MOV     86E,W0
00670:  MOV     870,W1
00672:  CALL    324
*
00676:  BRA     NC,688
.................... 		{
.................... 			flag = 1;
00678:  BSET.B  85B.0
.................... 			// basal cycle length
.................... 			BCL2 = BCL;
0067A:  PUSH    874
0067C:  POP     876
.................... 			BCL = 0;
0067E:  CLR     874
.................... 			BEEP(1);
00680:  MOV.B   #1,W0L
00682:  MOV.B   W0L,135E
00684:  CALL    38C
.................... 		}
.................... 	}
.................... 
.................... 	if (flag == 1)
*
00688:  BTSS.B  85B.0
0068A:  BRA     68E
.................... 	{
.................... 		k++;
0068C:  INC     0872
.................... 	}
.................... 
.................... 	//Durante 60 puntos = RR min = 0.24seg = 250 bpm
.................... 	//no se puede detectar otro punto RR
.................... 	//solo pasado ese tiempo se hace el calculo
.................... 
.................... 	if(k >60) // hay que calcular el tiempo que son 0.24s para nuestra freq (60 no)
0068E:  MOV     872,W4
00690:  MOV     #3C,W3
00692:  CP      W3,W4
00694:  BRA     C,6CE
.................... 	{
.................... 		k = 0;
00696:  CLR     872
.................... 		flag = 0;
00698:  BCLR.B  85B.0
.................... 
.................... 		//Me quedo con la Media del incremento MAX
.................... 		//De estos 200 puntos y del incremento de los anteriores
.................... 
.................... 		umbral = (maximo + maximo_ant)/2;
0069A:  MOV     86A,W0
0069C:  ADD     86C,W0
0069E:  MOV     W0,W5
006A0:  LSR     W5,#1,W0
006A2:  CALL    2EA
*
006A6:  MOV     W0,86E
006A8:  MOV     W1,870
.................... 		maximo_ant = maximo;
006AA:  PUSH    86A
006AC:  POP     86C
.................... 		maximo = 0;
006AE:  CLR     86A
.................... 
.................... 		//Reduzco el umbral al 66%
.................... 
.................... 		umbral = umbral -(umbral/3);
006B0:  MOV     86E,W0
006B2:  MOV     870,W1
006B4:  MOV     #0,W2
006B6:  MOV     #4040,W3
006B8:  CALL    3A4
*
006BC:  BSET.B  43.0
006BE:  MOV     W0,W2
006C0:  MOV     W1,W3
006C2:  MOV     86E,W0
006C4:  MOV     870,W1
006C6:  CALL    46E
*
006CA:  MOV     W0,86E
006CC:  MOV     W1,870
.................... 	}
.................... 
.................... 	//Si pasa un rato
.................... 	//equivaldria a un pulso de 15bpm si se detectara punto R
.................... 	//y no se ha superado el umbral se reinicia
.................... 
.................... 	if(BCL > 1000)
006CE:  MOV     874,W4
006D0:  MOV     #3E8,W3
006D2:  CP      W3,W4
006D4:  BRA     C,6E0
.................... 	{
.................... 		maximo = 0;
006D6:  CLR     86A
.................... 		umbral = 0;
006D8:  CLR     86E
006DA:  CLR     870
.................... 		flag = 1;
006DC:  BSET.B  85B.0
.................... 		BCL = 0;
006DE:  CLR     874
.................... 	}
.................... 	//Calculo el ritmo cardiaco (si esta en rango fisiologico)
.................... 	//y si no permanece el valor anteriore
.................... 	//15000 son las muestras de 1 minuto (60000[ms]/4[ms/muestra])
.................... 
.................... 	if((BCL2>60)&&(BCL2<750)) // Ritmo entre 20 ppm y 260 ppm
006E0:  MOV     876,W4
006E2:  MOV     #3C,W3
006E4:  CP      W3,W4
006E6:  BRA     C,6FA
006E8:  MOV     876,W4
006EA:  MOV     #2EE,W3
006EC:  CP      W3,W4
006EE:  BRA     LEU,6FA
.................... 	{
.................... 		pulsaciones = (int)(15000/BCL2);
006F0:  MOV     #3A98,W4
006F2:  MOV     876,W3
006F4:  REPEAT  #11
006F6:  DIV.U   W4,W3
006F8:  MOV     W0,135C
.................... 	}
.................... BCL=BCL+1;  // Actualiza la cuenta ente ciclos
006FA:  MOV     874,W4
006FC:  ADD     W4,#1,W0
006FE:  MOV     W0,874
.................... return pulsaciones;
00700:  PUSH    135C
00702:  POP     0
00704:  MOV     [--W15],W5
00706:  RETURN  
.................... }
.................... 
.................... 
.................... #endif // __ALGORITMO_H
.................... 
.................... #include "miFAT.h"
.................... // Definidos en sdcard.h - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... extern unsigned int8 dt[512];
.................... extern unsigned int32 LBA0;
.................... extern unsigned int8 sd_init();
.................... extern unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr);
.................... extern unsigned int8 sd_read_block( unsigned int32 address, unsigned char* ptr);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define MAX_ENTRIES_SECTOR_FAT16        256
.................... #define ENDFILE16                    0xFFFF
.................... #define MAX_ENTRIES_SECTOR_FAT32        128
.................... #define ENDFILE32                0x0FFFFFFF
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... typedef struct{
.................... 	union{
.................... 		unsigned int8 raw[32];
.................... 		struct fields{
.................... 			char name[8];
.................... 			char extension[3];
.................... 			unsigned int8 attrib;			///s�lo lectura, oculto, de sistema, directorio...
.................... 			//unsigned int8 reserved[10];
.................... 			  unsigned int8  reserved;
.................... 	 		  unsigned int8  createTimeMs;
.................... 			  unsigned int16 create_hour;
.................... 			  unsigned int16 create_date;
.................... 			  unsigned int16 last_access;
.................... 			  unsigned int16 eaIndex;
.................... 			  unsigned int16 modif_hour;
.................... 			  unsigned int16 modif_date;
.................... 			  unsigned int16 first_cluster;	///primer cluster (direcciona tabla FAT y sector para escribir contenido)
.................... 			  unsigned int32 size;			///tama�o en bytes
.................... 		};
.................... 	};
.................... } fileEntry;
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... typedef struct{
.................... 	unsigned int32 currentCluster;
.................... 	unsigned int32 currentSector;
.................... 	unsigned int16 posInSector;      //posici�n actual al escribir en el sector
.................... 	unsigned int32 sectorAtFAT;      //sector de la 1� FAT en el que tenemos el actual puntero de cierre de fichero
.................... 
.................... 	unsigned int32 sectorEntryFile; //direcci�n del sector de entradas de fichero
.................... 	unsigned int8  EntryFile[512];  //sector donde est� la entrada (root) del fichero (para actualizar tama�o)
.................... 	unsigned int16 offsetEntry;     //offset en el sector de entradas del fichero
.................... 	unsigned int32 size;            //tama�o del fichero
.................... }_file;
.................... 
.................... _file file;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... typedef struct _diskinforec{
....................    unsigned int8  jmpBoot[3];   // bytes  0.. 2: Salto a la rutina de arranque
....................    unsigned int8  OEMName[8];   // bytes  3..10: Es una cadena "MSDOS5.0"
....................    unsigned int16 BytsPerSec;   // bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes)
....................    unsigned int8  SectPerClus;  // byte  13:    Numero de sectores contenidos en 1 cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes
....................    unsigned int16 RsrvdCnt;     // bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente
....................    unsigned int8  NumFATs;      // byte  16:    Numero de tablas FAT en el volumen. Habitualmente es 2
....................    unsigned int16 RootEntCnt;   // bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
....................    unsigned int16 TotSect16;    // bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0)
....................    unsigned int8  Media;        // byte  21:    Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0
....................    unsigned int16 FATsz16;      // bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0)
....................    unsigned int16 SectPerTrack; // bytes 24..25: Sectores por track
....................    unsigned int16 NumHeads;     // bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.)
....................    unsigned int32 HiddSec;      // bytes 28..31: Sectores ocultos que preceden a la particion (irrelevante en uSD)
....................    unsigned int32 TotSect32;    // bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta
....................    unsigned int32 FATsz32;      // bytes 36..39: Numero de sectores ocupados por una FAT
....................    unsigned int16 ExtFlags;     // bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0)
....................    unsigned int16 FSVer;        // bytes 42..43: Version del sistema de archivos (empleamos la 0.0)
....................    unsigned int32 RootClus;     // bytes 44..47: Indica el numero del 1er cluster del directorio raiz.
....................    unsigned int16 FSInfo;       // bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1)
....................    unsigned int16 BkBootSec;    // bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque
....................    unsigned int8  RsrvdSys[12]; // bytes 52..63: Bytes reservados para futuros usos del sistema
....................    unsigned int8  DrvNum;       // byte  64:     Numero de la unidad (para MSDOS pero irrelevante en uSD).
....................    unsigned int8  Reserved1;    // byte  65:     Windows NT para formatear un volumen pone este byte a 0
....................    unsigned int8  BootSig;      // byte  66:     Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows)
....................    unsigned int32 VolId;        // bytes 67..70: Numero de volumen (generado por el reloj del sistema).
....................    unsigned int8  VolLab[11];   // bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME     ". Nosotros podemos poner "NUUBO_SD    "
....................    unsigned int8  FilSysType[8];// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   "
....................    unsigned int8  spam[420];    // bytes 90..509:Zona de codigo (no lo empleamos y esta a 0)
....................    unsigned int16 firma;        // byte 510..511:Debe de vale 55 AA
.................... } diskinforec;
.................... 
.................... diskinforec DiskInfo;
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned  int8 FATType; // FAT16 o FAT32
.................... //variables clave: inicio de la FAT1 y la FAT2 y de las entradas de ficheros
.................... unsigned  int8 sect_x_cluster;
.................... unsigned int16 sect_fat_1;
.................... unsigned int16 sect_fat_2;
.................... unsigned int32 sect_ini_datos;
.................... unsigned int32 sect_x_fat;
.................... unsigned int32 sect_entry;
.................... unsigned int16 sect_reserv;
.................... 
.................... //unsigned int8 dFil[32];
.................... unsigned int32 sector_fat32[MAX_ENTRIES_SECTOR_FAT32]; // 128 x 4 = 512
.................... unsigned int16 sector_fat16[MAX_ENTRIES_SECTOR_FAT16]; // 256 x 2 = 512
.................... 
.................... //atributos
.................... #define __FILE		0x20
.................... #define _DIRECTORY	0x10
.................... #define _VOLUMEN	0x08
.................... #define _SYSTEM		0x04
.................... #define _HIDDEN		0x02
.................... #define READONLY	0x01
.................... 
.................... ///variables globales
.................... unsigned int16 year = 2020;
.................... unsigned int8 yearLo=   20;
.................... unsigned int8 month =   10;
.................... unsigned int8 day   =	15;
.................... unsigned int8 hour	=   12;
.................... unsigned int8 minute=   34;
.................... unsigned int8 second=   56;
.................... 
.................... ///funciones
.................... #define getHour() (int16)((int16)hour << 11) + (int16)((int16)minute << 5) + (int16) (second >> 1)		//5 bits: horas, 6 bits: minutos, 5 bits: segundos/2
.................... #define getDate() (((int16)year - 1980) << 9 ) + ((int16)month << 5) + (int16)day	//7 bits: a�o (desde 1980), 4 bits: mes, 5 bits: dia
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... void initFAT(){
*
00DE2:  MOV     W5,[W15++]
00DE4:  MOV     W6,[W15++]
00DE6:  MOV     W7,[W15++]
00DE8:  MOV     #2,W4
00DEA:  MOV     W4,12EE
00DEC:  CLR     12F0
....................    unsigned int32 startClusterOfRootDirectory = 2;
....................    unsigned int32 sctrs;
....................    unsigned  int8 *ptrSct;
....................    diskinforec *ptrDiskInfo;
.................... 
.................... 	sd_read_block(LBA0, dt);
00DEE:  PUSH    A78
00DF0:  POP     1346
00DF2:  PUSH    A7A
00DF4:  POP     1348
00DF6:  MOV     #878,W4
00DF8:  MOV     W4,134A
00DFA:  CALL    AD2
....................     						ptrDiskInfo=&DiskInfo;
*
00DFE:  MOV     #C94,W4
00E00:  MOV     W4,12F8
....................     						ptrSct= &dt[0];
00E02:  MOV     #878,W4
00E04:  MOV     W4,12F6
....................    	memcpy((*ptrDiskInfo).jmpBoot, (ptrSct +  0), 3); 			//DiskInfo.jmpBoot[3]	// bytes  0.. 2: Salto a la rutina de arranque
00E06:  MOV     12F8,W5
00E08:  MOV     W5,W6
00E0A:  MOV     W6,W1
00E0C:  MOV     12F6,W2
00E0E:  REPEAT  #2
00E10:  MOV.B   [W2++],[W1++]
....................    	memcpy((*ptrDiskInfo).OEMName, (ptrSct +  3), 8); 			//DiskInfo.OEMName[8]	// bytes  3..10: Es una cadena, habitualmente "MSDOS5.0"
00E12:  MOV     12F8,W5
00E14:  ADD     W5,#3,W6
00E16:  MOV     12F6,W4
00E18:  ADD     W4,#3,W7
00E1A:  MOV     W6,W1
00E1C:  MOV     W7,W2
00E1E:  REPEAT  #7
00E20:  MOV.B   [W2++],[W1++]
....................    	DiskInfo.BytsPerSec = make16(dt[12],dt[11]);   				// bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes)
00E22:  MOV.B   883,W0L
00E24:  MOV.B   W0L,CA0
00E26:  MOV.B   884,W0L
00E28:  MOV.B   W0L,CA1
.................... 	DiskInfo.SectPerClus = dt[13];								// byte  13:	 Numero de sectores contenidos en un cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes
00E2A:  MOV.B   885,W0L
00E2C:  MOV.B   W0L,CA2
.................... 	DiskInfo.RsrvdCnt = make16(dt[15],dt[14]);					// bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente
00E2E:  MOV.B   886,W0L
00E30:  MOV.B   W0L,CA4
00E32:  MOV.B   887,W0L
00E34:  MOV.B   W0L,CA5
....................    	DiskInfo.NumFATs = dt[16];									// byte  16:	 Numero de tablas FAT en el volumen. Habitualmente es 2
00E36:  MOV.B   888,W0L
00E38:  MOV.B   W0L,CA6
.................... 	DiskInfo.RootEntCnt = make16(dt[18],dt[17]);				// bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
00E3A:  MOV.B   889,W0L
00E3C:  MOV.B   W0L,CA8
00E3E:  MOV.B   88A,W0L
00E40:  MOV.B   W0L,CA9
....................    	DiskInfo.TotSect16 = make16(dt[20],dt[19]);					// bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0)
00E42:  MOV.B   88B,W0L
00E44:  MOV.B   W0L,CAA
00E46:  MOV.B   88C,W0L
00E48:  MOV.B   W0L,CAB
.................... 	DiskInfo.Media = dt[21];									// byte  21:	 Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0
00E4A:  MOV.B   88D,W0L
00E4C:  MOV.B   W0L,CAC
.................... 	DiskInfo.FATsz16 = make16(dt[23],dt[22]);					// bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0)
00E4E:  MOV.B   88E,W0L
00E50:  MOV.B   W0L,CAE
00E52:  MOV.B   88F,W0L
00E54:  MOV.B   W0L,CAF
.................... 	DiskInfo.SectPerTrack = make16(dt[25],dt[24]); 				// bytes 24..25: Sectores por track
00E56:  MOV.B   890,W0L
00E58:  MOV.B   W0L,CB0
00E5A:  MOV.B   891,W0L
00E5C:  MOV.B   W0L,CB1
....................    	DiskInfo.NumHeads = make16(dt[27],dt[26]);					// bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.)
00E5E:  MOV.B   892,W0L
00E60:  MOV.B   W0L,CB2
00E62:  MOV.B   893,W0L
00E64:  MOV.B   W0L,CB3
.................... 	DiskInfo.HiddSec = make32(dt[31],dt[30],dt[29],dt[28]);		// bytes 28..31: Sectores ocultos que preceden a la particion
00E66:  MOV.B   897,W0L
00E68:  MOV.B   W0L,CB7
00E6A:  MOV.B   896,W0L
00E6C:  MOV.B   W0L,CB6
00E6E:  MOV.B   895,W0L
00E70:  MOV.B   W0L,CB5
00E72:  MOV.B   894,W0L
00E74:  MOV.B   W0L,CB4
.................... 	DiskInfo.TotSect32=make32(dt[35],dt[34],dt[33],dt[32]);		// bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta
00E76:  MOV.B   89B,W0L
00E78:  MOV.B   W0L,CBB
00E7A:  MOV.B   89A,W0L
00E7C:  MOV.B   W0L,CBA
00E7E:  MOV.B   899,W0L
00E80:  MOV.B   W0L,CB9
00E82:  MOV.B   898,W0L
00E84:  MOV.B   W0L,CB8
.................... 	DiskInfo.FATsz32 = make32(dt[39],dt[38],dt[37],dt[36]);		// bytes 36..39: Numero de sectores ocupados por una FAT
00E86:  MOV.B   89F,W0L
00E88:  MOV.B   W0L,CBF
00E8A:  MOV.B   89E,W0L
00E8C:  MOV.B   W0L,CBE
00E8E:  MOV.B   89D,W0L
00E90:  MOV.B   W0L,CBD
00E92:  MOV.B   89C,W0L
00E94:  MOV.B   W0L,CBC
.................... 	DiskInfo.ExtFlags = make16(dt[41],dt[40]); 					// bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0)
00E96:  MOV.B   8A0,W0L
00E98:  MOV.B   W0L,CC0
00E9A:  MOV.B   8A1,W0L
00E9C:  MOV.B   W0L,CC1
.................... 	DiskInfo.FSVer = make16(dt[43],dt[42]); 					// bytes 42..43: Version del sistema de archivos (empleamos la 0.0)
00E9E:  MOV.B   8A2,W0L
00EA0:  MOV.B   W0L,CC2
00EA2:  MOV.B   8A3,W0L
00EA4:  MOV.B   W0L,CC3
.................... 	DiskInfo.RootClus= make32(dt[47],dt[46],dt[45],dt[44]);		// bytes 44..47: Indica el numero del 1er cluster del directorio raiz.
00EA6:  MOV.B   8A7,W0L
00EA8:  MOV.B   W0L,CC7
00EAA:  MOV.B   8A6,W0L
00EAC:  MOV.B   W0L,CC6
00EAE:  MOV.B   8A5,W0L
00EB0:  MOV.B   W0L,CC5
00EB2:  MOV.B   8A4,W0L
00EB4:  MOV.B   W0L,CC4
.................... 	DiskInfo.FSInfo = make16(dt[49],dt[48]); 					// bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1)
00EB6:  MOV.B   8A8,W0L
00EB8:  MOV.B   W0L,CC8
00EBA:  MOV.B   8A9,W0L
00EBC:  MOV.B   W0L,CC9
.................... 	DiskInfo.BkBootSec = make16(dt[51],dt[50]); 				// bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque
00EBE:  MOV.B   8AA,W0L
00EC0:  MOV.B   W0L,CCA
00EC2:  MOV.B   8AB,W0L
00EC4:  MOV.B   W0L,CCB
.................... 	//  Estructura en el caso de FAT32 �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �  �
.................... 	memcpy((*ptrDiskInfo).RsrvdSys, (ptrSct +  52), 12);		//DiskInfo.RsrvdSys[12] 	// bytes 52..63: Bytes reservados para futuros usos del sistema
00EC6:  MOV     12F8,W5
00EC8:  MOV     #38,W4
00ECA:  ADD     W5,W4,W6
00ECC:  MOV     #34,W4
00ECE:  MOV     12F6,W3
00ED0:  ADD     W3,W4,W7
00ED2:  MOV     W6,W1
00ED4:  MOV     W7,W2
00ED6:  REPEAT  #B
00ED8:  MOV.B   [W2++],[W1++]
.................... 	DiskInfo.DrvNum = dt[64];								 	// byte  64: 	 Numero de la unidad
00EDA:  MOV.B   8B8,W0L
00EDC:  MOV.B   W0L,CD8
.................... 	DiskInfo.Reserved1 = dt[65];								// byte  65: 	 Windows NT para formatear un volumen pone este byte a 0
00EDE:  MOV.B   8B9,W0L
00EE0:  MOV.B   W0L,CD9
.................... 	DiskInfo.BootSig = dt[66]; 									// byte  66: 	 Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows)
00EE2:  MOV.B   8BA,W0L
00EE4:  MOV.B   W0L,CDA
.................... 	DiskInfo.VolId = make32(dt[70],dt[69],dt[68],dt[67]); 		// bytes 67..70: Numero de volumen (generado por el reloj del sistema).
00EE6:  MOV.B   8BE,W0L
00EE8:  MOV.B   W0L,CDF
00EEA:  MOV.B   8BD,W0L
00EEC:  MOV.B   W0L,CDE
00EEE:  MOV.B   8BC,W0L
00EF0:  MOV.B   W0L,CDD
00EF2:  MOV.B   8BB,W0L
00EF4:  MOV.B   W0L,CDC
.................... 	memcpy((*ptrDiskInfo).VolLab, (ptrSct +  71), 11);			//DiskInfo.VolLab[11]	// bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME    "
00EF6:  MOV     12F8,W5
00EF8:  MOV     #4C,W4
00EFA:  ADD     W5,W4,W6
00EFC:  MOV     #47,W4
00EFE:  MOV     12F6,W3
00F00:  ADD     W3,W4,W7
00F02:  MOV     W6,W1
00F04:  MOV     W7,W2
00F06:  REPEAT  #A
00F08:  MOV.B   [W2++],[W1++]
.................... 	memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  82), 8);		//DiskInfo.FilSysType[8] 	// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   "
00F0A:  MOV     12F8,W5
00F0C:  MOV     #57,W4
00F0E:  ADD     W5,W4,W6
00F10:  MOV     #52,W4
00F12:  MOV     12F6,W3
00F14:  ADD     W3,W4,W7
00F16:  MOV     W6,W1
00F18:  MOV     W7,W2
00F1A:  REPEAT  #7
00F1C:  MOV.B   [W2++],[W1++]
.................... 	memcpy((*ptrDiskInfo).spam, (ptrSct +  90),420);			//DiskInfo.spam[420]		// bytes 90..509:Zona de codigo (en uSD no se emplea y suele estar a 0)
00F1E:  MOV     12F8,W5
00F20:  MOV     #5F,W4
00F22:  ADD     W5,W4,W6
00F24:  MOV     #5A,W4
00F26:  MOV     12F6,W3
00F28:  ADD     W3,W4,W7
00F2A:  MOV     W6,W1
00F2C:  MOV     W7,W2
00F2E:  REPEAT  #1A3
00F30:  MOV.B   [W2++],[W1++]
.................... 	DiskInfo.firma = make16(dt[510],dt[511]);								// byte 510..511:Debe de vale 55 AA
00F32:  MOV.B   A77,W0L
00F34:  MOV.B   W0L,E98
00F36:  MOV.B   A76,W0L
00F38:  MOV.B   W0L,E99
.................... 
....................    		FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'3''2'
00F3A:  MOV     CEE,W4
00F3C:  SUB.B   #30,W4L
00F3E:  MOV.B   W4L,W0L
00F40:  MOV.B   W0L,0
00F42:  MOV.B   W0L,W4L
00F44:  CLR.B   9
00F46:  MUL.UU  W4,#A,W0
00F48:  MOV     W0,W5
00F4A:  MOV     CEE,W4
00F4C:  LSR     W4,#8,W4
00F4E:  ADD     W5,W4,W5
00F50:  MOV     #30,W4
00F52:  SUB.B   W5L,W4L,W0L
00F54:  MOV.B   W0L,E9A
.................... 
....................    if(FATType == 32){
00F56:  MOV     E9A,W4
00F58:  XOR.B   #20,W4L
00F5A:  BRA     NZ,F70
.................... 						sect_x_fat  = DiskInfo.FATsz32;		// Sectores reservados para la FAT
00F5C:  PUSH    CBC
00F5E:  POP     EA4
00F60:  PUSH    CBE
00F62:  POP     EA6
.................... 						startClusterOfRootDirectory = DiskInfo.RootClus;
00F64:  PUSH    CC4
00F66:  POP     12EE
00F68:  PUSH    CC6
00F6A:  POP     12F0
....................  	}else{
00F6C:  GOTO    FA0
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);	//DiskInfo.FilSysType[8] 	// bytes 54..61: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT16   "
*
00F70:  MOV     12F8,W5
00F72:  MOV     #57,W4
00F74:  ADD     W5,W4,W6
00F76:  MOV     #36,W4
00F78:  MOV     12F6,W3
00F7A:  ADD     W3,W4,W7
00F7C:  MOV     W6,W1
00F7E:  MOV     W7,W2
00F80:  REPEAT  #7
00F82:  MOV.B   [W2++],[W1++]
.................... 						FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'1''6'
00F84:  MOV     CEE,W4
00F86:  SUB.B   #30,W4L
00F88:  MOV.B   W4L,W0L
00F8A:  MOV.B   W0L,0
00F8C:  MOV.B   W0L,W4L
00F8E:  CLR.B   9
00F90:  MUL.UU  W4,#A,W0
00F92:  MOV     W0,W5
00F94:  MOV     CEE,W4
00F96:  LSR     W4,#8,W4
00F98:  ADD     W5,W4,W5
00F9A:  MOV     #30,W4
00F9C:  SUB.B   W5L,W4L,W0L
00F9E:  MOV.B   W0L,E9A
.................... 	}
.................... 
.................... 	if(FATType == 16){
00FA0:  MOV     E9A,W4
00FA2:  CP.B    W4L,#10
00FA4:  BRA     NZ,FEA
.................... 						DiskInfo.VolId = make32(dt[42],dt[41],dt[40],dt[39]);
00FA6:  MOV.B   8A2,W0L
00FA8:  MOV.B   W0L,CDF
00FAA:  MOV.B   8A1,W0L
00FAC:  MOV.B   W0L,CDE
00FAE:  MOV.B   8A0,W0L
00FB0:  MOV.B   W0L,CDD
00FB2:  MOV.B   89F,W0L
00FB4:  MOV.B   W0L,CDC
.................... 						memcpy((*ptrDiskInfo).VolLab, (ptrSct +  43), 11);
00FB6:  MOV     12F8,W5
00FB8:  MOV     #4C,W4
00FBA:  ADD     W5,W4,W6
00FBC:  MOV     #2B,W4
00FBE:  MOV     12F6,W3
00FC0:  ADD     W3,W4,W7
00FC2:  MOV     W6,W1
00FC4:  MOV     W7,W2
00FC6:  REPEAT  #A
00FC8:  MOV.B   [W2++],[W1++]
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);
00FCA:  MOV     12F8,W5
00FCC:  MOV     #57,W4
00FCE:  ADD     W5,W4,W6
00FD0:  MOV     #36,W4
00FD2:  MOV     12F6,W3
00FD4:  ADD     W3,W4,W7
00FD6:  MOV     W6,W1
00FD8:  MOV     W7,W2
00FDA:  REPEAT  #7
00FDC:  MOV.B   [W2++],[W1++]
.................... 
.................... 						sect_x_fat  = DiskInfo.FATsz16;		// Sectores reservados para la FAT
00FDE:  PUSH    CAE
00FE0:  POP     EA4
00FE2:  CLR     EA6
.................... 						startClusterOfRootDirectory = DiskInfo.RootEntCnt;
00FE4:  PUSH    CA8
00FE6:  POP     12EE
00FE8:  CLR     12F0
....................  					}
.................... 
....................   	sect_x_cluster = DiskInfo.SectPerClus;					// Cada cluster tiene este numero de sectores
00FEA:  MOV.B   CA2,W0L
00FEC:  MOV.B   W0L,E9B
.................... 
....................     			      sctrs  = LBA0;
00FEE:  PUSH    A78
00FF0:  POP     12F2
00FF2:  PUSH    A7A
00FF4:  POP     12F4
.................... 				  	  sctrs += DiskInfo.RsrvdCnt;
00FF6:  MOV     12F2,W0
00FF8:  ADD     CA4,W0
00FFA:  MOV     W0,12F2
00FFC:  MOV     12F4,W4
00FFE:  ADDC    W4,#0,W0
01000:  MOV     W0,12F4
.................... 	sect_reserv 	= sctrs;								// sectores reservados por el sistema
01002:  PUSH    12F2
01004:  POP     EAC
.................... 
....................     sect_fat_1  	= sctrs;               					// A partir de ah�: FAT 1
01006:  PUSH    12F2
01008:  POP     E9C
.................... 				  	  sctrs += sect_x_fat;
0100A:  MOV     12F2,W0
0100C:  ADD     EA4,W0
0100E:  MOV     W0,12F2
01010:  MOV     EA6,W4
01012:  MOV     12F4,W3
01014:  ADDC    W3,W4,W0
01016:  MOV     W0,12F4
.................... 	sect_fat_2  	= sctrs;;								// A partir de ah�: FAT 2 (copia de seguridad)
01018:  PUSH    12F2
0101A:  POP     E9E
.................... 				  	  sctrs += sect_x_fat;
0101C:  MOV     12F2,W0
0101E:  ADD     EA4,W0
01020:  MOV     W0,12F2
01022:  MOV     EA6,W4
01024:  MOV     12F4,W3
01026:  ADDC    W3,W4,W0
01028:  MOV     W0,12F4
.................... 	sect_entry  	= sctrs ;      							// A partir de ah� empieza el ra�z (la lista de ficheros)
0102A:  PUSH    12F2
0102C:  POP     EA8
0102E:  PUSH    12F4
01030:  POP     EAA
.................... 					  sctrs += sect_x_cluster;
01032:  MOV     E9A,W4
01034:  LSR     W4,#8,W4
01036:  MOV     12F2,W3
01038:  ADD     W3,W4,W0
0103A:  MOV     W0,12F2
0103C:  MOV     12F4,W3
0103E:  ADDC    W3,#0,W0
01040:  MOV     W0,12F4
.................... 	sect_ini_datos 	= sctrs ;								// A partir de ahi los datos del fichero
01042:  PUSH    12F2
01044:  POP     EA0
01046:  PUSH    12F4
01048:  POP     EA2
.................... 
....................     if(FATType == 16)										// RootEntCnt: Numero de entradas de 32 bytes al
0104A:  MOV     E9A,W4
0104C:  CP.B    W4L,#10
0104E:  BRA     NZ,1062
....................     sect_ini_datos = sect_entry+(DiskInfo.RootEntCnt>>4);	// directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
01050:  MOV     CA8,W0
01052:  LSR     W0,#4,W0
01054:  MOV     EA8,W4
01056:  ADD     W0,W4,W0
01058:  MOV     W0,EA0
0105A:  MOV     EAA,W4
0105C:  MOV     #0,W3
0105E:  ADDC    W3,W4,W0
01060:  MOV     W0,EA2
01062:  MOV     [--W15],W7
01064:  MOV     [--W15],W6
01066:  MOV     [--W15],W5
01068:  RETURN  
.................... 
.................... }//fin initFAT()
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void cargaConfig(unsigned int32 j);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 encontrar_fichero(){
....................    unsigned int8 FicheroEncontrado = 0;
....................    unsigned int32 i;
....................    unsigned int16 j,k=0;
....................    unsigned int32 SctStart = sect_entry;			//inicio Root
....................    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root
....................    unsigned int32 ClstIni  = ((FATType==16)?1:2);
.................... 
....................    unsigned int32 ClstNxt;
....................    unsigned int32 sctrClstr;
....................    unsigned int32 posSctr;
....................    unsigned int32 clstrSig;
.................... 
....................    for(i = SctStart; i < SctEnd; i++){
.................... 	      sd_read_block(i, dt);
.................... 		 for(j = 0; j < 512; j += 32){
.................... 										k=0;
.................... 										if(	(dt[j + 0] == 'C')&&
.................... 											(dt[j + 1] == 'O')&&
.................... 											(dt[j + 2] == 'N')&&
.................... 											(dt[j + 3] == 'F')&&
.................... 											(dt[j + 4] == 'I')&&
.................... 											(dt[j + 5] == 'G')&&
.................... 											(dt[j + 6] == ' ')&&
.................... 											(dt[j + 7] == ' ')&&
.................... 											(dt[j + 8] == 'T')&&
.................... 											(dt[j + 9] == 'X')&&
.................... 											(dt[j +10] == 'T')){
.................... 																 cargaConfig(j);
.................... 																 FicheroEncontrado = 1;
.................... 																 return FicheroEncontrado;
.................... 																}//fin if(CNF)
.................... 
.................... 		}//j
....................    }//i
....................    return FicheroEncontrado;
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void cargaConfig(unsigned int32 j){
....................    unsigned int32 direccion;
....................    unsigned int32 _sector;
.................... 
.................... 	if(FATType==16){
.................... 	   	direccion = make32(0,0,dt[j+27],dt[j+26]);
.................... 		_sector = ((unsigned int32)direccion - 2) * sect_x_cluster + sect_ini_datos;
.................... 	}
.................... 	if(FATType==32){
.................... 	   direccion = make32(dt[j+21],dt[j+20],dt[j+27],dt[j+26]); //en FAT32 se usa EAIndex + first cluster
.................... 	   _sector = ((unsigned int32)direccion - 3) * sect_x_cluster + sect_ini_datos;
....................    }
.................... 	sd_read_block(_sector, dt);
....................    // Ahora en el vector dt tengo los datos del fichero y puedo emplearlo
....................    // Por ejemplo: el texto que indica la hora y minutos del ensayo lo obtendria como:
....................    // hora   = (dt[140]-'0')*10 + dt[141]-'0' ;
....................    // minutos= (dt[143]-'0')*10 + dt[144]-'0' ;
....................    // ... Y con esos datos haria algo util
.................... 
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 inicializa_fichero(){
*
013CC:  MOV     W5,[W15++]
013CE:  MOV     W6,[W15++]
013D0:  CLR.B   12EE
013D2:  PUSH    EA8
013D4:  POP     12F6
013D6:  PUSH    EAA
013D8:  POP     12F8
013DA:  PUSH    EA0
013DC:  POP     12FA
013DE:  PUSH    EA2
013E0:  POP     12FC
013E2:  MOV     E9A,W4
013E4:  CP.B    W4L,#10
013E6:  BRA     NZ,13F0
013E8:  MOV     #0,W0
013EA:  MOV     #0,W1
013EC:  GOTO    13F4
*
013F0:  MOV     #1,W0
013F2:  MOV     #0,W1
013F4:  MOV     W0,12FE
013F6:  MOV     W1,1300
....................    unsigned int8 FicheroIncializado = 0;
....................    unsigned int32 i;
....................    unsigned int16 j;
....................    unsigned int32 SctStart = sect_entry;			//inicio Root
....................    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root
....................    unsigned int32 ClstIni  = ((FATType==16)?0:1);
.................... 
....................    unsigned int32 ClstNxt;
....................    unsigned int32 sctrClstr;
....................    unsigned int32 posSctr;
....................    unsigned int32 clstrSig;
.................... 
....................    unsigned int32 startCluster;      //cluster donde empezar�an los datos del fichero
....................    fileEntry newFile;
.................... 
....................    for(i = SctStart; i < SctEnd; i++){
013F8:  PUSH    12F6
013FA:  POP     12F0
013FC:  PUSH    12F8
013FE:  POP     12F2
01400:  MOV     12F2,W0
01402:  MOV     12FC,W4
01404:  CP      W4,W0
01406:  BRA     NC,1732
01408:  BRA     GTU,1412
0140A:  MOV     12F0,W0
0140C:  MOV     12FA,W4
0140E:  CP      W4,W0
01410:  BRA     LEU,1732
.................... 	      sd_read_block(i, dt);
01412:  PUSH    12F0
01414:  POP     1346
01416:  PUSH    12F2
01418:  POP     1348
0141A:  MOV     #878,W4
0141C:  MOV     W4,134A
0141E:  CALL    AD2
.................... 		  for(j = 0; j < 512; j += 32){
*
01422:  CLR     12F4
01424:  MOV     12F4,W4
01426:  MOV     #200,W3
01428:  CP      W3,W4
0142A:  BRA     LEU,1728
.................... 			if((dt[j] == 0x00) || dt[j] == 0xFF){
0142C:  MOV     #878,W4
0142E:  MOV     12F4,W3
01430:  ADD     W3,W4,W0
01432:  CP0.B   [W0]
01434:  BRA     Z,1442
01436:  MOV     #878,W4
01438:  MOV     12F4,W3
0143A:  ADD     W3,W4,W0
0143C:  MOV.B   [W0],W4L
0143E:  XOR.B   #FF,W4L
01440:  BRA     NZ,171C
.................... 					   newFile.fields.name[0] = 		'L';
01442:  MOV.B   #4C,W0L
01444:  MOV.B   W0L,1316
.................... 					   newFile.fields.name[1] = 		'A';
01446:  MOV.B   #41,W0L
01448:  MOV.B   W0L,1317
.................... 					   newFile.fields.name[2] = 		'T';
0144A:  MOV.B   #54,W0L
0144C:  MOV.B   W0L,1318
.................... 					   newFile.fields.name[3] = 		'I';
0144E:  MOV.B   #49,W0L
01450:  MOV.B   W0L,1319
.................... 					   newFile.fields.name[4] = 		'D';
01452:  MOV.B   #44,W0L
01454:  MOV.B   W0L,131A
.................... 					   newFile.fields.name[5] = 		'O';
01456:  MOV.B   #4F,W0L
01458:  MOV.B   W0L,131B
.................... 					   newFile.fields.name[6] = 		'S';
0145A:  MOV.B   #53,W0L
0145C:  MOV.B   W0L,131C
.................... 					   newFile.fields.name[7] = 		'_';
0145E:  MOV.B   #5F,W0L
01460:  MOV.B   W0L,131D
.................... 					   newFile.fields.extension[0] = 	'T';
01462:  MOV.B   #54,W0L
01464:  MOV.B   W0L,131E
.................... 					   newFile.fields.extension[1] = 	'X';
01466:  MOV.B   #58,W0L
01468:  MOV.B   W0L,131F
.................... 					   newFile.fields.extension[2] = 	'T';
0146A:  MOV.B   #54,W0L
0146C:  MOV.B   W0L,1320
.................... 					   newFile.fields.reserved = 0;
0146E:  CLR.B   1322
.................... 					   newFile.fields.createTimeMs = 0;
01470:  CLR.B   1323
.................... 					   newFile.fields.create_hour = getHour();
01472:  MOV.B   12B3,W0L
01474:  MOV.B   W0L,W5L
01476:  CLR.B   B
01478:  SL      W5,#B,W5
0147A:  MOV.B   12B4,W0L
0147C:  MOV.B   W0L,C
0147E:  CLR.B   D
01480:  SL      W6,#5,W0
01482:  ADD     W0,W5,W5
01484:  MOV.B   12B5,W0L
01486:  CLR.B   1
01488:  LSR     W0,#1,W0
0148A:  ADD     W0,W5,W0
0148C:  MOV     W0,1324
.................... 					   newFile.fields.create_date = getDate();
0148E:  MOV     12AE,W4
01490:  MOV     #7BC,W3
01492:  SUB     W4,W3,W5
01494:  SL      W5,#9,W5
01496:  MOV.B   12B1,W0L
01498:  MOV.B   W0L,W6L
0149A:  CLR.B   D
0149C:  SL      W6,#5,W0
0149E:  ADD     W0,W5,W5
014A0:  MOV.B   12B2,W0L
014A2:  CLR.B   1
014A4:  ADD     W0,W5,W0
014A6:  MOV     W0,1326
.................... 					   newFile.fields.last_access = newFile.fields.create_date;
014A8:  PUSH    1326
014AA:  POP     1328
.................... 					   newFile.fields.eaIndex = 0;
014AC:  CLR     132A
.................... 					   newFile.fields.attrib = __FILE ;   //archivo normal + s�lo lectura  | READONLY
014AE:  MOV.B   #20,W0L
014B0:  MOV.B   W0L,1321
.................... 					   newFile.fields.modif_hour = newFile.fields.create_hour;
014B2:  PUSH    1324
014B4:  POP     132C
.................... 					   newFile.fields.modif_date = newFile.fields.create_date;
014B6:  PUSH    1326
014B8:  POP     132E
.................... 					   newFile.fields.first_cluster = 0;
014BA:  CLR     1330
.................... 					   newFile.fields.size = 0;
014BC:  CLR     1332
014BE:  CLR     1334
.................... 
.................... 					   file.offsetEntry = j;
014C0:  PUSH    12F4
014C2:  POP     C8E
.................... 					   file.sectorEntryFile = i;
014C4:  PUSH    12F0
014C6:  POP     A8A
014C8:  PUSH    12F2
014CA:  POP     A8C
.................... 					   sd_read_block(file.sectorEntryFile, file.EntryFile);
014CC:  PUSH    A8A
014CE:  POP     1346
014D0:  PUSH    A8C
014D2:  POP     1348
014D4:  MOV     #A8E,W4
014D6:  MOV     W4,134A
014D8:  CALL    AD2
.................... 
.................... 					   for(i = 0; i < 32; j++, i++)  dt[j] = newFile.raw[i];
*
014DC:  CLR     12F0
014DE:  CLR     12F2
014E0:  MOV     12F2,W4
014E2:  CP      W4,#0
014E4:  BRA     GTU,150C
014E6:  BRA     NC,14F0
014E8:  MOV     12F0,W4
014EA:  MOV     #20,W3
014EC:  CP      W3,W4
014EE:  BRA     LEU,150C
014F0:  MOV     #878,W4
014F2:  MOV     12F4,W3
014F4:  ADD     W3,W4,W5
014F6:  MOV     #1316,W4
014F8:  MOV     12F0,W3
014FA:  ADD     W3,W4,W0
014FC:  MOV.B   [W0],[W5]
014FE:  MOV     12F4,W0
01500:  INC     12F4
01502:  INC     12F0
01504:  BTSC.B  42.1
01506:  INC     12F2
01508:  GOTO    14E0
.................... 					   for(i = 0; i < 512; i++)      file.EntryFile[i] = dt[i];
*
0150C:  CLR     12F0
0150E:  CLR     12F2
01510:  MOV     12F2,W4
01512:  CP      W4,#0
01514:  BRA     GTU,1538
01516:  BRA     NC,1520
01518:  MOV     12F0,W4
0151A:  MOV     #200,W3
0151C:  CP      W3,W4
0151E:  BRA     LEU,1538
01520:  MOV     #A8E,W0
01522:  ADD     12F0,W0
01524:  MOV     W0,W5
01526:  MOV     #878,W4
01528:  MOV     12F0,W3
0152A:  ADD     W3,W4,W0
0152C:  MOV.B   [W0],[W5]
0152E:  INC     12F0
01530:  BTSC.B  42.1
01532:  INC     12F2
01534:  GOTO    1510
.................... 					   file.posInSector    = 0;   															//empezamos en un sector y cluster nuevos
*
01538:  CLR     A84
.................... 					   if(FATType==16){
0153A:  MOV     E9A,W4
0153C:  CP.B    W4L,#10
0153E:  BRA     NZ,1596
.................... 					   startCluster = encontrarCluster(2);         											//busco cluster donde empezar�a a almacenarse los datos
01540:  MOV     #2,W4
01542:  MOV     W4,1336
01544:  CLR     1338
01546:  CALL    10BE
*
0154A:  MOV     W0,1312
0154C:  MOV     W1,1314
.................... 					   file.currentCluster = startCluster;   												//que ser� el cluster en el que escribiremos
0154E:  PUSH    1312
01550:  POP     A7C
01552:  PUSH    1314
01554:  POP     A7E
.................... 					   file.currentSector  = (file.currentCluster -  2) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster)
01556:  MOV     A7C,W4
01558:  SUB     W4,#2,W5
0155A:  MOV     A7E,W4
0155C:  SUBB    W4,#0,W6
0155E:  MOV.B   E9B,W0L
01560:  MOV.B   W0L,W2L
01562:  CLR.B   5
01564:  MOV     #0,W3
01566:  MOV     W5,W0
01568:  MOV     W6,W1
0156A:  CALL    1268
*
0156E:  MOV     W0,W5
01570:  MOV     W1,W6
01572:  MOV     W5,W0
01574:  ADD     EA0,W0
01576:  MOV     W0,A80
01578:  MOV     EA2,W4
0157A:  ADDC    W6,W4,W0
0157C:  MOV     W0,A82
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 8) + sect_reserv;						//sector en la FAT donde marcar el cluster usado
0157E:  MOV.B   A7D,W0L
01580:  MOV.B   W0L,W5L
01582:  MOV.B   A7E,W0L
01584:  MOV.B   W0L,B
01586:  MOV.B   A7F,W0L
01588:  MOV.B   W0L,W6L
0158A:  CLR.B   D
0158C:  MOV     W5,W0
0158E:  ADD     EAC,W0
01590:  MOV     W0,A86
01592:  ADDC    W6,#0,W0
01594:  MOV     W0,A88
.................... 					   }
.................... 					   if(FATType==32){
01596:  MOV     E9A,W4
01598:  XOR.B   #20,W4L
0159A:  BRA     NZ,15F6
.................... 					   startCluster = encontrarCluster(3);         											//busco cluster donde empezar�a a almacenarse los datos
0159C:  MOV     #3,W4
0159E:  MOV     W4,1336
015A0:  CLR     1338
015A2:  CALL    10BE
*
015A6:  MOV     W0,1312
015A8:  MOV     W1,1314
.................... 					   file.currentCluster = startCluster;   												//que ser� el cluster en el que escribiremos
015AA:  PUSH    1312
015AC:  POP     A7C
015AE:  PUSH    1314
015B0:  POP     A7E
.................... 					   file.currentSector  = (file.currentCluster -  3) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster)
015B2:  MOV     A7C,W4
015B4:  SUB     W4,#3,W5
015B6:  MOV     A7E,W4
015B8:  SUBB    W4,#0,W6
015BA:  MOV.B   E9B,W0L
015BC:  MOV.B   W0L,W2L
015BE:  CLR.B   5
015C0:  MOV     #0,W3
015C2:  MOV     W5,W0
015C4:  MOV     W6,W1
015C6:  CALL    1268
*
015CA:  MOV     W0,W5
015CC:  MOV     W1,W6
015CE:  MOV     W5,W0
015D0:  ADD     EA0,W0
015D2:  MOV     W0,A80
015D4:  MOV     EA2,W4
015D6:  ADDC    W6,W4,W0
015D8:  MOV     W0,A82
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 7) + sect_reserv;						//sector en la FAT donde marcar el cluster usado
015DA:  MOV     #7,W4
015DC:  MOV     A7C,W5
015DE:  MOV     A7E,W6
015E0:  INC     W4,W4
015E2:  DEC     W4,W4
015E4:  BRA     Z,15EC
015E6:  LSR     W6,W6
015E8:  RRC     W5,W5
015EA:  BRA     15E2
015EC:  MOV     W5,W0
015EE:  ADD     EAC,W0
015F0:  MOV     W0,A86
015F2:  ADDC    W6,#0,W0
015F4:  MOV     W0,A88
.................... 					   }
.................... 					   file.EntryFile[file.offsetEntry + 27] = make8(file.currentCluster, 1); 					//1er cluster del archivo
015F6:  MOV     C8E,W4
015F8:  ADD     W4,#1B,W5
015FA:  MOV     #A8E,W4
015FC:  ADD     W5,W4,W6
015FE:  MOV.B   A7D,W0L
01600:  MOV.B   W0L,[W6]
.................... 					   file.EntryFile[file.offsetEntry + 26] = make8(file.currentCluster, 0);
01602:  MOV     C8E,W4
01604:  ADD     W4,#1A,W5
01606:  MOV     #A8E,W4
01608:  ADD     W5,W4,W6
0160A:  MOV.B   A7C,W0L
0160C:  MOV.B   W0L,[W6]
.................... 					   file.EntryFile[file.offsetEntry + 21] = make8(file.currentCluster, 3);
0160E:  MOV     C8E,W4
01610:  ADD     W4,#15,W5
01612:  MOV     #A8E,W4
01614:  ADD     W5,W4,W6
01616:  MOV.B   A7F,W0L
01618:  MOV.B   W0L,[W6]
.................... 					   file.EntryFile[file.offsetEntry + 20] = make8(file.currentCluster, 2);
0161A:  MOV     C8E,W4
0161C:  ADD     W4,#14,W5
0161E:  MOV     #A8E,W4
01620:  ADD     W5,W4,W6
01622:  MOV.B   A7E,W0L
01624:  MOV.B   W0L,[W6]
.................... 					   file.size = 0;																			//Inicialmente el tama�o es cero
01626:  CLR     C90
01628:  CLR     C92
.................... 
.................... 					   if(FATType==16){
0162A:  MOV     E9A,W4
0162C:  CP.B    W4L,#10
0162E:  BRA     NZ,169A
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile);
01630:  PUSH    A8A
01632:  POP     133A
01634:  PUSH    A8C
01636:  POP     133C
01638:  MOV     #A8E,W4
0163A:  MOV     W4,133E
0163C:  CALL    1298
.................... 						sd_read_block (file.sectorAtFAT, sector_fat16);
*
01640:  PUSH    A86
01642:  POP     1346
01644:  PUSH    A88
01646:  POP     1348
01648:  MOV     #10AE,W4
0164A:  MOV     W4,134A
0164C:  CALL    AD2
.................... 						sector_fat16[file.currentCluster % MAX_ENTRIES_SECTOR_FAT16] = ENDFILE16;				//marco el cluster como usado
*
01650:  MOV     A7C,W5
01652:  AND     #FF,W5
01654:  CLR     W6
01656:  MOV     #1,W4
01658:  MOV     W5,W0
0165A:  MOV     W6,W1
0165C:  INC     W4,W4
0165E:  DEC     W4,W4
01660:  BRA     Z,1668
01662:  SL      W0,W0
01664:  RLC     W1,W1
01666:  BRA     165E
01668:  MOV     #10AE,W4
0166A:  ADD     W0,W4,W5
0166C:  SETM.B  [W5]
0166E:  MOV.B   #FF,W0L
01670:  MOV.B   W0L,[W5+#1]
.................... 						sd_write_block( file.sectorAtFAT, sector_fat16);
01672:  PUSH    A86
01674:  POP     133A
01676:  PUSH    A88
01678:  POP     133C
0167A:  MOV     #10AE,W4
0167C:  MOV     W4,133E
0167E:  CALL    1298
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat16);   //FAT2					//�Ojo! la cosa puede ser mas complicada...
*
01682:  MOV     A86,W0
01684:  ADD     EA4,W0
01686:  MOV     W0,W5
01688:  MOV     A88,W0
0168A:  ADDC    EA6,W0
0168C:  MOV     W0,W6
0168E:  MOV     W5,133A
01690:  MOV     W6,133C
01692:  MOV     #10AE,W4
01694:  MOV     W4,133E
01696:  CALL    1298
.................... 						}
.................... 					   if(FATType==32){
*
0169A:  MOV     E9A,W4
0169C:  XOR.B   #20,W4L
0169E:  BRA     NZ,1712
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile);
016A0:  PUSH    A8A
016A2:  POP     133A
016A4:  PUSH    A8C
016A6:  POP     133C
016A8:  MOV     #A8E,W4
016AA:  MOV     W4,133E
016AC:  CALL    1298
.................... 						sd_read_block (file.sectorAtFAT,sector_fat32);
*
016B0:  PUSH    A86
016B2:  POP     1346
016B4:  PUSH    A88
016B6:  POP     1348
016B8:  MOV     #EAE,W4
016BA:  MOV     W4,134A
016BC:  CALL    AD2
.................... 						sector_fat32[file.currentCluster % MAX_ENTRIES_SECTOR_FAT32] = ENDFILE32;				//marco el cluster como usado
*
016C0:  MOV     A7C,W5
016C2:  AND     #7F,W5
016C4:  CLR     W6
016C6:  MOV     #2,W4
016C8:  MOV     W5,W0
016CA:  MOV     W6,W1
016CC:  INC     W4,W4
016CE:  DEC     W4,W4
016D0:  BRA     Z,16D8
016D2:  SL      W0,W0
016D4:  RLC     W1,W1
016D6:  BRA     16CE
016D8:  MOV     #EAE,W4
016DA:  ADD     W0,W4,W5
016DC:  SETM.B  [W5]
016DE:  MOV.B   #FF,W0L
016E0:  MOV.B   W0L,[W5+#1]
016E2:  MOV.B   #FF,W0L
016E4:  MOV.B   W0L,[W5+#2]
016E6:  MOV.B   #F,W0L
016E8:  MOV.B   W0L,[W5+#3]
.................... 						sd_write_block( file.sectorAtFAT, sector_fat32);
016EA:  PUSH    A86
016EC:  POP     133A
016EE:  PUSH    A88
016F0:  POP     133C
016F2:  MOV     #EAE,W4
016F4:  MOV     W4,133E
016F6:  CALL    1298
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat32);   //FAT2					//�Ojo! la cosa puede ser mas complicada...
*
016FA:  MOV     A86,W0
016FC:  ADD     EA4,W0
016FE:  MOV     W0,W5
01700:  MOV     A88,W0
01702:  ADDC    EA6,W0
01704:  MOV     W0,W6
01706:  MOV     W5,133A
01708:  MOV     W6,133C
0170A:  MOV     #EAE,W4
0170C:  MOV     W4,133E
0170E:  CALL    1298
.................... 						}
.................... 					   FicheroIncializado = 1;
*
01712:  MOV.B   #1,W0L
01714:  MOV.B   W0L,12EE
.................... 					   return FicheroIncializado;
01716:  MOV.B   12EE,W0L
01718:  MOV.B   W0L,0
0171A:  BRA     1736
.................... 					   }
0171C:  MOV     #20,W4
0171E:  MOV     12F4,W3
01720:  ADD     W3,W4,W0
01722:  MOV     W0,12F4
01724:  GOTO    1424
.................... 
.................... 		}//j
*
01728:  INC     12F0
0172A:  BTSC.B  42.1
0172C:  INC     12F2
0172E:  GOTO    1400
....................    }//i
....................    return FicheroIncializado;
*
01732:  MOV.B   12EE,W0L
01734:  MOV.B   W0L,0
01736:  MOV     [--W15],W6
01738:  MOV     [--W15],W5
0173A:  RETURN  
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart){
*
010BE:  MOV     W5,[W15++]
010C0:  MOV     W6,[W15++]
....................    unsigned int32 cluster;
....................    unsigned int32 _sector;   //recorrer sectores
....................    unsigned int32 bytes;     //recorrer bytes en cada sector
.................... 
....................    cluster =  clusterStart;
010C2:  PUSH    1336
010C4:  POP     133A
010C6:  PUSH    1338
010C8:  POP     133C
....................    if(FATType==16)
010CA:  MOV     E9A,W4
010CC:  CP.B    W4L,#10
010CE:  BRA     NZ,10EC
....................    _sector = (clusterStart >> 2) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante
010D0:  MOV     #2,W4
010D2:  MOV     1336,W5
010D4:  MOV     1338,W6
010D6:  INC     W4,W4
010D8:  DEC     W4,W4
010DA:  BRA     Z,10E2
010DC:  LSR     W6,W6
010DE:  RRC     W5,W5
010E0:  BRA     10D8
010E2:  MOV     W5,W0
010E4:  ADD     E9C,W0
010E6:  MOV     W0,133E
010E8:  ADDC    W6,#0,W0
010EA:  MOV     W0,1340
....................    if(FATType==32)
010EC:  MOV     E9A,W4
010EE:  XOR.B   #20,W4L
010F0:  BRA     NZ,110E
....................    _sector = (clusterStart >> 3) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante
010F2:  MOV     #3,W4
010F4:  MOV     1336,W5
010F6:  MOV     1338,W6
010F8:  INC     W4,W4
010FA:  DEC     W4,W4
010FC:  BRA     Z,1104
010FE:  LSR     W6,W6
01100:  RRC     W5,W5
01102:  BRA     10FA
01104:  MOV     W5,W0
01106:  ADD     E9C,W0
01108:  MOV     W0,133E
0110A:  ADDC    W6,#0,W0
0110C:  MOV     W0,1340
....................    bytes = (clusterStart % ((FATType==16) ? MAX_ENTRIES_SECTOR_FAT16 : MAX_ENTRIES_SECTOR_FAT32));
0110E:  MOV     E9A,W4
01110:  CP.B    W4L,#10
01112:  BRA     NZ,111C
01114:  MOV     #100,W0
01116:  MOV     #0,W1
01118:  GOTO    1120
*
0111C:  MOV     #80,W0
0111E:  MOV     #0,W1
01120:  BSET.B  43.0
01122:  MOV     W0,W2
01124:  MOV     W1,W3
01126:  MOV     1336,W0
01128:  MOV     1338,W1
0112A:  CALL    106A
*
0112E:  MOV     W0,1342
01130:  MOV     W1,1344
.................... 
....................    if(FATType==32){
01132:  MOV     E9A,W4
01134:  XOR.B   #20,W4L
01136:  BRA     NZ,11C6
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT
01138:  MOV     1340,W4
0113A:  CP      W4,#0
0113C:  BRA     GTU,11C2
0113E:  BRA     NC,1148
01140:  MOV     133E,W0
01142:  MOV     E9E,W4
01144:  CP      W4,W0
01146:  BRA     LEU,11C2
.................... 		  sd_read_block(_sector,sector_fat32); 							//leemos el sector
01148:  PUSH    133E
0114A:  POP     1346
0114C:  PUSH    1340
0114E:  POP     1348
01150:  MOV     #EAE,W4
01152:  MOV     W4,134A
01154:  CALL    AD2
....................     					      for(; bytes < MAX_ENTRIES_SECTOR_FAT32; bytes++){ //recorremos el sector para buscar un puntero a cluster libre
*
01158:  MOV     1344,W4
0115A:  CP      W4,#0
0115C:  BRA     GTU,11B4
0115E:  BRA     NC,1168
01160:  MOV     1342,W4
01162:  MOV     #80,W3
01164:  CP      W3,W4
01166:  BRA     LEU,11B4
.................... 					         if(sector_fat32[bytes]== 0){
01168:  MOV     #2,W4
0116A:  MOV     1342,W0
0116C:  MOV     1344,W1
0116E:  INC     W4,W4
01170:  DEC     W4,W4
01172:  BRA     Z,117A
01174:  SL      W0,W0
01176:  RLC     W1,W1
01178:  BRA     1170
0117A:  MOV     #EAE,W4
0117C:  ADD     W0,W4,W0
0117E:  MOV     #A,W4
01180:  MOV     [W0++],[W4++]
01182:  MOV     [W0++],[W4++]
01184:  CP0     W5
01186:  BRA     NZ,11A4
01188:  CP0     W6
0118A:  BRA     NZ,11A4
.................... 					            if(cluster < 3)               continue;  	//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando
0118C:  MOV     133C,W4
0118E:  CP      W4,#0
01190:  BRA     GTU,119E
01192:  BRA     NC,119A
01194:  MOV     133A,W4
01196:  CP      W4,#3
01198:  BRA     C,119E
0119A:  GOTO    11AA
.................... 					            return cluster;
*
0119E:  MOV     133A,W0
011A0:  MOV     133C,W1
011A2:  BRA     1262
.................... 					         }//fin if
.................... 					         cluster++;
011A4:  INC     133A
011A6:  BTSC.B  42.1
011A8:  INC     133C
011AA:  INC     1342
011AC:  BTSC.B  42.1
011AE:  INC     1344
011B0:  GOTO    1158
.................... 					      }//fin for de recorrer bytes dentro de un sector
.................... 	      bytes = 0;
*
011B4:  CLR     1342
011B6:  CLR     1344
011B8:  INC     133E
011BA:  BTSC.B  42.1
011BC:  INC     1340
011BE:  GOTO    1138
.................... 	   }//fin for de recorrer sectores
....................    }else
*
011C2:  GOTO    124E
....................     if(FATType==16){
*
011C6:  MOV     E9A,W4
011C8:  CP.B    W4L,#10
011CA:  BRA     NZ,124E
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT
011CC:  MOV     1340,W4
011CE:  CP      W4,#0
011D0:  BRA     GTU,124E
011D2:  BRA     NC,11DC
011D4:  MOV     133E,W0
011D6:  MOV     E9E,W4
011D8:  CP      W4,W0
011DA:  BRA     LEU,124E
.................... 		  sd_read_block(_sector,sector_fat16); 							//leemos el sector
011DC:  PUSH    133E
011DE:  POP     1346
011E0:  PUSH    1340
011E2:  POP     1348
011E4:  MOV     #10AE,W4
011E6:  MOV     W4,134A
011E8:  CALL    AD2
.................... 
.................... 					      for(; bytes < MAX_ENTRIES_SECTOR_FAT16; bytes++){ 	//recorremos el sector para buscar un puntero a cluster libre
*
011EC:  MOV     1344,W4
011EE:  CP      W4,#0
011F0:  BRA     GTU,1240
011F2:  BRA     NC,11FC
011F4:  MOV     1342,W4
011F6:  MOV     #100,W3
011F8:  CP      W3,W4
011FA:  BRA     LEU,1240
.................... 					         if(sector_fat16[bytes]== 0){
011FC:  MOV     #1,W4
011FE:  MOV     1342,W0
01200:  MOV     1344,W1
01202:  INC     W4,W4
01204:  DEC     W4,W4
01206:  BRA     Z,120E
01208:  SL      W0,W0
0120A:  RLC     W1,W1
0120C:  BRA     1204
0120E:  MOV     #10AE,W4
01210:  ADD     W0,W4,W0
01212:  MOV     [W0],W5
01214:  CP0     W5
01216:  BRA     NZ,1230
.................... 					            if(cluster < 2)               continue;		//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando
01218:  MOV     133C,W4
0121A:  CP      W4,#0
0121C:  BRA     GTU,122A
0121E:  BRA     NC,1226
01220:  MOV     133A,W4
01222:  CP      W4,#2
01224:  BRA     C,122A
01226:  GOTO    1236
.................... 					            return cluster;
*
0122A:  MOV     133A,W0
0122C:  MOV     133C,W1
0122E:  BRA     1262
.................... 					         }//fin if
.................... 					         cluster++;
01230:  INC     133A
01232:  BTSC.B  42.1
01234:  INC     133C
01236:  INC     1342
01238:  BTSC.B  42.1
0123A:  INC     1344
0123C:  GOTO    11EC
.................... 					      }//fin for de recorrer bytes dentro de un sector
.................... 	      bytes = 0;
*
01240:  CLR     1342
01242:  CLR     1344
01244:  INC     133E
01246:  BTSC.B  42.1
01248:  INC     1340
0124A:  GOTO    11CC
.................... 	   }//fin for de recorrer sectores
.................... 	}
....................    return ((FATType==16)?ENDFILE16:ENDFILE32);
*
0124E:  MOV     E9A,W4
01250:  CP.B    W4L,#10
01252:  BRA     NZ,125C
01254:  MOV     #FFFF,W0
01256:  MOV     #0,W1
01258:  GOTO    1260
*
0125C:  MOV     #FFFF,W0
0125E:  MOV     #FFF,W1
01260:  MOV.D   W0,W0
01262:  MOV     [--W15],W6
01264:  MOV     [--W15],W5
01266:  RETURN  
.................... }//fin encontrarCluster
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... void escribe_datos_en_fichero(){
*
01B76:  MOV     W5,[W15++]
01B78:  MOV     W6,[W15++]
01B7A:  MOV     W7,[W15++]
....................    unsigned int32 relSector;
....................    unsigned int32 nextCluster;
....................    unsigned int32  oldCluster;
....................    unsigned int16 _hour, date;
.................... 
.................... 	sd_write_block(file.currentSector, dt);
01B7C:  PUSH    A80
01B7E:  POP     133A
01B80:  PUSH    A82
01B82:  POP     133C
01B84:  MOV     #878,W4
01B86:  MOV     W4,133E
01B88:  CALL    1298
.................... 
.................... 
.................... 
.................... 
.................... 		file.currentSector++;																					//actualizar las FATs
*
01B8C:  INC     0A80
01B8E:  BTSC.B  42.1
01B90:  INC     0A82
.................... 		if(FATType==16)
01B92:  MOV     E9A,W4
01B94:  CP.B    W4L,#10
01B96:  BRA     NZ,1BC8
.................... 	    relSector= file.currentSector - ((file.currentCluster -  2) * sect_x_cluster + sect_ini_datos);
01B98:  MOV     A7C,W4
01B9A:  SUB     W4,#2,W5
01B9C:  MOV     A7E,W4
01B9E:  SUBB    W4,#0,W6
01BA0:  MOV.B   E9B,W0L
01BA2:  MOV.B   W0L,W2L
01BA4:  CLR.B   5
01BA6:  MOV     #0,W3
01BA8:  MOV     W5,W0
01BAA:  MOV     W6,W1
01BAC:  CALL    1268
*
01BB0:  MOV     W0,W5
01BB2:  MOV     W1,W6
01BB4:  MOV     W5,W0
01BB6:  ADD     EA0,W0
01BB8:  MOV     EA2,W4
01BBA:  ADDC    W6,W4,W1
01BBC:  MOV     A80,W4
01BBE:  SUB     W4,W0,W0
01BC0:  MOV     W0,12F0
01BC2:  MOV     A82,W4
01BC4:  SUBB    W4,W1,W0
01BC6:  MOV     W0,12F2
.................... 		if(FATType==32)
01BC8:  MOV     E9A,W4
01BCA:  XOR.B   #20,W4L
01BCC:  BRA     NZ,1BFE
.................... 	    relSector= file.currentSector - ((file.currentCluster -  3) * sect_x_cluster + sect_ini_datos);
01BCE:  MOV     A7C,W4
01BD0:  SUB     W4,#3,W5
01BD2:  MOV     A7E,W4
01BD4:  SUBB    W4,#0,W6
01BD6:  MOV.B   E9B,W0L
01BD8:  MOV.B   W0L,W2L
01BDA:  CLR.B   5
01BDC:  MOV     #0,W3
01BDE:  MOV     W5,W0
01BE0:  MOV     W6,W1
01BE2:  CALL    1268
*
01BE6:  MOV     W0,W5
01BE8:  MOV     W1,W6
01BEA:  MOV     W5,W0
01BEC:  ADD     EA0,W0
01BEE:  MOV     EA2,W4
01BF0:  ADDC    W6,W4,W1
01BF2:  MOV     A80,W4
01BF4:  SUB     W4,W0,W0
01BF6:  MOV     W0,12F0
01BF8:  MOV     A82,W4
01BFA:  SUBB    W4,W1,W0
01BFC:  MOV     W0,12F2
.................... 
.................... 	    if((relSector % sect_x_cluster) == 0){   											//�el siguiente sector est� en cluster nuevo?
01BFE:  BSET.B  43.0
01C00:  MOV.B   E9B,W0L
01C02:  MOV.B   W0L,W2L
01C04:  CLR.B   5
01C06:  MOV     #0,W3
01C08:  MOV     12F0,W0
01C0A:  MOV     12F2,W1
01C0C:  CALL    106A
*
01C10:  MOV     W0,W5
01C12:  MOV     W1,W6
01C14:  CP0     W5
01C16:  BRA     NZ,1C98
01C18:  CP0     W6
01C1A:  BRA     NZ,1C98
.................... 	      oldCluster = 	file.currentCluster;
01C1C:  PUSH    A7C
01C1E:  POP     12F8
01C20:  PUSH    A7E
01C22:  POP     12FA
.................... 	      nextCluster = encontrarCluster(oldCluster);   									//siguiente cluster
01C24:  PUSH    12F8
01C26:  POP     1336
01C28:  PUSH    12FA
01C2A:  POP     1338
01C2C:  CALL    10BE
*
01C30:  MOV     W0,12F4
01C32:  MOV     W1,12F6
.................... 	      //escribirCluster(oldCluster, nextCluster);  										//marcar actual cluster para que apunte al siguiente
.................... 	      file.currentCluster = nextCluster;
01C34:  PUSH    12F4
01C36:  POP     A7C
01C38:  PUSH    12F6
01C3A:  POP     A7E
.................... 		  if(FATType==16)
01C3C:  MOV     E9A,W4
01C3E:  CP.B    W4L,#10
01C40:  BRA     NZ,1C6A
.................... 	      file.currentSector = (nextCluster - 2) * sect_x_cluster + sect_ini_datos;
01C42:  MOV     12F4,W4
01C44:  SUB     W4,#2,W5
01C46:  MOV     12F6,W4
01C48:  SUBB    W4,#0,W6
01C4A:  MOV.B   E9B,W0L
01C4C:  MOV.B   W0L,W2L
01C4E:  CLR.B   5
01C50:  MOV     #0,W3
01C52:  MOV     W5,W0
01C54:  MOV     W6,W1
01C56:  CALL    1268
*
01C5A:  MOV     W0,W5
01C5C:  MOV     W1,W6
01C5E:  MOV     W5,W0
01C60:  ADD     EA0,W0
01C62:  MOV     W0,A80
01C64:  MOV     EA2,W4
01C66:  ADDC    W6,W4,W0
01C68:  MOV     W0,A82
.................... 		  if(FATType==32)
01C6A:  MOV     E9A,W4
01C6C:  XOR.B   #20,W4L
01C6E:  BRA     NZ,1C98
.................... 	      file.currentSector = (nextCluster - 3) * sect_x_cluster + sect_ini_datos;
01C70:  MOV     12F4,W4
01C72:  SUB     W4,#3,W5
01C74:  MOV     12F6,W4
01C76:  SUBB    W4,#0,W6
01C78:  MOV.B   E9B,W0L
01C7A:  MOV.B   W0L,W2L
01C7C:  CLR.B   5
01C7E:  MOV     #0,W3
01C80:  MOV     W5,W0
01C82:  MOV     W6,W1
01C84:  CALL    1268
*
01C88:  MOV     W0,W5
01C8A:  MOV     W1,W6
01C8C:  MOV     W5,W0
01C8E:  ADD     EA0,W0
01C90:  MOV     W0,A80
01C92:  MOV     EA2,W4
01C94:  ADDC    W6,W4,W0
01C96:  MOV     W0,A82
.................... 	   }
.................... 
.................... 	   //actualizar el tama�o del fichero y fechas
.................... 	   file.size += 512;
01C98:  MOV     #200,W4
01C9A:  MOV     C90,W3
01C9C:  ADD     W3,W4,W0
01C9E:  MOV     W0,C90
01CA0:  MOV     C92,W4
01CA2:  ADDC    W4,#0,W0
01CA4:  MOV     W0,C92
.................... 	   file.EntryFile[file.offsetEntry + 28] = make8(file.size, 0);   //tama�o
01CA6:  MOV     C8E,W4
01CA8:  ADD     W4,#1C,W5
01CAA:  MOV     #A8E,W4
01CAC:  ADD     W5,W4,W6
01CAE:  MOV.B   C90,W0L
01CB0:  MOV.B   W0L,[W6]
.................... 	   file.EntryFile[file.offsetEntry + 29] = make8(file.size, 1);
01CB2:  MOV     C8E,W4
01CB4:  ADD     W4,#1D,W5
01CB6:  MOV     #A8E,W4
01CB8:  ADD     W5,W4,W6
01CBA:  MOV.B   C91,W0L
01CBC:  MOV.B   W0L,[W6]
.................... 	   file.EntryFile[file.offsetEntry + 30] = make8(file.size, 2);
01CBE:  MOV     C8E,W4
01CC0:  ADD     W4,#1E,W5
01CC2:  MOV     #A8E,W4
01CC4:  ADD     W5,W4,W6
01CC6:  MOV.B   C92,W0L
01CC8:  MOV.B   W0L,[W6]
.................... 	   file.EntryFile[file.offsetEntry + 31] = make8(file.size, 3);
01CCA:  MOV     C8E,W4
01CCC:  ADD     W4,#1F,W5
01CCE:  MOV     #A8E,W4
01CD0:  ADD     W5,W4,W6
01CD2:  MOV.B   C93,W0L
01CD4:  MOV.B   W0L,[W6]
.................... 	   //ActualizaReloj();
.................... 	   _hour = getHour();
01CD6:  MOV.B   12B3,W0L
01CD8:  MOV.B   W0L,W5L
01CDA:  CLR.B   B
01CDC:  SL      W5,#B,W5
01CDE:  MOV.B   12B4,W0L
01CE0:  MOV.B   W0L,C
01CE2:  CLR.B   D
01CE4:  SL      W6,#5,W0
01CE6:  ADD     W0,W5,W5
01CE8:  MOV.B   12B5,W0L
01CEA:  CLR.B   1
01CEC:  LSR     W0,#1,W0
01CEE:  ADD     W0,W5,W0
01CF0:  MOV     W0,12FC
.................... 	   date = getDate();
01CF2:  MOV     12AE,W4
01CF4:  MOV     #7BC,W3
01CF6:  SUB     W4,W3,W5
01CF8:  SL      W5,#9,W5
01CFA:  MOV.B   12B1,W0L
01CFC:  MOV.B   W0L,W6L
01CFE:  CLR.B   D
01D00:  SL      W6,#5,W0
01D02:  ADD     W0,W5,W5
01D04:  MOV.B   12B2,W0L
01D06:  CLR.B   1
01D08:  ADD     W0,W5,W0
01D0A:  MOV     W0,12FE
.................... 	   file.EntryFile[file.offsetEntry + 24] = make8(date, 0);       //fecha modif
01D0C:  MOV     C8E,W4
01D0E:  ADD     W4,#18,W5
01D10:  MOV     #A8E,W4
01D12:  ADD     W5,W4,W6
01D14:  MOV.B   12FE,W0L
01D16:  MOV.B   W0L,[W6]
.................... 	   file.EntryFile[file.offsetEntry + 25] = make8(date, 1);
01D18:  MOV     C8E,W4
01D1A:  ADD     W4,#19,W5
01D1C:  MOV     #A8E,W4
01D1E:  ADD     W5,W4,W6
01D20:  MOV.B   12FF,W0L
01D22:  MOV.B   W0L,[W6]
.................... 	   file.EntryFile[file.offsetEntry + 22] = make8(_hour, 0);      //hora modif
01D24:  MOV     C8E,W4
01D26:  ADD     W4,#16,W5
01D28:  MOV     #A8E,W4
01D2A:  ADD     W5,W4,W6
01D2C:  MOV.B   12FC,W0L
01D2E:  MOV.B   W0L,[W6]
.................... 	   file.EntryFile[file.offsetEntry + 23] = make8(_hour, 1);
01D30:  MOV     C8E,W4
01D32:  ADD     W4,#17,W5
01D34:  MOV     #A8E,W4
01D36:  ADD     W5,W4,W6
01D38:  MOV.B   12FD,W0L
01D3A:  MOV.B   W0L,[W6]
.................... 	   file.EntryFile[file.offsetEntry + 18] = file.EntryFile[file.offsetEntry + 24];   //fecha �ltimo acceso
01D3C:  MOV     C8E,W4
01D3E:  ADD     W4,#12,W5
01D40:  MOV     #A8E,W4
01D42:  ADD     W5,W4,W6
01D44:  MOV     C8E,W4
01D46:  ADD     W4,#18,W7
01D48:  MOV     #A8E,W4
01D4A:  ADD     W7,W4,W0
01D4C:  MOV.B   [W0],[W6]
.................... 	   file.EntryFile[file.offsetEntry + 19] = file.EntryFile[file.offsetEntry + 25];
01D4E:  MOV     C8E,W4
01D50:  ADD     W4,#13,W5
01D52:  MOV     #A8E,W4
01D54:  ADD     W5,W4,W6
01D56:  MOV     C8E,W4
01D58:  ADD     W4,#19,W7
01D5A:  MOV     #A8E,W4
01D5C:  ADD     W7,W4,W0
01D5E:  MOV.B   [W0],[W6]
.................... 
.................... 	   sd_write_block(file.sectorEntryFile, file.EntryFile);  	// Actualiza root
01D60:  PUSH    A8A
01D62:  POP     133A
01D64:  PUSH    A8C
01D66:  POP     133C
01D68:  MOV     #A8E,W4
01D6A:  MOV     W4,133E
01D6C:  CALL    1298
*
01D70:  MOV     [--W15],W7
01D72:  MOV     [--W15],W6
01D74:  MOV     [--W15],W5
01D76:  RETURN  
.................... 
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void sd_init_global(){
....................   set_tris_b(0b1111111110011111);
*
0173C:  MOV     #FF9F,W4
0173E:  MOV     W4,2C8
....................   set_tris_c(0b1111111111011111);
01740:  MOV     #FFDF,W4
01742:  MOV     W4,2D0
....................   delay_ms(30);
01744:  MOV     #1E,W0
01746:  CALL    750
.................... 
....................   sd_init();	// Inicializa micro SD
*
0174A:  CALL    BA6
.................... 
....................   initFAT();	// Carga los parametros del sistema de ficheros
*
0174E:  CALL    DE2
.................... 	inicializa_fichero();
*
01752:  CALL    13CC
*
01756:  RETURN  
.................... }
.................... 
.................... #include "sdcard.h"
.................... #bit  SPIRBF    = getenv("SFR:SPI1STAT").0
.................... #bit  SPITBF    = getenv("SFR:SPI1STAT").1
.................... #bit  SPIROV    = getenv("SFR:SPI1STAT").6
.................... #byte SPI1BUF   = getenv("SFR:SPI1BUF")
.................... #byte SPI1STAT  = getenv("SFR:SPI1STAT")
.................... #byte SPI1CON1  = getenv("SFR:SPI1CON1")
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define   CMD0              		0x40      //go to idle				//Commands
.................... #define   CMD1               		0x41      //initialization process
.................... #define   CMD8               		0x48      //verify interface
.................... #define   CMD17              		0x51      //read single block
.................... #define   CMD24              		0x58      //write single block
.................... #define   CMD55              		0x77      //escape for app specific command
.................... #define   CMD58              		0x7a      //read OCR
.................... #define   ACMD41             		0x69      //poll operation range
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define   R1_READY_STATE          	0x00      //sd ready				//Responses
.................... #define   R1_IDLE_STATE           	0x01      //card in idle state
.................... #define   R1_ILLEGAL_COMMAND      	0x04      //illegal command
.................... #define   DATA_START_BLOCK       	0xFE      //start token for read or write
.................... #define   DATA_RES_MASK          	0x1F      //mask for data response
.................... #define   DATA_RES_ACCEPTED      	0x05      //write accepted
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sdhc;
.................... extern unsigned int8 dt[512];            /// Buffer de escritura  en uSD
.................... unsigned int32 LBA0 = 0;
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... inline unsigned int8 xfer_spi(char envio){
....................    SPIROV = 0;
*
009F0:  BCLR.B  240.6
*
00A06:  BCLR.B  240.6
*
00A24:  BCLR.B  240.6
*
00A44:  BCLR.B  240.6
*
00A64:  BCLR.B  240.6
*
00A84:  BCLR.B  240.6
*
00A9C:  BCLR.B  240.6
*
00AB0:  BCLR.B  240.6
*
00B06:  BCLR.B  240.6
*
00B3A:  BCLR.B  240.6
*
00B58:  BCLR.B  240.6
*
00B6C:  BCLR.B  240.6
*
00B80:  BCLR.B  240.6
*
00BE2:  BCLR.B  240.6
*
00C3E:  BCLR.B  240.6
*
00C54:  BCLR.B  240.6
*
00C6A:  BCLR.B  240.6
*
00C80:  BCLR.B  240.6
*
00D1E:  BCLR.B  240.6
*
00D34:  BCLR.B  240.6
*
00D4A:  BCLR.B  240.6
*
00D60:  BCLR.B  240.6
*
012CE:  BCLR.B  240.6
*
012E4:  BCLR.B  240.6
*
0130E:  BCLR.B  240.6
*
0132A:  BCLR.B  240.6
*
0133E:  BCLR.B  240.6
*
01352:  BCLR.B  240.6
*
01372:  BCLR.B  240.6
*
01392:  BCLR.B  240.6
*
013A6:  BCLR.B  240.6
....................    SPI1BUF= envio;
*
009F2:  MOV.B   135A,W0L
009F4:  MOV.B   W0L,248
*
00A08:  MOV.B   135A,W0L
00A0A:  MOV.B   W0L,248
*
00A26:  MOV.B   135A,W0L
00A28:  MOV.B   W0L,248
*
00A46:  MOV.B   135A,W0L
00A48:  MOV.B   W0L,248
*
00A66:  MOV.B   135A,W0L
00A68:  MOV.B   W0L,248
*
00A86:  MOV.B   135A,W0L
00A88:  MOV.B   W0L,248
*
00A9E:  MOV.B   135A,W0L
00AA0:  MOV.B   W0L,248
*
00AB2:  MOV.B   135A,W0L
00AB4:  MOV.B   W0L,248
*
00B08:  MOV.B   135A,W0L
00B0A:  MOV.B   W0L,248
*
00B3C:  MOV.B   135A,W0L
00B3E:  MOV.B   W0L,248
*
00B5A:  MOV.B   135A,W0L
00B5C:  MOV.B   W0L,248
*
00B6E:  MOV.B   135A,W0L
00B70:  MOV.B   W0L,248
*
00B82:  MOV.B   135A,W0L
00B84:  MOV.B   W0L,248
*
00BE4:  MOV.B   135A,W0L
00BE6:  MOV.B   W0L,248
*
00C40:  MOV.B   135A,W0L
00C42:  MOV.B   W0L,248
*
00C56:  MOV.B   135A,W0L
00C58:  MOV.B   W0L,248
*
00C6C:  MOV.B   135A,W0L
00C6E:  MOV.B   W0L,248
*
00C82:  MOV.B   135A,W0L
00C84:  MOV.B   W0L,248
*
00D20:  MOV.B   135A,W0L
00D22:  MOV.B   W0L,248
*
00D36:  MOV.B   135A,W0L
00D38:  MOV.B   W0L,248
*
00D4C:  MOV.B   135A,W0L
00D4E:  MOV.B   W0L,248
*
00D62:  MOV.B   135A,W0L
00D64:  MOV.B   W0L,248
*
012D0:  MOV.B   135A,W0L
012D2:  MOV.B   W0L,248
*
012E6:  MOV.B   135A,W0L
012E8:  MOV.B   W0L,248
*
01310:  MOV.B   135A,W0L
01312:  MOV.B   W0L,248
*
0132C:  MOV.B   135A,W0L
0132E:  MOV.B   W0L,248
*
01340:  MOV.B   135A,W0L
01342:  MOV.B   W0L,248
*
01354:  MOV.B   135A,W0L
01356:  MOV.B   W0L,248
*
01374:  MOV.B   135A,W0L
01376:  MOV.B   W0L,248
*
01394:  MOV.B   135A,W0L
01396:  MOV.B   W0L,248
*
013A8:  MOV.B   135A,W0L
013AA:  MOV.B   W0L,248
....................    while( SPITBF);
*
009F6:  BTSC.B  240.1
009F8:  BRA     9F6
*
00A0C:  BTSC.B  240.1
00A0E:  BRA     A0C
*
00A2A:  BTSC.B  240.1
00A2C:  BRA     A2A
*
00A4A:  BTSC.B  240.1
00A4C:  BRA     A4A
*
00A6A:  BTSC.B  240.1
00A6C:  BRA     A6A
*
00A8A:  BTSC.B  240.1
00A8C:  BRA     A8A
*
00AA2:  BTSC.B  240.1
00AA4:  BRA     AA2
*
00AB6:  BTSC.B  240.1
00AB8:  BRA     AB6
*
00B0C:  BTSC.B  240.1
00B0E:  BRA     B0C
*
00B40:  BTSC.B  240.1
00B42:  BRA     B40
*
00B5E:  BTSC.B  240.1
00B60:  BRA     B5E
*
00B72:  BTSC.B  240.1
00B74:  BRA     B72
*
00B86:  BTSC.B  240.1
00B88:  BRA     B86
*
00BE8:  BTSC.B  240.1
00BEA:  BRA     BE8
*
00C44:  BTSC.B  240.1
00C46:  BRA     C44
*
00C5A:  BTSC.B  240.1
00C5C:  BRA     C5A
*
00C70:  BTSC.B  240.1
00C72:  BRA     C70
*
00C86:  BTSC.B  240.1
00C88:  BRA     C86
*
00D24:  BTSC.B  240.1
00D26:  BRA     D24
*
00D3A:  BTSC.B  240.1
00D3C:  BRA     D3A
*
00D50:  BTSC.B  240.1
00D52:  BRA     D50
*
00D66:  BTSC.B  240.1
00D68:  BRA     D66
*
012D4:  BTSC.B  240.1
012D6:  BRA     12D4
*
012EA:  BTSC.B  240.1
012EC:  BRA     12EA
*
01314:  BTSC.B  240.1
01316:  BRA     1314
*
01330:  BTSC.B  240.1
01332:  BRA     1330
*
01344:  BTSC.B  240.1
01346:  BRA     1344
*
01358:  BTSC.B  240.1
0135A:  BRA     1358
*
01378:  BTSC.B  240.1
0137A:  BRA     1378
*
01398:  BTSC.B  240.1
0139A:  BRA     1398
*
013AC:  BTSC.B  240.1
013AE:  BRA     13AC
....................    while(!SPIRBF);
*
009FA:  BTSS.B  240.0
009FC:  BRA     9FA
*
00A10:  BTSS.B  240.0
00A12:  BRA     A10
*
00A2E:  BTSS.B  240.0
00A30:  BRA     A2E
*
00A4E:  BTSS.B  240.0
00A50:  BRA     A4E
*
00A6E:  BTSS.B  240.0
00A70:  BRA     A6E
*
00A8E:  BTSS.B  240.0
00A90:  BRA     A8E
*
00AA6:  BTSS.B  240.0
00AA8:  BRA     AA6
*
00ABA:  BTSS.B  240.0
00ABC:  BRA     ABA
*
00B10:  BTSS.B  240.0
00B12:  BRA     B10
*
00B44:  BTSS.B  240.0
00B46:  BRA     B44
*
00B62:  BTSS.B  240.0
00B64:  BRA     B62
*
00B76:  BTSS.B  240.0
00B78:  BRA     B76
*
00B8A:  BTSS.B  240.0
00B8C:  BRA     B8A
*
00BEC:  BTSS.B  240.0
00BEE:  BRA     BEC
*
00C48:  BTSS.B  240.0
00C4A:  BRA     C48
*
00C5E:  BTSS.B  240.0
00C60:  BRA     C5E
*
00C74:  BTSS.B  240.0
00C76:  BRA     C74
*
00C8A:  BTSS.B  240.0
00C8C:  BRA     C8A
*
00D28:  BTSS.B  240.0
00D2A:  BRA     D28
*
00D3E:  BTSS.B  240.0
00D40:  BRA     D3E
*
00D54:  BTSS.B  240.0
00D56:  BRA     D54
*
00D6A:  BTSS.B  240.0
00D6C:  BRA     D6A
*
012D8:  BTSS.B  240.0
012DA:  BRA     12D8
*
012EE:  BTSS.B  240.0
012F0:  BRA     12EE
*
01318:  BTSS.B  240.0
0131A:  BRA     1318
*
01334:  BTSS.B  240.0
01336:  BRA     1334
*
01348:  BTSS.B  240.0
0134A:  BRA     1348
*
0135C:  BTSS.B  240.0
0135E:  BRA     135C
*
0137C:  BTSS.B  240.0
0137E:  BRA     137C
*
0139C:  BTSS.B  240.0
0139E:  BRA     139C
*
013B0:  BTSS.B  240.0
013B2:  BRA     13B0
....................    return SPI1BUF;
*
009FE:  MOV.B   248,W0L
00A00:  MOV.B   W0L,0
*
00A14:  MOV.B   248,W0L
00A16:  MOV.B   W0L,0
*
00A32:  MOV.B   248,W0L
00A34:  MOV.B   W0L,0
00A36:  MOV     [--W15],W5
*
00A52:  MOV.B   248,W0L
00A54:  MOV.B   W0L,0
00A56:  MOV     [--W15],W5
*
00A72:  MOV.B   248,W0L
00A74:  MOV.B   W0L,0
00A76:  MOV     [--W15],W5
*
00A92:  MOV.B   248,W0L
00A94:  MOV.B   W0L,0
00A96:  MOV     [--W15],W5
*
00AAA:  MOV.B   248,W0L
00AAC:  MOV.B   W0L,0
*
00ABE:  MOV.B   248,W0L
00AC0:  MOV.B   W0L,0
*
00B14:  MOV.B   248,W0L
00B16:  MOV.B   W0L,0
*
00B48:  MOV.B   248,W0L
00B4A:  MOV.B   W0L,0
00B4C:  MOV     [--W15],W5
*
00B66:  MOV.B   248,W0L
00B68:  MOV.B   W0L,0
*
00B7A:  MOV.B   248,W0L
00B7C:  MOV.B   W0L,0
*
00B8E:  MOV.B   248,W0L
00B90:  MOV.B   W0L,0
*
00BF0:  MOV.B   248,W0L
00BF2:  MOV.B   W0L,0
*
00C4C:  MOV.B   248,W0L
00C4E:  MOV.B   W0L,0
*
00C62:  MOV.B   248,W0L
00C64:  MOV.B   W0L,0
*
00C78:  MOV.B   248,W0L
00C7A:  MOV.B   W0L,0
*
00C8E:  MOV.B   248,W0L
00C90:  MOV.B   W0L,0
*
00D2C:  MOV.B   248,W0L
00D2E:  MOV.B   W0L,0
*
00D42:  MOV.B   248,W0L
00D44:  MOV.B   W0L,0
*
00D58:  MOV.B   248,W0L
00D5A:  MOV.B   W0L,0
*
00D6E:  MOV.B   248,W0L
00D70:  MOV.B   W0L,0
*
012DC:  MOV.B   248,W0L
012DE:  MOV.B   W0L,0
*
012F2:  MOV.B   248,W0L
012F4:  MOV.B   W0L,0
*
0131C:  MOV.B   248,W0L
0131E:  MOV.B   W0L,0
01320:  MOV     [--W15],W5
*
01338:  MOV.B   248,W0L
0133A:  MOV.B   W0L,0
*
0134C:  MOV.B   248,W0L
0134E:  MOV.B   W0L,0
*
01360:  MOV.B   248,W0L
01362:  MOV.B   W0L,0
*
01380:  MOV.B   248,W0L
01382:  MOV.B   W0L,0
*
013A0:  MOV.B   248,W0L
013A2:  MOV.B   W0L,0
*
013B4:  MOV.B   248,W0L
013B6:  MOV.B   W0L,0
.................... }//fin xfer_spi
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 Commnd(char befF, int32 SD_Adress, char befH){
*
009EC:  MOV     W5,[W15++]
....................    unsigned int8 iC1;
....................    xfer_spi(0xFF);
009EE:  SETM.B  135A
....................    xfer_spi(befF);
*
00A02:  MOV.B   1350,W0L
00A04:  MOV.B   W0L,135A
....................    xfer_spi(make8(SD_Adress, 3));
*
00A18:  MOV.B   1355,W0L
00A1A:  MOV.B   W0L,W5L
00A1C:  MOV     W5,[W15++]
00A1E:  PUSH    135A
00A20:  MOV.B   W5L,[W15-#2]
00A22:  POP     135A
....................    xfer_spi(make8(SD_Adress, 2));
*
00A38:  MOV.B   1354,W0L
00A3A:  MOV.B   W0L,A
00A3C:  MOV     W5,[W15++]
00A3E:  PUSH    135A
00A40:  MOV.B   W5L,[W15-#2]
00A42:  POP     135A
....................    xfer_spi(make8(SD_Adress, 1));
*
00A58:  MOV.B   1353,W0L
00A5A:  MOV.B   W0L,W5L
00A5C:  MOV     W5,[W15++]
00A5E:  PUSH    135A
00A60:  MOV.B   W5L,[W15-#2]
00A62:  POP     135A
....................    xfer_spi(make8(SD_Adress, 0));
*
00A78:  MOV.B   1352,W0L
00A7A:  MOV.B   W0L,A
00A7C:  MOV     W5,[W15++]
00A7E:  PUSH    135A
00A80:  MOV.B   W5L,[W15-#2]
00A82:  POP     135A
....................    xfer_spi(befH);
*
00A98:  MOV.B   1351,W0L
00A9A:  MOV.B   W0L,135A
....................     do{iC1 = xfer_spi(0xFF);
*
00AAE:  SETM.B  135A
*
00AC2:  MOV.B   W0L,1356
....................    }while(iC1 == 0xFF);
00AC4:  MOV     1356,W4
00AC6:  XOR.B   #FF,W4L
00AC8:  BRA     Z,AAE
....................    return iC1;
00ACA:  MOV.B   1356,W0L
00ACC:  MOV.B   W0L,0
00ACE:  MOV     [--W15],W5
00AD0:  RETURN  
.................... }//fin Commnd
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_init(){
*
00BA6:  MOV     W5,[W15++]
*
00BBA:  MOV.B   #1,W0L
00BBC:  MOV.B   W0L,12EE
00BBE:  CLR     1304
00BC0:  CLR     1306
....................  unsigned  int8 R[17]={0}, versionSD= 1, crc;
*
00BA8:  CLR     12F0
00BAA:  CLR     12F2
00BAC:  CLR     12F4
00BAE:  CLR     12F6
00BB0:  CLR     12F8
00BB2:  CLR     12FA
00BB4:  CLR     12FC
00BB6:  CLR     12FE
00BB8:  CLR.B   1300
....................  unsigned int16 iI;
....................  unsigned int32 arg=0;
.................... 
....................  setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_16);
*
00BC2:  BCLR.B  241.7
00BC4:  BCLR.B  240.6
00BC6:  MOV     #13D,W4
00BC8:  MOV     W4,242
00BCA:  BSET.B  241.7
.................... 
....................  memset(dt,0,512);
00BCC:  MOV     #878,W1
00BCE:  MOV     #0,W2
00BD0:  REPEAT  #1FF
00BD2:  CLR.B   [W1++]
....................  // CMD0 - GO_IDLE_STATE  (R1)� � Card Reset  � � � � � � � � � � � � � � � � � � � � � � �
.................... 	do{	output_high(CS);   	// tarjeta deshabilitada
00BD4:  BCLR.B  2D0.5
00BD6:  BSET.B  2D4.5
.................... 		for (iI = 0; iI < 10; iI++)  	xfer_spi(0xFF);
00BD8:  CLR     1302
00BDA:  MOV     1302,W4
00BDC:  CP      W4,#A
00BDE:  BRA     C,BFA
00BE0:  SETM.B  135A
*
00BF4:  INC     1302
00BF6:  GOTO    BDA
.................... 		output_low(CS); 	// tarjeta habilitada
*
00BFA:  BCLR.B  2D0.5
00BFC:  BCLR.B  2D4.5
.................... 		R[0] = Commnd( CMD0 , 0x00000000 , 0x95); //go to idle
00BFE:  MOV.B   #40,W0L
00C00:  MOV.B   W0L,1350
00C02:  MOV.B   #95,W0L
00C04:  MOV.B   W0L,1351
00C06:  CLR     1352
00C08:  CLR     1354
00C0A:  CALL    9EC
*
00C0E:  MOV.B   W0L,12F0
.................... 	}while( R[0] != R1_IDLE_STATE);
00C10:  MOV     12F0,W4
00C12:  CP.B    W4L,#1
00C14:  BRA     NZ,BD4
....................   // CMD8 - SEND_IF_COND (R7)  � Send Interface Condition Command� � � � � � � � � � � � � �
....................   // Argument 00 - 00 - 01 (Voltage supplied = 2.7-3.6V) - AA (Check pattern)
....................   // Response: illegal command -> Version 1
....................   // Response: echo-back 	   -> Version 2
.................... 	R[0] = Commnd(CMD8, 0x000001AA, 0x87);
00C16:  MOV.B   #48,W0L
00C18:  MOV.B   W0L,1350
00C1A:  MOV.B   #87,W0L
00C1C:  MOV.B   W0L,1351
00C1E:  MOV     #1AA,W4
00C20:  MOV     W4,1352
00C22:  CLR     1354
00C24:  CALL    9EC
*
00C28:  MOV.B   W0L,12F0
....................     if(R[0]& R1_ILLEGAL_COMMAND){	  			versionSD = 1;
00C2A:  MOV.B   12F0,W0L
00C2C:  CLR.B   1
00C2E:  AND     W0,#4,W0
00C30:  CP0     W0
00C32:  BRA     Z,C3C
00C34:  MOV.B   #1,W0L
00C36:  MOV.B   W0L,12EE
....................    			}else{	R[1] = xfer_spi(0xFF);
00C38:  GOTO    CA8
*
00C3C:  SETM.B  135A
*
00C50:  MOV.B   W0L,12F1
.................... 					R[2] = xfer_spi(0xFF);
00C52:  SETM.B  135A
*
00C66:  MOV.B   W0L,12F2
.................... 					R[3] = xfer_spi(0xFF);
00C68:  SETM.B  135A
*
00C7C:  MOV.B   W0L,12F3
.................... 					R[4] = xfer_spi(0xFF);
00C7E:  SETM.B  135A
*
00C92:  MOV.B   W0L,12F4
.................... 				    if(R[4]!=0xAA){	output_high(CS); return 1; }		//error
00C94:  MOV     12F4,W4
00C96:  XOR.B   #AA,W4L
00C98:  BRA     Z,CA4
00C9A:  BCLR.B  2D0.5
00C9C:  BSET.B  2D4.5
00C9E:  MOV.B   #1,W0L
00CA0:  MOV.B   W0L,0
00CA2:  BRA     DDE
....................       											versionSD = 2;
00CA4:  MOV.B   #2,W0L
00CA6:  MOV.B   W0L,12EE
....................    			}
.................... 
....................   // ACMD41 - SD_SEND_OP_ COND (R1) � � Initialization Command   � � � � � � � � � � � � � �
....................   // If host supports SDHC or SDXC: HCS (Host Capacity Support) is set to 1 (arg= 0x40000000)
....................   // If host only support SDSC:     HCS (Host Capacity Support) is set to 0 (arg= 0)
....................    arg = (versionSD == 2) ? 0x40000000 : 0;
00CA8:  MOV     12EE,W4
00CAA:  CP.B    W4L,#2
00CAC:  BRA     NZ,CB6
00CAE:  MOV     #0,W0
00CB0:  MOV     #4000,W1
00CB2:  GOTO    CBA
*
00CB6:  MOV     #0,W0
00CB8:  MOV     #0,W1
00CBA:  MOV     W0,1304
00CBC:  MOV     W1,1306
....................    crc = (versionSD == 2) ? 0x77 : 0xFF;
00CBE:  MOV     12EE,W4
00CC0:  CP.B    W4L,#2
00CC2:  BRA     NZ,CCA
00CC4:  MOV.B   #77,W0L
00CC6:  GOTO    CCC
*
00CCA:  SETM.B  W0
00CCC:  MOV.B   W0L,12EF
.................... 
.................... 
....................    do{            Commnd(CMD55,    0, 0x65);	// El proceso puede llegar a durar hasta 1 segundo
00CCE:  MOV.B   #77,W0L
00CD0:  MOV.B   W0L,1350
00CD2:  MOV.B   #65,W0L
00CD4:  MOV.B   W0L,1351
00CD6:  CLR     1352
00CD8:  CLR     1354
00CDA:  CALL    9EC
....................            R[0] = Commnd(ACMD41, arg, crc);		// Application-Specific Command � APP_CMD (CMD55)
*
00CDE:  MOV.B   #69,W0L
00CE0:  MOV.B   W0L,1350
00CE2:  MOV.B   12EF,W0L
00CE4:  MOV.B   W0L,1351
00CE6:  PUSH    1304
00CE8:  POP     1352
00CEA:  PUSH    1306
00CEC:  POP     1354
00CEE:  CALL    9EC
*
00CF2:  MOV.B   W0L,12F0
.................... 		   delay_ms(4);
00CF4:  REPEAT  #1662
00CF6:  NOP     
00CF8:  REPEAT  #3FFF
00CFA:  NOP     
....................    }while(R[0] != R1_READY_STATE);
00CFC:  CP0.B   12F0
00CFE:  BRA     NZ,CCE
.................... 
....................   if(versionSD == 2){
00D00:  MOV     12EE,W4
00D02:  CP.B    W4L,#2
00D04:  BRA     NZ,D9A
.................... 
....................   // � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � �
....................   // CMD58 - READ_OCR (R3) � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � �
....................   // Bit 30 - Card Capacity Status bit: 	0 indicates that the card is SDSC.
....................   //										1 indicates that the card is SDHC or SDXC
.................... 	R[0] = Commnd(CMD58, 0x00000000, 0xFF);
00D06:  MOV.B   #7A,W0L
00D08:  MOV.B   W0L,1350
00D0A:  MOV.B   #FF,W0L
00D0C:  MOV.B   W0L,1351
00D0E:  CLR     1352
00D10:  CLR     1354
00D12:  CALL    9EC
*
00D16:  MOV.B   W0L,12F0
....................     if(R[0] == R1_READY_STATE){	R[1] = xfer_spi(0xFF);
00D18:  CP0.B   12F0
00D1A:  BRA     NZ,D90
00D1C:  SETM.B  135A
*
00D30:  MOV.B   W0L,12F1
.................... 								R[2] = xfer_spi(0xFF);
00D32:  SETM.B  135A
*
00D46:  MOV.B   W0L,12F2
.................... 								R[3] = xfer_spi(0xFF);
00D48:  SETM.B  135A
*
00D5C:  MOV.B   W0L,12F3
.................... 								R[4] = xfer_spi(0xFF);
00D5E:  SETM.B  135A
*
00D72:  MOV.B   W0L,12F4
.................... 								sdhc = ((R[1]& 0xC0) == 0xC0) ? 1 : 0;
00D74:  MOV.B   12F1,W0L
00D76:  CLR.B   1
00D78:  MOV.B   W0L,W5L
00D7A:  AND     #C0,W5
00D7C:  MOV     #C0,W4
00D7E:  CP      W4,W5
00D80:  BRA     NZ,D88
00D82:  MOV.B   #1,W0L
00D84:  GOTO    D8A
*
00D88:  CLR.B   W0
00D8A:  MOV.B   W0L,12B6
....................    			}else{				output_high(CS); return 1; }		//error
00D8C:  GOTO    D9A
*
00D90:  BCLR.B  2D0.5
00D92:  BSET.B  2D4.5
00D94:  MOV.B   #1,W0L
00D96:  MOV.B   W0L,0
00D98:  BRA     DDE
....................   // � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � �
.................... 
....................   }// versionSD == 2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
....................   setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_1);
00D9A:  BCLR.B  241.7
00D9C:  BCLR.B  240.6
00D9E:  MOV     #13F,W4
00DA0:  MOV     W4,242
00DA2:  BSET.B  241.7
.................... 
....................   // � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � �
.................... 	sd_read_block(0, dt);	//Lee el sector fisico 0 para obtener el LBA0
00DA4:  CLR     1346
00DA6:  CLR     1348
00DA8:  MOV     #878,W4
00DAA:  MOV     W4,134A
00DAC:  CALL    AD2
.................... 	if(dt[510]==0x55)
*
00DB0:  MOV     A76,W4
00DB2:  XOR.B   #55,W4L
00DB4:  BRA     NZ,DD8
.................... 	if(dt[511]==0xAA){ 		// Efectivamente parece que estoy en sct 0
00DB6:  MOV     A76,W4
00DB8:  LSR     W4,#8,W4
00DBA:  XOR.B   #AA,W4L
00DBC:  BRA     NZ,DD8
.................... 							// Tabla de particiones
.................... 								LBA0 = make32(dt[457],dt[456],dt[455],dt[454]);
00DBE:  MOV.B   A41,W0L
00DC0:  MOV.B   W0L,A7B
00DC2:  MOV.B   A40,W0L
00DC4:  MOV.B   W0L,A7A
00DC6:  MOV.B   A3F,W0L
00DC8:  MOV.B   W0L,A79
00DCA:  MOV.B   A3E,W0L
00DCC:  MOV.B   W0L,A78
.................... 								if(dt[0]==0xEB) // MBR
00DCE:  MOV     878,W4
00DD0:  XOR.B   #EB,W4L
00DD2:  BRA     NZ,DD8
....................  								LBA0 = 0;
00DD4:  CLR     A78
00DD6:  CLR     A7A
.................... 						  }//55AA
....................   // � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � �
.................... 
....................   output_high(CS);   									// tarjeta deshabilitada
00DD8:  BCLR.B  2D0.5
00DDA:  BSET.B  2D4.5
....................   return 0;
00DDC:  CLR.B   0
00DDE:  MOV     [--W15],W5
00DE0:  RETURN  
.................... }//char sd_init()- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr){
*
01298:  MOV     W5,[W15++]
....................    unsigned int16 iW;
.................... 
....................    if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores
0129A:  CP0.B   12B6
0129C:  BRA     NZ,12AC
0129E:  MOV     #9,W4
012A0:  INC     W4,W4
012A2:  DEC     W4,W4
012A4:  BRA     Z,12AC
012A6:  SL      133A
012A8:  RLC     133C
012AA:  BRA     12A2
....................    output_low(CS);
012AC:  BCLR.B  2D0.5
012AE:  BCLR.B  2D4.5
.................... 
.................... 		iW = Commnd(CMD24, address, 0xFF);
012B0:  MOV.B   #58,W0L
012B2:  MOV.B   W0L,1350
012B4:  MOV.B   #FF,W0L
012B6:  MOV.B   W0L,1351
012B8:  PUSH    133A
012BA:  POP     1352
012BC:  PUSH    133C
012BE:  POP     1354
012C0:  CALL    9EC
*
012C4:  MOV.B   W0L,1340
012C6:  CLR.B   1341
....................     if( iW == R1_READY_STATE){
012C8:  CP0     1340
012CA:  BRA     NZ,13C0
....................              								              		xfer_spi(0xFF);
012CC:  SETM.B  135A
....................                               									xfer_spi(DATA_START_BLOCK);   // Data start token
*
012E0:  MOV.B   #FE,W0L
012E2:  MOV.B   W0L,135A
....................                            			for(iW = 0; iW < 512; iW++)  xfer_spi(ptr[iW]);
*
012F6:  CLR     1340
012F8:  MOV     1340,W4
012FA:  MOV     #200,W3
012FC:  CP      W3,W4
012FE:  BRA     LEU,1328
01300:  MOV     1340,W0
01302:  ADD     133E,W0
01304:  MOV.B   [W0],W5L
01306:  MOV     W5,[W15++]
01308:  PUSH    135A
0130A:  MOV.B   W5L,[W15-#2]
0130C:  POP     135A
*
01322:  INC     1340
01324:  GOTO    12F8
....................                            							xfer_spi(0xFF);   // Dummy bytes
*
01328:  SETM.B  135A
....................                           							xfer_spi(0xFF);   // en lugar del CRC16
*
0133C:  SETM.B  135A
.................... 
....................                         do{       iW = xfer_spi(0xFF);
*
01350:  SETM.B  135A
*
01364:  MOV.B   W0L,1340
01366:  CLR.B   1341
....................                         }while( (iW & DATA_RES_MASK) != DATA_RES_ACCEPTED);
01368:  MOV     1340,W0
0136A:  AND     W0,#1F,W5
0136C:  CP      W5,#5
0136E:  BRA     NZ,1350
.................... 
....................                         do{       iW = xfer_spi(0xFF); delay_us(100);
01370:  SETM.B  135A
*
01384:  MOV.B   W0L,1340
01386:  CLR.B   1341
01388:  REPEAT  #226
0138A:  NOP     
....................                         }while(   iW == 0 );
0138C:  CP0     1340
0138E:  BRA     Z,1370
.................... 
.................... 						xfer_spi(0xFF);
01390:  SETM.B  135A
.................... 						xfer_spi(0xFF);
*
013A4:  SETM.B  135A
.................... 
....................    						output_high(CS);   return 0; //correcto
*
013B8:  BCLR.B  2D0.5
013BA:  BSET.B  2D4.5
013BC:  CLR.B   0
013BE:  BRA     13C8
.................... 						}
....................    						output_high(CS);   return 1; //error
013C0:  BCLR.B  2D0.5
013C2:  BSET.B  2D4.5
013C4:  MOV.B   #1,W0L
013C6:  MOV.B   W0L,0
013C8:  MOV     [--W15],W5
013CA:  RETURN  
.................... }//fin sd_write_block
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr){
*
00AD2:  MOV     W5,[W15++]
....................    unsigned int16 jR;
....................    unsigned int8  iR;
.................... 
....................     if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores
00AD4:  CP0.B   12B6
00AD6:  BRA     NZ,AE6
00AD8:  MOV     #9,W4
00ADA:  INC     W4,W4
00ADC:  DEC     W4,W4
00ADE:  BRA     Z,AE6
00AE0:  SL      1346
00AE2:  RLC     1348
00AE4:  BRA     ADC
....................     output_low(CS);
00AE6:  BCLR.B  2D0.5
00AE8:  BCLR.B  2D4.5
.................... 
....................        iR  = Commnd(CMD17, address, 0xFF);
00AEA:  MOV.B   #51,W0L
00AEC:  MOV.B   W0L,1350
00AEE:  MOV.B   #FF,W0L
00AF0:  MOV.B   W0L,1351
00AF2:  PUSH    1346
00AF4:  POP     1352
00AF6:  PUSH    1348
00AF8:  POP     1354
00AFA:  CALL    9EC
*
00AFE:  MOV.B   W0L,134C
....................     if(iR == R1_READY_STATE){
00B00:  CP0.B   134C
00B02:  BRA     NZ,B9A
.................... 								do{     iR  = xfer_spi(0xFF);
00B04:  SETM.B  135A
*
00B18:  MOV.B   W0L,134C
.................... 								}while( iR != DATA_START_BLOCK);
00B1A:  MOV     134C,W4
00B1C:  XOR.B   #FE,W4L
00B1E:  BRA     NZ,B04
.................... 
.................... 								if(iR == DATA_START_BLOCK){
00B20:  MOV     134C,W4
00B22:  XOR.B   #FE,W4L
00B24:  BRA     NZ,B92
.................... 								for(jR = 0; jR < 512; jR++)
00B26:  CLR     134E
00B28:  MOV     134E,W4
00B2A:  MOV     #200,W3
00B2C:  CP      W3,W4
00B2E:  BRA     LEU,B56
.................... 								         ptr[jR] = xfer_spi(0xFF);
00B30:  MOV     134E,W0
00B32:  ADD     134A,W0
00B34:  MOV     W0,W5
00B36:  MOV     W5,[W15++]
00B38:  SETM.B  135A
*
00B4E:  MOV.B   W0L,[W5]
00B50:  INC     134E
00B52:  GOTO    B28
.................... 								xfer_spi(0xFF);
*
00B56:  SETM.B  135A
.................... 								xfer_spi(0xFF);
*
00B6A:  SETM.B  135A
.................... 								xfer_spi(0xFF);
*
00B7E:  SETM.B  135A
....................   								}
.................... 
....................    							output_high(CS);      return 0;
*
00B92:  BCLR.B  2D0.5
00B94:  BSET.B  2D4.5
00B96:  CLR.B   0
00B98:  BRA     BA2
.................... 							}
.................... 							output_high(CS);      return 1;
00B9A:  BCLR.B  2D0.5
00B9C:  BSET.B  2D4.5
00B9E:  MOV.B   #1,W0L
00BA0:  MOV.B   W0L,0
00BA2:  MOV     [--W15],W5
00BA4:  RETURN  
.................... }//fin sd_read_block
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... char cadena[32];
.................... int jj;
.................... static int cont = 0;
.................... //Escritura en el fichero LATIDOS
.................... void escritura_sd(int ppm){
*
01D78:  MOV     W5,[W15++]
01D7A:  MOV     W6,[W15++]
.................... 
....................  sprintf(cadena,"%03d\n",ppm); //Escribe ppm en el archivo LATIDOS
01D7C:  MOV     #12B8,W4
01D7E:  MOV     W4,12DC
01D80:  MOV     12EE,W0
01D82:  MOV     #8003,W4
01D84:  CALL    18D8
*
01D88:  MOV.B   #A,W0L
01D8A:  CALL    18CA
....................  output_toggle(H1);
*
01D8E:  BCLR.B  2C9.6
01D90:  BTG.B   2CD.6
.................... 
....................  for(jj=0;jj<4;jj++)
01D92:  CLR     12D8
01D94:  MOV     12D8,W4
01D96:  CP      W4,#4
01D98:  BRA     GE,1DB4
....................  {
....................    dt[jj+(cont*4)] = cadena[jj];
01D9A:  MOV     12DA,W4
01D9C:  MUL.UU  W4,#4,W0
01D9E:  MOV     12D8,W4
01DA0:  ADD     W0,W4,W5
01DA2:  MOV     #878,W4
01DA4:  ADD     W5,W4,W6
01DA6:  MOV     #12B8,W4
01DA8:  MOV     12D8,W3
01DAA:  ADD     W3,W4,W0
01DAC:  MOV.B   [W0],[W6]
01DAE:  INC     12D8
01DB0:  GOTO    1D94
....................  }
.................... cont++;
*
01DB4:  INC     12DA
.................... escribe_datos_en_fichero();
01DB6:  CALL    1B76
*
01DBA:  MOV     [--W15],W6
01DBC:  MOV     [--W15],W5
01DBE:  RETURN  
.................... }
.................... 
.................... #include "BLUETOOTH.h"
.................... #ifndef Bluetooth_h
.................... #define Bluetooth_h
.................... #include "Header.h"
.................... #ifndef Header_h
.................... #define Header_h
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses HS
.................... #fuses PR
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock= 11059200)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON( pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define III            PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		   PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDO1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDI1 =     PIN_B7  //                    (43)
.................... #define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use rs232(UART1,baud=115200,STREAM=BT)
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void init_BT(void); //inits and enables uart isr
.................... void enviar_datos(unsigned int16 ppm);
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void init_BT(void)
.................... {
....................   	fprintf(BT,"$$$");	     delay_ms(500); // command mode
*
00760:  BTSC.B  223.1
00762:  BRA     760
00764:  MOV     #24,W4
00766:  MOV     W4,224
00768:  BTSC.B  223.1
0076A:  BRA     768
0076C:  MOV     #24,W4
0076E:  MOV     W4,224
00770:  BTSC.B  223.1
00772:  BRA     770
00774:  MOV     #24,W4
00776:  MOV     W4,224
00778:  MOV     #1F4,W0
0077A:  CALL    750
....................   	fprintf(BT,"SF,1\r");      delay_ms(500); // factory defaults
*
0077E:  MOV     #0,W1
00780:  MOV     W1,W0
00782:  CLR.B   1
00784:  CALL    200
*
00788:  INC     W1,W1
0078A:  BTSC.B  223.1
0078C:  BRA     78A
0078E:  MOV     W0,224
00790:  MOV     #4,W0
00792:  CPSGT   W1,W0
00794:  BRA     780
00796:  MOV     #1F4,W0
00798:  CALL    750
....................   	fprintf(BT,"SA,0\r");      delay_ms(500); // authentication 'Open'
*
0079C:  MOV     #0,W1
0079E:  MOV     W1,W0
007A0:  CLR.B   1
007A2:  CALL    212
*
007A6:  INC     W1,W1
007A8:  BTSC.B  223.1
007AA:  BRA     7A8
007AC:  MOV     W0,224
007AE:  MOV     #4,W0
007B0:  CPSGT   W1,W0
007B2:  BRA     79E
007B4:  MOV     #1F4,W0
007B6:  CALL    750
....................   	fprintf(BT,"R,1\r");       delay_ms(500); // Run device
*
007BA:  MOV     #0,W1
007BC:  MOV     W1,W0
007BE:  CLR.B   1
007C0:  CALL    224
*
007C4:  INC     W1,W1
007C6:  BTSC.B  223.1
007C8:  BRA     7C6
007CA:  MOV     W0,224
007CC:  MOV     #3,W0
007CE:  CPSGT   W1,W0
007D0:  BRA     7BC
007D2:  MOV     #1F4,W0
007D4:  CALL    750
*
007D8:  RETURN  
.................... 
.................... 
.................... }
.................... 
.................... void enviar_datos(unsigned int16 ppm)
.................... {
.................... 	COM:
.................... 	while(!input(COMM));
*
01B08:  BSET.B  2C1.1
01B0A:  NOP     
01B0C:  BTSS.B  2C3.1
01B0E:  BRA     1B08
....................     fprintf(BT,"$Representacion grafica,Funcion,datos 1\n");
01B10:  MOV     #0,W1
01B12:  MOV     W1,W0
01B14:  CLR.B   1
01B16:  CALL    236
*
01B1A:  INC     W1,W1
01B1C:  BTSC.B  223.1
01B1E:  BRA     1B1C
01B20:  MOV     W0,224
01B22:  MOV     #27,W0
01B24:  CPSGT   W1,W0
01B26:  BRA     1B12
....................     fprintf(BT,"&0,250,0,1,0\n"); //X
01B28:  MOV     #0,W1
01B2A:  MOV     W1,W0
01B2C:  CLR.B   1
01B2E:  CALL    26C
*
01B32:  INC     W1,W1
01B34:  BTSC.B  223.1
01B36:  BRA     1B34
01B38:  MOV     W0,224
01B3A:  MOV     #C,W0
01B3C:  CPSGT   W1,W0
01B3E:  BRA     1B2A
....................     fprintf(BT,"#0,250,0,1,0\n"); //Y
01B40:  MOV     #0,W1
01B42:  MOV     W1,W0
01B44:  CLR.B   1
01B46:  CALL    286
*
01B4A:  INC     W1,W1
01B4C:  BTSC.B  223.1
01B4E:  BRA     1B4C
01B50:  MOV     W0,224
01B52:  MOV     #C,W0
01B54:  CPSGT   W1,W0
01B56:  BRA     1B42
....................  		fprintf(BT, "%03d\n", ppm);
01B58:  MOV     12EE,W0
01B5A:  MOV     #8003,W4
01B5C:  CALL    1A08
*
01B60:  BTSC.B  223.1
01B62:  BRA     1B60
01B64:  MOV     #A,W4
01B66:  MOV     W4,224
.................... 		if(!input(COMM))
01B68:  BSET.B  2C1.1
01B6A:  NOP     
01B6C:  BTSC.B  2C3.1
01B6E:  BRA     1B74
.................... 		goto COM;
01B70:  GOTO    1B08
*
01B74:  RETURN  
.................... }
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... #include "BEEP.h"
.................... /**
....................  @file    BEEP.h
....................  @author  Julio Gomis-Tena
....................  @brief   Generate n "beeps" of variable frequency
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __BEEP_H
.................... #define __BEEP_H
.................... #include "Header.h"
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #pin_select OC2 = BUZZER
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void); //Inicializa las frecuencias de los beeps y la separación entre ellos
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP(unsigned int8); //Realiza n beeps
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void)		//4kHz -> T/2= 125us
.................... {
.................... 	setup_timer3(TMR_INTERNAL|TMR_DIV_BY_1, 737); // 5kHz. Frecuencia de los beeps
.................... 	set_compare_time(2, 0);
.................... 	setup_compare(2, COMPARE_OFF);
.................... 
.................... 		// (11059200/2)/256/432 = 50 Hz  <-> 100ms
.................... 	setup_timer4(TMR_INTERNAL|TMR_DIV_BY_8, 1843);
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 N_beep;
.................... 
.................... void BEEP(unsigned int8 n)
.................... {
.................... 	if(n<127)
.................... 		N_beep = 2*n;
.................... 	else
.................... 		N_beep = 255;
.................... 
.................... 	enable_interrupts(INT_TIMER4);
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #INT_TIMER4
.................... void isr_TIMER4()			// Cada 100 ms. Espaciado entre beeps. Habra que asociarlo a una interrupcion por software
.................... {
.................... 		if((N_beep%2)==1)
.................... 		{
.................... 			setup_compare(2, COMPARE_TOGGLE | COMPARE_TIMER3);
.................... 		}
.................... 		else
.................... 		{
.................... 			setup_compare(2, COMPARE_OFF);
.................... 			OFF(BUZZER);
.................... 		}
.................... 
.................... 		if( N_beep>0 )
.................... 		{
.................... 		   	N_beep-=1;
.................... 		}
.................... 		else
.................... 		{
.................... 			disable_interrupts(INT_TIMER4);
.................... 		}
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif // __BEEP_H
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... unsigned int8 dt[512];
.................... unsigned int16 ppm;
.................... int1 datos_flag;
.................... 
.................... #INT_TIMER2
.................... 
.................... void timer2_isr()
*
00708:  PUSH    42
0070A:  PUSH    36
0070C:  PUSH    32
0070E:  MOV     W0,[W15++]
00710:  MOV     #2,W0
00712:  REPEAT  #C
00714:  MOV     [W0++],[W15++]
.................... {
.................... 	ppm=algoritmo();
00716:  CALL    618
*
0071A:  MOV     W0,12DE
.................... }
.................... 
0071C:  BCLR.B  84.7
0071E:  MOV     #1A,W0
00720:  REPEAT  #C
00722:  MOV     [--W15],[W0--]
00724:  MOV     [--W15],W0
00726:  POP     32
00728:  POP     36
0072A:  POP     42
0072C:  RETFIE  
.................... #INT_TIMER5
.................... void timer5_isr()
0072E:  PUSH    42
00730:  PUSH    36
00732:  PUSH    32
00734:  MOV     W0,[W15++]
00736:  MOV     #2,W0
00738:  REPEAT  #C
0073A:  MOV     [W0++],[W15++]
.................... {
.................... 
.................... 	datos_flag=1;
0073C:  BSET.B  85B.1
0073E:  BCLR.B  87.4
00740:  MOV     #1A,W0
00742:  REPEAT  #C
00744:  MOV     [--W15],[W0--]
00746:  MOV     [--W15],W0
00748:  POP     32
0074A:  POP     36
0074C:  POP     42
0074E:  RETFIE  
.................... }
.................... 
.................... void main(void)
*
01DFC:  MOV     #3F50,W15
01DFE:  MOV     #3FFF,W0
01E00:  MOV     W0,20
01E02:  NOP     
01E04:  MOV     #4444,W0
01E06:  MOV     W0,A6
01E08:  MOV     #4444,W0
01E0A:  MOV     W0,B0
01E0C:  BSET.B  81.7
01E0E:  DISI    #6
01E10:  MOV     #742,W1
01E12:  MOV     #46,W2
01E14:  MOV     #57,W3
01E16:  MOV.B   W2L,[W1]
01E18:  MOV.B   W3L,[W1]
01E1A:  BCLR.B  742.6
01E1C:  MOV     #3F14,W0
01E1E:  MOV     W0,6A4
01E20:  MOV     #607,W0
01E22:  MOV     W0,6A8
01E24:  MOV     #700,W0
01E26:  MOV     W0,6C4
01E28:  MOV     #8,W0
01E2A:  MOV     W0,6C6
01E2C:  MOV     #300,W0
01E2E:  MOV     W0,6D2
01E30:  MOV     #13,W0
01E32:  MOV     W0,6D6
01E34:  DISI    #6
01E36:  MOV     #742,W1
01E38:  MOV     #46,W2
01E3A:  MOV     #57,W3
01E3C:  MOV.B   W2L,[W1]
01E3E:  MOV.B   W3L,[W1]
01E40:  BSET.B  742.6
01E42:  BCLR.B  2CD.1
01E44:  BSET.B  207.7
01E46:  BSET.B  207.5
01E48:  BSET.B  206.6
01E4A:  BCLR.B  207.3
01E4C:  BCLR.B  206.7
01E4E:  BCLR.B  207.0
01E50:  BSET.B  207.1
01E52:  BCLR.B  207.2
01E54:  CLR     20A
01E56:  MOV     #1FF,W4
01E58:  MOV     W4,204
01E5A:  MOV     #7E4,W4
01E5C:  MOV     W4,12AE
01E5E:  MOV.B   #14,W0L
01E60:  MOV.B   W0L,12B0
01E62:  MOV.B   #A,W0L
01E64:  MOV.B   W0L,12B1
01E66:  MOV.B   #F,W0L
01E68:  MOV.B   W0L,12B2
01E6A:  MOV.B   #C,W0L
01E6C:  MOV.B   W0L,12B3
01E6E:  MOV.B   #22,W0L
01E70:  MOV.B   W0L,12B4
01E72:  MOV.B   #38,W0L
01E74:  MOV.B   W0L,12B5
01E76:  CLR     A78
01E78:  CLR     A7A
01E7A:  CLR     12DC
01E7C:  MOV     #8000,W4
01E7E:  MOV     W4,220
01E80:  MOV     #400,W4
01E82:  MOV     W4,222
01E84:  BCLR.B  220.3
01E86:  MOV     #2,W4
01E88:  MOV     W4,228
01E8A:  SETM    32C
01E8C:  CLR     12DA
01E8E:  CLR     12EC
.................... {
....................   //Declaración e inicialización de variables
.................... 
....................   char ppm_string[9];
.................... 
.................... 	// Flags del programa
....................   int1 peligro_flag, altas, bajas;
.................... 
....................   unsigned int16 ppm_anterior=0;
.................... 
.................... 
.................... 	peligro_flag=0;
01E90:  BCLR.B  12E0.0
.................... 	altas=0;
01E92:  BCLR.B  12E0.1
.................... 	bajas=0;
01E94:  BCLR.B  12E0.2
.................... 
....................   //para debugging. Eliminar al final
.................... 
.................... 
....................   // -----------------------------------------
.................... 
....................   // 1. Inicialización de módulos (BT, LCD)
....................   // 2. Menu de bienvenida y espera a BTOK
.................... 	// 3. Inicializar ADC y rutina del algoritmo
....................   // 4. Bucle de programa. Finalizar al pulsar BTOK
.................... 	//			4.1 Un ISR temporizado calcula las ppm
....................   //      4.2 Generar alarmas si es necesario
....................   //      4.3 Mostrar por pantalla
....................   //      4.4 Envío de datos
.................... 
.................... 
....................   //1.
....................   init_BT();
01E96:  CALL    760
....................   lcdi2cinit();
*
01E9A:  CALL    826
....................   BEEP_Init();
*
01E9E:  CALL    8B6
.................... 
.................... 
....................   //2. Menu bienvenida
....................   initmenu();
*
01EA2:  CALL    94C
....................   while(input(BTOK))
*
01EA6:  BSET.B  2C0.7
01EA8:  NOP     
01EAA:  BTSS.B  2C2.7
01EAC:  BRA     1EB8
....................   {
....................     delay_ms(50);
01EAE:  MOV     #32,W0
01EB0:  CALL    750
*
01EB4:  GOTO    1EA6
....................   }
....................   while(!input(BTOK)) // para evitar rebotes y finalizar el programa
*
01EB8:  BSET.B  2C0.7
01EBA:  NOP     
01EBC:  BTSC.B  2C2.7
01EBE:  BRA     1ECA
....................   {
....................     delay_ms(50);
01EC0:  MOV     #32,W0
01EC2:  CALL    750
*
01EC6:  GOTO    1EB8
....................   }
.................... 
.................... 
....................   //3. Inicializar algoritmo, adc y timer2 a 250 Hz
....................   adcinit();
*
01ECA:  CALL    9D4
.................... 	sd_init_global();
*
01ECE:  CALL    173C
.................... 
.................... 
....................   setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8, 2765); // 11059200/2/8/1843 = 4 ms
*
01ED2:  CLR     110
01ED4:  MOV     #ACD,W4
01ED6:  MOV     W4,10C
01ED8:  MOV     #8010,W4
01EDA:  MOV     W4,110
.................... 	setup_timer5(TMR_INTERNAL | TMR_DIV_BY_256, 216*50); // 11059200/2/8/14395 = 1 s
01EDC:  CLR     120
01EDE:  MOV     #2A30,W4
01EE0:  MOV     W4,11C
01EE2:  MOV     #8030,W4
01EE4:  MOV     W4,120
....................   init_algoritmo();
01EE6:  CALL    1758
.................... 	enable_interrupts(INT_TIMER5);
*
01EEA:  BSET.B  97.4
.................... 	memset(dt,0,512);
01EEC:  MOV     #878,W1
01EEE:  MOV     #0,W2
01EF0:  REPEAT  #1FF
01EF2:  CLR.B   [W1++]
.................... 
....................   //Mostrar pantalla de frecuencia
....................   display_frecuencia();
01EF4:  CALL    1798
....................   delay_ms(4); // que al menos se ejecute el algoritmo una vez para no tener valores raros
*
01EF8:  REPEAT  #1662
01EFA:  NOP     
01EFC:  REPEAT  #3FFF
01EFE:  NOP     
.................... 
....................   //4. Bucle del programa
....................   while(input(BTOK))
01F00:  BSET.B  2C0.7
01F02:  NOP     
01F04:  BTSS.B  2C2.7
01F06:  BRA     1FA0
....................   {
.................... 
.................... 		//Comprobar si hay electrodo suelto
.................... 		// if(input(PIN_)) // COnectar pin del electrodo
.................... 		// {
.................... 		// 	display_electrodo_suelto();
.................... 		// 	disable_interrupts(INT_TIMER2);
.................... 		// 	disable_interrupts(INT_TIMER5);
.................... 		// 	while(input(PIN_))
.................... 		// 	{
.................... 		// 		delay_ms(100);
.................... 		// 	}
.................... 		// 	display_electrodo_recuperado();
.................... 		// 	while(!input(BTOK)) // pulsa para continuar
.................... 		//   {
.................... 		//     delay_ms(50);
.................... 		//   }
.................... 		// 	enable_interrupts(INT_TIMER2); // restaura ciclo de funcionamiento normal
.................... 		// 	enable_interrupts(INT_TIMER5);
.................... 		// 	delay_ms(4);
.................... 		// }
.................... 
....................     //4.1 Generar alarmas si es necesario
....................     if(ppm>=250)
01F08:  MOV     12DE,W4
01F0A:  MOV     #FA,W3
01F0C:  CP      W3,W4
01F0E:  BRA     GTU,1F22
....................     {
.................... 			if(!altas)	display_alarma_alto();
01F10:  BTSC.B  12E0.1
01F12:  BRA     1F18
01F14:  CALL    1848
.................... 			altas=1;
*
01F18:  BSET.B  12E0.1
.................... 			bajas=0;
01F1A:  BCLR.B  12E0.2
.................... 			peligro_flag=1;
01F1C:  BSET.B  12E0.0
.................... 			ppm_anterior=ppm;
01F1E:  PUSH    12DE
01F20:  POP     12EC
.................... 		}
.................... 		if(ppm<=35)
01F22:  MOV     12DE,W4
01F24:  MOV     #23,W3
01F26:  CP      W3,W4
01F28:  BRA     NC,1F40
....................     {
.................... 			if(!bajas)	display_alarma_bajo();
01F2A:  BTSC.B  12E0.2
01F2C:  BRA     1F32
01F2E:  CALL    188C
.................... 			altas=0;
*
01F32:  BCLR.B  12E0.1
.................... 			bajas=1;
01F34:  BSET.B  12E0.2
.................... 			peligro_flag=1;
01F36:  BSET.B  12E0.0
.................... 			ppm_anterior=ppm;
01F38:  PUSH    12DE
01F3A:  POP     12EC
.................... 			output_toggle(BUZZER);
01F3C:  BCLR.B  2D0.6
01F3E:  BTG.B   2D4.6
.................... 		}
.................... 
.................... 		//4.2 Mostrar por pantalla en funcionamiento normal
.................... 		if(!peligro_flag)
01F40:  BTSC.B  12E0.0
01F42:  BRA     1F84
.................... 		{
.................... 			OFF(BUZZER);
01F44:  BCLR.B  2D0.6
01F46:  BCLR.B  2D4.6
.................... 			if(ppm!=ppm_anterior) // mostrar por pantalla si ha cambiado el valor
01F48:  MOV     12DE,W0
01F4A:  CP      12EC
01F4C:  BRA     Z,1F84
.................... 			{
.................... 				display_frecuencia();
01F4E:  CALL    1798
.................... 				sprintf(ppm_string,"%d  ",ppm); // crear cadena con espacios para borrar el valor anterior
*
01F52:  MOV     #12E2,W4
01F54:  MOV     W4,12DC
01F56:  MOV     12DE,W0
01F58:  MOV     #0,W4
01F5A:  CALL    18D8
*
01F5E:  MOV.B   #20,W0L
01F60:  CALL    18CA
*
01F64:  MOV.B   #20,W0L
01F66:  CALL    18CA
.................... 				LCD_cursor_at(0,16);
*
01F6A:  CLR.B   1328
01F6C:  MOV.B   #10,W0L
01F6E:  MOV.B   W0L,1329
01F70:  CALL    8D0
.................... 				LCD_write(ppm_string);
*
01F74:  MOV     #12E2,W4
01F76:  MOV     W4,1328
01F78:  CALL    8F0
.................... 				ppm_anterior=ppm; 							// actualizar pulsaciones anteriores
*
01F7C:  PUSH    12DE
01F7E:  POP     12EC
.................... 				bajas=0;
01F80:  BCLR.B  12E0.2
.................... 				altas=0;
01F82:  BCLR.B  12E0.1
.................... 			}
.................... 		}
.................... 
.................... 
....................     //4.3 Enviar datos y escribir cada x segundos
....................     if(datos_flag)
01F84:  BTSS.B  85B.1
01F86:  BRA     1F9A
....................     {
....................       enviar_datos(ppm);
01F88:  PUSH    12DE
01F8A:  POP     12EE
01F8C:  CALL    1B08
.................... 			escritura_sd(ppm);
*
01F90:  PUSH    12DE
01F92:  POP     12EE
01F94:  CALL    1D78
.................... 			datos_flag=0;
*
01F98:  BCLR.B  85B.1
.................... 		}
.................... 		peligro_flag=0; // actualizar flag
01F9A:  BCLR.B  12E0.0
01F9C:  GOTO    1F00
....................     //fin del bucle
....................   }
.................... 
.................... 	//fin de programa
.................... 	display_final();
*
01FA0:  CALL    1DC0
.................... 	disable_interrupts(INT_TIMER2);
*
01FA4:  BCLR.B  94.7
01FA6:  NOP     
.................... 	disable_interrupts(INT_TIMER5);
01FA8:  BCLR.B  97.4
01FAA:  NOP     
.................... }
01FAC:  BRA     1FAC

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: 0000  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: 0000  
   Word  3L: 0007   NOWRT NOPROTECT
          H: 0000  
   Word  4L: 0002   PR NOIESO
          H: 0000  
   Word  5L: 0062   HS OSCIO IOL1WAY CKSNOFSM
          H: 0000  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: 0000  
   Word  7L: 00F7   PUT128 NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: 0000  
   Word  8L: 0043   ICSP1 NOJTAG DEBUG
          H: 0000  

   Some fuses have been forced to be compatible with the ICD debugger.
