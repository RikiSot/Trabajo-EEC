CCS PCD C Compiler, Version 5.051, 27113               18-ene.-21 18:19

               Filename:   C:\Users\klzi\Desktop\Klaudija\main.lst

               ROM used:   3878 bytes (4%)
                           Largest free fragment is 61658
               RAM used:   2865 (18%) at main() level
                           2936 (18%) worst case
               Stack used: 76 locations (20 in main + 56 for interrupts)
               Stack size: 160

*
00000:  GOTO    D92
*
00022:  DATA    D2,06,00
*
0004A:  DATA    6C,02,00
0004C:  DATA    F8,06,00
.................... /** 
....................  @file    main.c 
....................  @author  Ricardo Gomez 
....................  
....................  @brief   main EEC 
.................... */ 
....................  
.................... /* SECTION 1: Included header files to compile this file           */ 
.................... #include "33FJ128MC804.h" 
....................  
.................... #ifndef LIB_h 
.................... #define LIB_h 
....................  
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device DSPIC33FJ128MC804 
*
00200:  CLR     32
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    24,52,00
0020E:  DATA    65,70,00
00210:  DATA    72,65,00
00212:  DATA    73,65,00
00214:  DATA    6E,74,00
00216:  DATA    61,63,00
00218:  DATA    69,6F,00
0021A:  DATA    6E,20,00
0021C:  DATA    67,72,00
0021E:  DATA    61,66,00
00220:  DATA    69,63,00
00222:  DATA    61,2C,00
00224:  DATA    46,75,00
00226:  DATA    6E,63,00
00228:  DATA    69,6F,00
0022A:  DATA    6E,2C,00
0022C:  DATA    64,61,00
0022E:  DATA    74,6F,00
00230:  DATA    73,20,00
00232:  DATA    31,0A,00
00234:  DATA    00,00,00
00236:  CLR     32
00238:  MOV     #242,W3
0023A:  ADD     W3,W0,W0
0023C:  TBLRDL.B[W0],W0L
0023E:  CLR.B   1
00240:  RETURN  
00242:  DATA    26,30,00
00244:  DATA    2C,31,00
00246:  DATA    30,30,00
00248:  DATA    30,2C,00
0024A:  DATA    30,2C,00
0024C:  DATA    31,2C,00
0024E:  DATA    30,0A,00
00250:  DATA    00,00,00
00252:  CLR     32
00254:  MOV     #25E,W3
00256:  ADD     W3,W0,W0
00258:  TBLRDL.B[W0],W0L
0025A:  CLR.B   1
0025C:  RETURN  
0025E:  DATA    23,30,00
00260:  DATA    2C,32,00
00262:  DATA    30,30,00
00264:  DATA    2C,30,00
00266:  DATA    2C,31,00
00268:  DATA    2C,30,00
0026A:  DATA    0A,00,00
*
002B4:  MOV     W5,[W15++]
002B6:  MOV     W6,[W15++]
002B8:  MOV     #8E,W1
002BA:  CP0     W0
002BC:  BRA     Z,2E2
002BE:  BTSC    W0.F
002C0:  BRA     2CA
002C2:  BCLR.B  42.0
002C4:  RLC     W0,W0
002C6:  DEC     W1,W1
002C8:  BRA     2BE
002CA:  SWAP    W1
002CC:  BCLR.B  42.0
002CE:  RRC     W1,W1
002D0:  BCLR    W0.F
002D2:  SWAP    W0
002D4:  XOR.B   W0L,W1L,W1L
002D6:  AND.B   #0,W0L
002D8:  BRA     2E8
002DA:  MOV.B   W1L,W0L
002DC:  BSET    W1.7
002DE:  AND.B   #0,W1L
002E0:  BRA     2E8
002E2:  CLR     W0
002E4:  CLR     W1
002E6:  BRA     2E8
002E8:  MOV     [--W15],W6
002EA:  MOV     [--W15],W5
002EC:  RETURN  
002EE:  MOV     W5,[W15++]
002F0:  MOV     W6,[W15++]
002F2:  MOV     W7,[W15++]
002F4:  XOR     W1,W3,W4
002F6:  BTSS    W4.F
002F8:  BRA     306
002FA:  BCLR.B  42.0
002FC:  BCLR.B  42.1
002FE:  BTSS    W1.F
00300:  BRA     34E
00302:  BSET.B  42.0
00304:  BRA     34E
00306:  MOV     W1,W4
00308:  MOV     W0,W5
0030A:  MOV     W3,W6
0030C:  MOV     W2,W7
0030E:  RLC     W1,W1
00310:  SWAP    W1
00312:  RLC     W3,W3
00314:  SWAP    W3
00316:  SUB.B   W3L,W1L,W1L
00318:  BRA     Z,324
0031A:  BTSS    W4.F
0031C:  BRA     34E
0031E:  MOV     #1,W0
00320:  XOR.B   42
00322:  BRA     34E
00324:  MOV.B   W4L,W1L
00326:  MOV.B   W6L,W3L
00328:  BCLR    W1.7
0032A:  BCLR    W3.7
0032C:  SUB.B   W3L,W1L,W1L
0032E:  BRA     Z,33A
00330:  BTSS    W4.F
00332:  BRA     34E
00334:  MOV     #1,W0
00336:  XOR.B   42
00338:  BRA     34E
0033A:  SUB     W7,W5,W1
0033C:  BRA     Z,348
0033E:  BTSS    W4.F
00340:  BRA     34E
00342:  MOV     #1,W0
00344:  XOR.B   42
00346:  BRA     34E
00348:  BCLR.B  42.0
0034A:  BRA     34E
0034C:  BRA     34E
0034E:  MOV     [--W15],W7
00350:  MOV     [--W15],W6
00352:  MOV     [--W15],W5
00354:  RETURN  
*
0036E:  MOV     W5,[W15++]
00370:  MOV     #C,W5
00372:  REPEAT  #4
00374:  MOV     [W5++],[W15++]
00376:  CLR     W9
00378:  XOR     W1,W3,W9
0037A:  MOV     W1,W6
0037C:  MOV     W0,W5
0037E:  MOV     W3,W8
00380:  MOV     W2,W7
00382:  RLC     W1,W1
00384:  SWAP    W1
00386:  ZE      W1,W1
00388:  CP0     W1
0038A:  BRA     Z,428
0038C:  RLC     W3,W3
0038E:  SWAP    W3
00390:  ZE      W3,W3
00392:  CP0     W3
00394:  BRA     Z,428
00396:  CLR     W0
00398:  SUB.B   W1L,W3L,W0L
0039A:  BRA     NC,3A2
0039C:  ADD.B   #7F,W0L
0039E:  BRA     C,428
003A0:  BRA     3A8
003A2:  SUB.B   #81,W0L
003A4:  BRA     NC,428
003A6:  BRA     Z,428
003A8:  MOV     W5,W1
003AA:  MOV     W6,W2
003AC:  BSET    W2.7
003AE:  AND     #FF,W2
003B0:  AND     #FF,W8
003B2:  BSET    W8.7
003B4:  MOV     #19,W10
003B6:  CLR     W3
003B8:  CLR     W4
003BA:  SUB     W1,W7,W1
003BC:  SUBB    W2,W8,W2
003BE:  BRA     N,3C4
003C0:  BRA     C,3CA
003C2:  BRA     NZ,3CC
003C4:  ADD     W1,W7,W1
003C6:  ADDC    W2,W8,W2
003C8:  BRA     3CC
003CA:  BSET    W4.0
003CC:  DEC     W10,W10
003CE:  BRA     Z,3DE
003D0:  BCLR.B  42.0
003D2:  RLC     W1,W1
003D4:  RLC     W2,W2
003D6:  BCLR.B  42.0
003D8:  RLC     W4,W4
003DA:  RLC     W3,W3
003DC:  BRA     3BA
003DE:  CLR     W10
003E0:  BTSC    W3.8
003E2:  BRA     3E6
003E4:  BRA     3F2
003E6:  BCLR.B  42.0
003E8:  RRC     W3,W3
003EA:  BCLR    W3.7
003EC:  RRC     W4,W4
003EE:  RLC     W10,W10
003F0:  BRA     3F6
003F2:  DEC     W0,W0
003F4:  BRA     Z,428
003F6:  BTSC    W10.F
003F8:  BRA     NC,404
003FA:  RLC     W1,W1
003FC:  RLC     W2,W2
003FE:  SUB     W1,W7,W1
00400:  SUBB    W2,W8,W2
00402:  BRA     NC,416
00404:  INC     W4,W4
00406:  BRA     NZ,416
00408:  INC     W3,W3
0040A:  BRA     NZ,416
0040C:  INC     W0,W0
0040E:  BRA     Z,428
00410:  BRA     416
00412:  DEC     W0,W0
00414:  BRA     Z,428
00416:  SWAP    W0
00418:  RRC     W0,W1
0041A:  BSET    W1.F
0041C:  BTSS    W9.F
0041E:  BCLR    W1.F
00420:  BCLR    W3.7
00422:  XOR.B   W3L,W1L,W1L
00424:  MOV     W4,W0
00426:  BRA     42E
00428:  MOV     #0,W0
0042A:  MOV     #0,W1
0042C:  BRA     42E
0042E:  MOV     #14,W5
00430:  REPEAT  #4
00432:  MOV     [--W15],[W5--]
00434:  MOV     [--W15],W5
00436:  RETURN  
00438:  MOV     W5,[W15++]
0043A:  MOV     #C,W5
0043C:  REPEAT  #3
0043E:  MOV     [W5++],[W15++]
00440:  CLR     W9
00442:  MOV     #8000,W8
00444:  BTSC.B  43.0
00446:  XOR     W8,W3,W3
00448:  CP0     W0
0044A:  BRA     NZ,452
0044C:  MOV     #7FFF,W10
0044E:  AND     W1,W10,W10
00450:  BTSS.B  42.1
00452:  MOV     W1,W10
00454:  XOR     W3,W10,W11
00456:  MOV     W1,W6
00458:  MOV     W3,W7
0045A:  MOV     W3,W12
0045C:  BCLR.B  42.1
0045E:  BCLR.B  42.0
00460:  RLC     W6,W6
00462:  SWAP    W6
00464:  AND     #FF,W6
00466:  CP0     W6
00468:  BRA     Z,5AC
0046A:  BCLR.B  42.1
0046C:  BCLR.B  42.0
0046E:  RLC     W7,W7
00470:  SWAP    W7
00472:  AND     #FF,W7
00474:  CP0     W7
00476:  BRA     Z,5B6
00478:  BCLR.B  42.1
0047A:  BCLR.B  42.0
0047C:  CP      W7,W6
0047E:  BRA     Z,5B8
00480:  BRA     N,5C8
00482:  BCLR    W9.0
00484:  BSET    W9.1
00486:  SUB     W7,W6,W8
00488:  MOV     W7,W6
0048A:  AND     #FF,W1
0048C:  BSET    W1.7
0048E:  AND     #FF,W3
00490:  BSET    W3.7
00492:  MOV     #28,W7
00494:  CP      W7,W8
00496:  BRA     N,4BA
00498:  BCLR.B  42.1
0049A:  BCLR.B  42.0
0049C:  RRC     W1,W1
0049E:  RRC     W0,W0
004A0:  DEC     W8,W8
004A2:  BRA     NZ,498
004A4:  BRA     4C0
004A6:  MOV     #28,W7
004A8:  CP      W7,W8
004AA:  BRA     N,4BE
004AC:  BCLR.B  42.1
004AE:  BCLR.B  42.0
004B0:  RRC     W3,W3
004B2:  RRC     W2,W2
004B4:  DEC     W8,W8
004B6:  BRA     NZ,4AC
004B8:  BRA     4D8
004BA:  MOV     W2,W0
004BC:  MOV     W3,W1
004BE:  BRA     546
004C0:  BTSS    W11.F
004C2:  BRA     4E6
004C4:  BTSC    W9.4
004C6:  MOV     W12,W11
004C8:  NEG     W0,W0
004CA:  BRA     Z,4D0
004CC:  COM.B   W1L,W1L
004CE:  BRA     4D2
004D0:  NEG     W1,W1
004D2:  BTSC    W9.4
004D4:  BRA     52C
004D6:  BRA     4E6
004D8:  BTSS    W11.F
004DA:  BRA     4E6
004DC:  NEG     W2,W2
004DE:  BRA     Z,4E4
004E0:  COM.B   W3L,W3L
004E2:  BRA     4E6
004E4:  NEG     W3,W3
004E6:  AND     #FF,W5
004E8:  BCLR.B  42.1
004EA:  BCLR.B  42.0
004EC:  ADD     W0,W2,W0
004EE:  ADDC.B  W1L,W3L,W1L
004F0:  BTSC.B  42.0
004F2:  BSET    W9.3
004F4:  BTSC    W9.0
004F6:  BRA     50A
004F8:  BTSC    W9.1
004FA:  BRA     4FE
004FC:  BRA     514
004FE:  BTSC    W11.F
00500:  BRA     52C
00502:  BTSC    W9.3
00504:  BRA     558
00506:  BSET    W9.6
00508:  BRA     546
0050A:  BTSC    W11.F
0050C:  BRA     52C
0050E:  BTSC    W9.3
00510:  BRA     558
00512:  BRA     546
00514:  BCLR    W9.2
00516:  BTSC    W11.F
00518:  BRA     522
0051A:  MOV     W10,W11
0051C:  BTSC    W9.3
0051E:  BRA     558
00520:  BRA     58E
00522:  BSET    W9.4
00524:  XOR.B   #80,W1L
00526:  BTSC    W1.7
00528:  BRA     4C4
0052A:  MOV     W10,W11
0052C:  AND     #FF,W1
0052E:  IOR      W0,  W1,W7
00530:  BRA     Z,546
00532:  BTSC    W1.7
00534:  BRA     546
00536:  BCLR.B  42.1
00538:  BCLR.B  42.0
0053A:  RLC     W0,W0
0053C:  RLC     W1,W1
0053E:  DEC     W6,W6
00540:  BTSC.B  42.1
00542:  BRA     5A6
00544:  BRA     532
00546:  BTSC    W9.0
00548:  MOV     W10,W11
0054A:  BTSC    W9.1
0054C:  MOV     W12,W11
0054E:  BTSS    W9.5
00550:  BRA     586
00552:  BTSC    W10.F
00554:  BSET    W0.8
00556:  BRA     58E
00558:  BSET.B  42.0
0055A:  RRC.B   W1L,W1L
0055C:  RRC     W0,W0
0055E:  BTSC.B  42.0
00560:  BSET    W9.5
00562:  INC     W6,W6
00564:  BRA     Z,5A6
00566:  BTSS    W9.5
00568:  BRA     57A
0056A:  INC     W0,W0
0056C:  BRA     NZ,57A
0056E:  INC.B   W1L,W1L
00570:  BRA     NZ,57A
00572:  RRC.B   W1L,W1L
00574:  RRC     W0,W0
00576:  INC     W6,W6
00578:  BRA     Z,5A6
0057A:  BTSC    W9.0
0057C:  MOV     W10,W11
0057E:  BTSC    W9.1
00580:  MOV     W12,W11
00582:  BTSC.B  42.1
00584:  BRA     5A6
00586:  BTSC    W9.6
00588:  MOV     W10,W11
0058A:  BTSC    W9.7
0058C:  MOV     W12,W11
0058E:  IOR      W0,  W1,W2
00590:  BRA     Z,5D8
00592:  BCLR    W1.7
00594:  SWAP    W6
00596:  BCLR.B  42.1
00598:  BCLR.B  42.0
0059A:  RRC     W6,W6
0059C:  XOR     W6,W1,W1
0059E:  BSET    W1.F
005A0:  BTSS    W11.F
005A2:  BCLR    W1.F
005A4:  BRA     5D8
005A6:  MOV     #0,W0
005A8:  MOV     #0,W1
005AA:  BRA     5D8
005AC:  BTSC    W10.F
005AE:  XOR     W8,W3,W3
005B0:  MOV     W2,W0
005B2:  MOV     W3,W1
005B4:  BRA     5D8
005B6:  BRA     5D8
005B8:  AND     #FF,W3
005BA:  BSET    W3.7
005BC:  AND     #FF,W1
005BE:  BSET    W1.7
005C0:  BTSC    W11.F
005C2:  BCLR    W3.7
005C4:  BSET    W9.2
005C6:  BRA     4D8
005C8:  SUB     W6,W7,W8
005CA:  AND     #FF,W1
005CC:  BSET    W1.7
005CE:  AND     #FF,W3
005D0:  BSET    W3.7
005D2:  BCLR    W9.1
005D4:  BSET    W9.0
005D6:  BRA     4A6
005D8:  MOV     #12,W5
005DA:  REPEAT  #3
005DC:  MOV     [--W15],[W5--]
005DE:  MOV     [--W15],W5
005E0:  RETURN  
*
00AAA:  MOV     W1,[W15++]
00AAC:  MOV     12DC,W1
00AAE:  MOV.B   W0L,[W1++]
00AB0:  CLR.B   [W1]
00AB2:  MOV     [--W15],W1
00AB4:  INC     12DC
00AB6:  RETURN  
00AB8:  MOV     W5,[W15++]
00ABA:  MOV     #C,W5
00ABC:  REPEAT  #3
00ABE:  MOV     [W5++],[W15++]
00AC0:  BTSS    W0.F
00AC2:  BRA     AE2
00AC4:  NEG     W0,W0
00AC6:  BSET    W4.8
00AC8:  BTSS    W4.F
00ACA:  BRA     AE2
00ACC:  MOV     W0,[W15++]
00ACE:  MOV     #2D,W0
00AD0:  MOV     W4,[W15++]
00AD2:  MOV     W0,[W15++]
00AD4:  MOV     [--W15],W0
00AD6:  CALL    AAA
00ADA:  MOV     [--W15],W4
00ADC:  MOV     [--W15],W0
00ADE:  BCLR    W4.8
00AE0:  DEC.B   0008
00AE2:  CLR     W5
00AE4:  MOV     W0,W7
00AE6:  MOV     W4,W9
00AE8:  BCLR    W4.F
00AEA:  CP0.B   W4L
00AEC:  BRA     NZ,AFA
00AEE:  BTSC    W9.F
00AF0:  BRA     AF6
00AF2:  MOV     #0,W5
00AF4:  BRA     B24
00AF6:  MOV     #0,W5
00AF8:  BRA     B24
00AFA:  BTSS    W9.8
00AFC:  SUB.B   W4L,#6,W5L
00AFE:  BTSC    W9.8
00B00:  SUB.B   W4L,#7,W5L
00B02:  BRA     NC,B22
00B04:  MOV     #30,W0
00B06:  BTSS    W9.F
00B08:  MOV     #20,W0
00B0A:  MOV     W0,[W15++]
00B0C:  MOV     W4,[W15++]
00B0E:  MOV     W0,[W15++]
00B10:  MOV     [--W15],W0
00B12:  CALL    AAA
00B16:  MOV     [--W15],W4
00B18:  MOV     [--W15],W0
00B1A:  DEC     W5,W5
00B1C:  BRA     NN,B0A
00B1E:  MOV     #5,W5
00B20:  BRA     B24
00B22:  MOV     W4,W5
00B24:  MOV     #6,W4
00B26:  BTSC    W5.8
00B28:  INC     W4,W4
00B2A:  BSET    W5.E
00B2C:  BTSC    W9.F
00B2E:  BSET    W5.F
00B30:  MOV     #2710,W8
00B32:  REPEAT  #11
00B34:  DIV.U   W7,W8
00B36:  CALL    B8A
00B3A:  MOV     W1,W7
00B3C:  MOV     #3E8,W8
00B3E:  REPEAT  #11
00B40:  DIV.U   W7,W8
00B42:  CALL    B8A
00B46:  MOV     W1,W7
00B48:  MOV     #64,W8
00B4A:  REPEAT  #11
00B4C:  DIV.U   W7,W8
00B4E:  CALL    B8A
00B52:  MOV     W1,W7
00B54:  MOV     #A,W8
00B56:  REPEAT  #11
00B58:  DIV.U   W7,W8
00B5A:  CALL    B8A
00B5E:  BTSS    W9.8
00B60:  BRA     B76
00B62:  MOV     #2D,W0
00B64:  MOV     W1,[W15++]
00B66:  MOV     W4,[W15++]
00B68:  MOV     W0,[W15++]
00B6A:  MOV     [--W15],W0
00B6C:  CALL    AAA
00B70:  MOV     [--W15],W4
00B72:  MOV     [--W15],W1
00B74:  BCLR    W9.8
00B76:  MOV     #30,W0
00B78:  ADD.B   W1L,W0L,W0L
00B7A:  MOV     W0,2A
00B7C:  MOV     W4,[W15++]
00B7E:  MOV     W0,[W15++]
00B80:  MOV     [--W15],W0
00B82:  CALL    AAA
00B86:  MOV     [--W15],W4
00B88:  BRA     BDE
00B8A:  MOV     #30,W6
00B8C:  CP0     W0
00B8E:  BRA     NZ,BAC
00B90:  BTSS    W5.E
00B92:  BRA     BCA
00B94:  DEC     W4,W4
00B96:  CP.B    W4L,W5L
00B98:  BRA     Z,B9E
00B9A:  BTSC.B  42.0
00B9C:  RETURN  
00B9E:  CP0     W0
00BA0:  BRA     NZ,BAC
00BA2:  BTSS    W5.E
00BA4:  BRA     BCA
00BA6:  BTSS    W5.F
00BA8:  MOV     #20,W6
00BAA:  BRA     BCA
00BAC:  BCLR    W5.E
00BAE:  BTSS    W9.8
00BB0:  BRA     BCA
00BB2:  MOV     W0,W10
00BB4:  MOV     #2D,W0
00BB6:  MOV     W1,[W15++]
00BB8:  MOV     W4,[W15++]
00BBA:  MOV     W0,[W15++]
00BBC:  MOV     [--W15],W0
00BBE:  CALL    AAA
00BC2:  MOV     [--W15],W4
00BC4:  MOV     [--W15],W1
00BC6:  BCLR    W9.8
00BC8:  MOV     W10,W0
00BCA:  ADD.B   W6L,W0L,W0L
00BCC:  MOV     W1,[W15++]
00BCE:  MOV     W4,[W15++]
00BD0:  MOV     W0,[W15++]
00BD2:  MOV     [--W15],W0
00BD4:  CALL    AAA
00BD8:  MOV     [--W15],W4
00BDA:  MOV     [--W15],W1
00BDC:  RETURN  
00BDE:  MOV     #12,W5
00BE0:  REPEAT  #3
00BE2:  MOV     [--W15],[W5--]
00BE4:  MOV     [--W15],W5
00BE6:  RETURN  
00BE8:  MOV     W5,[W15++]
00BEA:  MOV     #C,W5
00BEC:  REPEAT  #3
00BEE:  MOV     [W5++],[W15++]
00BF0:  BTSS    W0.F
00BF2:  BRA     C0C
00BF4:  NEG     W0,W0
00BF6:  BSET    W4.8
00BF8:  BTSS    W4.F
00BFA:  BRA     C0C
00BFC:  MOV     W0,[W15++]
00BFE:  MOV     #2D,W0
00C00:  BTSC.B  223.1
00C02:  BRA     C00
00C04:  MOV     W0,224
00C06:  MOV     [--W15],W0
00C08:  BCLR    W4.8
00C0A:  DEC.B   0008
00C0C:  CLR     W5
00C0E:  MOV     W0,W7
00C10:  MOV     W4,W9
00C12:  BCLR    W4.F
00C14:  CP0.B   W4L
00C16:  BRA     NZ,C24
00C18:  BTSC    W9.F
00C1A:  BRA     C20
00C1C:  MOV     #0,W5
00C1E:  BRA     C48
00C20:  MOV     #0,W5
00C22:  BRA     C48
00C24:  BTSS    W9.8
00C26:  SUB.B   W4L,#6,W5L
00C28:  BTSC    W9.8
00C2A:  SUB.B   W4L,#7,W5L
00C2C:  BRA     NC,C46
00C2E:  MOV     #30,W0
00C30:  BTSS    W9.F
00C32:  MOV     #20,W0
00C34:  MOV     W0,[W15++]
00C36:  BTSC.B  223.1
00C38:  BRA     C36
00C3A:  MOV     W0,224
00C3C:  MOV     [--W15],W0
00C3E:  DEC     W5,W5
00C40:  BRA     NN,C34
00C42:  MOV     #5,W5
00C44:  BRA     C48
00C46:  MOV     W4,W5
00C48:  MOV     #6,W4
00C4A:  BTSC    W5.8
00C4C:  INC     W4,W4
00C4E:  BSET    W5.E
00C50:  BTSC    W9.F
00C52:  BSET    W5.F
00C54:  MOV     #2710,W8
00C56:  REPEAT  #11
00C58:  DIV.U   W7,W8
00C5A:  CALL    C9E
00C5E:  MOV     W1,W7
00C60:  MOV     #3E8,W8
00C62:  REPEAT  #11
00C64:  DIV.U   W7,W8
00C66:  CALL    C9E
00C6A:  MOV     W1,W7
00C6C:  MOV     #64,W8
00C6E:  REPEAT  #11
00C70:  DIV.U   W7,W8
00C72:  CALL    C9E
00C76:  MOV     W1,W7
00C78:  MOV     #A,W8
00C7A:  REPEAT  #11
00C7C:  DIV.U   W7,W8
00C7E:  CALL    C9E
00C82:  BTSS    W9.8
00C84:  BRA     C90
00C86:  MOV     #2D,W0
00C88:  BTSC.B  223.1
00C8A:  BRA     C88
00C8C:  MOV     W0,224
00C8E:  BCLR    W9.8
00C90:  MOV     #30,W0
00C92:  ADD.B   W1L,W0L,W0L
00C94:  MOV     W0,2A
00C96:  BTSC.B  223.1
00C98:  BRA     C96
00C9A:  MOV     W0,224
00C9C:  BRA     CDE
00C9E:  MOV     #30,W6
00CA0:  CP0     W0
00CA2:  BRA     NZ,CC0
00CA4:  BTSS    W5.E
00CA6:  BRA     CD4
00CA8:  DEC     W4,W4
00CAA:  CP.B    W4L,W5L
00CAC:  BRA     Z,CB2
00CAE:  BTSC.B  42.0
00CB0:  RETURN  
00CB2:  CP0     W0
00CB4:  BRA     NZ,CC0
00CB6:  BTSS    W5.E
00CB8:  BRA     CD4
00CBA:  BTSS    W5.F
00CBC:  MOV     #20,W6
00CBE:  BRA     CD4
00CC0:  BCLR    W5.E
00CC2:  BTSS    W9.8
00CC4:  BRA     CD4
00CC6:  MOV     W0,W10
00CC8:  MOV     #2D,W0
00CCA:  BTSC.B  223.1
00CCC:  BRA     CCA
00CCE:  MOV     W0,224
00CD0:  BCLR    W9.8
00CD2:  MOV     W10,W0
00CD4:  ADD.B   W6L,W0L,W0L
00CD6:  BTSC.B  223.1
00CD8:  BRA     CD6
00CDA:  MOV     W0,224
00CDC:  RETURN  
00CDE:  MOV     #12,W5
00CE0:  REPEAT  #3
00CE2:  MOV     [--W15],[W5--]
00CE4:  MOV     [--W15],W5
00CE6:  RETURN  
....................  
.................... #list 
....................  
.................... #endif 
....................  
....................  
.................... #include <common.h> 
.................... #ifndef COMMON_h 
.................... #define COMMON_h 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... //#include "33FJ128MC804.h" 
.................... #include "Header.h" 
.................... #ifndef HEADER_h 
.................... #define HEADER_h 
.................... //------------------------------------------------------------------- 
....................  
.................... #include "33FJ128MC804.h" 
....................  
.................... #ifndef LIB_h 
.................... #define LIB_h 
....................  
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device DSPIC33FJ128MC804 
....................  
.................... #nolist 
.................... //////// Program memory: 44032x24  Data RAM: 16384  Stack: 31 
.................... //////// I/O: 35   Analog Pins: 9 
.................... //////// Fuses: WRTB,NOWRTB,BSSHL,BSSHM,BSSHS,BSSSL,BSSSM,BSSSS,NOBSS 
.................... //////// Fuses: RBS1024,RBS256,RBS128,NORBS,WRTSS,NOWRTSS,SSSHL,SSSHM,SSSHS 
.................... //////// Fuses: SSSSL,SSSSM,SSSSS,NOSSS,RSS4096,RSS2048,RSS256,NORSS,WRT 
.................... //////// Fuses: NOWRT,PROTECT_HIGH,PROTECT,NOPROTECT,FRC,FRC_PLL,PR,PR_PLL 
.................... //////// Fuses: SOSC,LPRC,FRC_DIV_BY_16,FRC_PS,NOIESO,IESO,EC,XT,HS,NOPR 
.................... //////// Fuses: OSCIO,NOOSCIO,NOIOL1WAY,IOL1WAY,CKSFSM,CKSNOFSM,NOCKSFSM 
.................... //////// Fuses: WPOSTS1,WPOSTS2,WPOSTS3,WPOSTS4,WPOSTS5,WPOSTS6,WPOSTS7 
.................... //////// Fuses: WPOSTS8,WPOSTS9,WPOSTS10,WPOSTS11,WPOSTS12,WPOSTS13,WPOSTS14 
.................... //////// Fuses: WPOSTS15,WPOSTS16,WPRES32,WPRES128,NOWINDIS,WINDIS,NOWDT,WDT 
.................... //////// Fuses: NOPUT,PUT2,PUT4,PUT8,PUT16,PUT32,PUT64,PUT128,ALTI2C1 
.................... //////// Fuses: NOALTI2C1,LPOL_LOW,LPOL_HIGH,HPOL_LOW,HPOL_HIGH,PWMPIN 
.................... //////// Fuses: NOPWMPIN,ICSP3,ICSP2,ICSP1,NOJTAG,JTAG,DEBUG,NODEBUG 
.................... //////// 
.................... #if (!defined(__PCD__)||defined(__ISNT_CCS__)) 
.................... #define _bif 
.................... #define int8 char 
.................... #define int16 int 
.................... #define int32 long 
.................... #define int48 long 
.................... #define int64 long long 
.................... #define float32 float 
.................... #define float48 float 
.................... #define float64 double 
.................... #define int1 char 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////////////////////// PIN_SELECT 
.................... // #pin_select function=pin 
.................... // Valid Pins: 
.................... //    PIN_B0,PIN_B1,PIN_B2,PIN_B3,PIN_B4,PIN_B5,PIN_B6,PIN_B7,PIN_B8,PIN_B9, 
.................... //    PIN_B10,PIN_B11,PIN_B12,PIN_B13,PIN_B14,PIN_B15,PIN_C0,PIN_C1,PIN_C2, 
.................... //    PIN_C3,PIN_C4,PIN_C5,PIN_C6,PIN_C7,PIN_C8,PIN_C9 
.................... // Input Functions: 
.................... //    INT1,INT2,T2CK,T3CK,T4CK,T5CK,IC1,IC2,IC3,IC4,IC5,OCFA,OCFB,U1RX,U1CTS, 
.................... //    U2RX,U2CTS,SDI1,SCK1IN,SS1IN,SDI2,SCK2IN,SS2IN,C1RX,IC7,IC8,CSDI,CSCK,COFS, 
.................... //    FLTA1,FLTA2,QEA1,QEB1,INDX1,QEA2,QEB2,INDX2,T1CK,FLT1,FLT2,FLT3,FLT4,FLT5, 
.................... //    FLT6,FLT7,FLT8,SYNCI1,SYNCI2 
.................... // Output Functions: 
.................... //    NULL,C1OUT,C2OUT,U1TX,U1RTS,U2TX,U2RTS,SDO1,SCK1OUT,SS1OUT,SDO2,SCK2OUT, 
.................... //    SS2OUT,OC1,OC2,OC3,OC4,OC5,C1TX,CSDO,CSCKOUT,COFSOUT,UPDN1,UPDN2,CTPLS, 
.................... //    C3OUT,SYNCO1,REFCLKO,CMP1,CMP2,CMP3,CMP4,PWM4H,PWM4L 
.................... // 
....................  
.................... ////////////////////////////////////////////////////////////////// I/O 
.................... // Discrete I/O Functions: SET_TRIS_x(), OUTPUT_x(), INPUT_x(), 
.................... //                         SET_PULLUP(), INPUT(), 
.................... //                         OUTPUT_LOW(), OUTPUT_HIGH(), 
.................... //                         OUTPUT_FLOAT(), OUTPUT_BIT() 
.................... // Discrete I/O Prototypes: 
.................... _bif void set_tris_a(unsigned int16 value); 
.................... _bif void set_tris_b(unsigned int16 value); 
.................... _bif void set_tris_c(unsigned int16 value); 
.................... _bif unsigned int16 get_tris_a(void); 
.................... _bif unsigned int16 get_tris_b(void); 
.................... _bif unsigned int16 get_tris_c(void); 
.................... _bif void output_a(unsigned int16 value); 
.................... _bif void output_b(unsigned int16 value); 
.................... _bif void output_c(unsigned int16 value); 
.................... _bif unsigned int16 input_a(void); 
.................... _bif unsigned int16 input_b(void); 
.................... _bif unsigned int16 input_c(void); 
.................... _bif int16 input_change_a(void); 
.................... _bif int16 input_change_b(void); 
.................... _bif int16 input_change_c(void); 
.................... _bif void set_pullup(int1 state); 
.................... _bif void set_pullup(int1 state, unsigned int16 pin); 
.................... _bif void set_pulldown(int1 state); 
.................... _bif void set_pulldown(int1 state, unsigned int16 pin); 
.................... _bif int1 input(unsigned int16 pin); 
.................... _bif int1 input_state(unsigned int16 pin); 
.................... _bif void output_low(unsigned int16 pin); 
.................... _bif void output_high(unsigned int16 pin); 
.................... _bif void output_toggle(unsigned int16 pin); 
.................... _bif void output_bit(unsigned int16 pin, int1 level); 
.................... _bif void output_float(unsigned int16 pin); 
.................... _bif void output_drive(unsigned int16 pin); 
.................... // Constants used to identify pins in the above are: 
....................  
.................... #define PIN_A0  5648 
.................... #define PIN_A1  5649 
.................... #define PIN_A2  5650 
.................... #define PIN_A3  5651 
.................... #define PIN_A4  5652 
.................... #define PIN_A7  5655 
.................... #define PIN_A8  5656 
.................... #define PIN_A9  5657 
.................... #define PIN_A10  5658 
....................  
.................... #define PIN_B0  5712 
.................... #define PIN_B1  5713 
.................... #define PIN_B2  5714 
.................... #define PIN_B3  5715 
.................... #define PIN_B4  5716 
.................... #define PIN_B5  5717 
.................... #define PIN_B6  5718 
.................... #define PIN_B7  5719 
.................... #define PIN_B8  5720 
.................... #define PIN_B9  5721 
.................... #define PIN_B10  5722 
.................... #define PIN_B11  5723 
.................... #define PIN_B12  5724 
.................... #define PIN_B13  5725 
.................... #define PIN_B14  5726 
.................... #define PIN_B15  5727 
....................  
.................... #define PIN_C0  5776 
.................... #define PIN_C1  5777 
.................... #define PIN_C2  5778 
.................... #define PIN_C3  5779 
.................... #define PIN_C4  5780 
.................... #define PIN_C5  5781 
.................... #define PIN_C6  5782 
.................... #define PIN_C7  5783 
.................... #define PIN_C8  5784 
.................... #define PIN_C9  5785 
....................  
.................... ////////////////////////////////////////////////////////////////// Useful defines 
.................... #define FALSE 0 
.................... #define TRUE 1 
....................  
.................... #define BYTE unsigned int8 
.................... #define BOOLEAN int1 
....................  
.................... #define getc getch 
.................... #define fgetc getch 
.................... #define getchar getch 
.................... #define putc putchar 
.................... #define fputc putchar 
.................... #define fgets gets 
.................... #define fputs puts 
....................  
.................... ////////////////////////////////////////////////////////////////// UART 
.................... // UART Prototypes: 
.................... _bif void setup_uart(unsigned int32 baud); 
.................... _bif void setup_uart(unsigned int32 baud, unsigned int8 stream); 
.................... _bif void setup_uart(unsigned int32 baud, unsigned int8 stream, unsigned int32 clock); 
.................... _bif void set_uart_speed(unsigned int32 baud); 
.................... _bif void set_uart_speed(unsigned int32 baud, unsigned int8 stream); 
.................... _bif void set_uart_speed(unsigned int32 baud, unsigned int8 stream, unsigned int32 clock); 
.................... // Constants used in setup_uart() are: 
.................... // FALSE - Turn UART off 
.................... // TRUE  - Turn UART on 
.................... #define UART_ADDRESS           2 
.................... #define UART_DATA              4 
.................... #define UART_AUTODETECT        8 
.................... #define UART_AUTODETECT_NOWAIT 9 
.................... #define UART_WAKEUP_ON_RDA     10 
.................... #define UART_SEND_BREAK        13 
....................  
.................... ////////////////////////////////////////////////////////////////// WDT 
.................... // Watch Dog Timer Functions: SETUP_WDT() and RESTART_WDT() 
.................... // WDT Prototypes: 
.................... _bif void setup_wdt(unsigned int8 mode); 
.................... _bif void restart_wdt(void); 
.................... // Constants used for SETUP_WDT() are: 
.................... #define WDT_ON      1 
.................... #define WDT_OFF     0 
....................  
.................... #define  WDT_1MS    0x002 
.................... #define  WDT_2MS    0x003 
.................... #define  WDT_4MS    0x004 
.................... #define  WDT_8MS    0x005 
.................... #define  WDT_16MS   0x006 
.................... #define  WDT_32MS   0x007 
.................... #define  WDT_64MS   0x008 
.................... #define  WDT_128MS  0x009 
.................... #define  WDT_256MS  0x00A 
.................... #define  WDT_512MS  0x00B 
.................... #define  WDT_1S     0x00C 
.................... #define  WDT_2S     0x00D 
.................... #define  WDT_4S     0x00E 
.................... #define  WDT_8S     0x00F 
.................... #define  WDT_16S    0x010 
.................... #define  WDT_33S    0x011 
.................... #define  WDT_65S    0x030 
.................... #define  WDT_131S   0x031 
....................  
.................... ////////////////////////////////////////////////////////////////// Control 
.................... // Control Functions:  RESET_CPU(), SLEEP(), RESTART_CAUSE() 
.................... // Prototypes: 
.................... _bif unsigned int8 restart_cause(void); 
.................... _bif void reset_cpu(void); 
.................... _bif void sleep(void); 
.................... _bif void sleep(unsigned int8 mode); 
.................... // Constants passed into RESTART_CAUSE() are: 
.................... #define RESTART_POWER_UP      0 
.................... #define RESTART_BROWNOUT      1 
.................... #define RESTART_WATCHDOG      4 
.................... #define RESTART_SOFTWARE      6 
.................... #define RESTART_MCLR          7 
.................... #define RESTART_ILLEGAL_OP    14 
.................... #define RESTART_TRAP_CONFLICT 15 
.................... // 
.................... // Constants passed into SLEEP() are: 
.................... #define SLEEP_FULL      0  // Default 
.................... #define SLEEP_IDLE      1  // Clock and peripherals don't stop 
....................  
.................... ////////////////////////////////////////////////////////////////// INTERNAL RC 
.................... // Oscillator Prototypes: 
.................... _bif void setup_oscillator(unsigned int8 type, unsigned int32 target); 
.................... _bif void setup_oscillator(unsigned int8 type, unsigned int32 target, unsigned int32 source); 
.................... // Constants used in setup_oscillator() are: 
.................... #define OSC_INTERNAL     32 
.................... #define OSC_CRYSTAL       1 
.................... #define OSC_CLOCK         2 
.................... #define OSC_RC            3 
.................... #define OSC_SECONDARY    16 
....................  
.................... ////////////////////////////////////////////////////////////////// Timer 
.................... // Timer Functions: SETUP_TIMERx, GET_TIMERx, GET_TIMERxy, 
.................... // SET_TIMERx, SET_TIMERxy 
.................... // Timer x Prototypes: 
.................... _bif void setup_timer1(unsigned int16 mode); 
.................... _bif void setup_timer1(unsigned int16 mode, unsigned int16 period); 
.................... _bif unsigned int16 get_timer1(void); 
.................... _bif void set_timer1(unsigned int16 value); 
.................... _bif void setup_timer2(unsigned int16 mode); 
.................... _bif void setup_timer2(unsigned int16 mode, unsigned int16 period); 
.................... _bif unsigned int16 get_timer2(void); 
.................... _bif void set_timer2(unsigned int16 value); 
.................... _bif void setup_timer3(unsigned int16 mode); 
.................... _bif void setup_timer3(unsigned int16 mode, unsigned int16 period); 
.................... _bif unsigned int16 get_timer3(void); 
.................... _bif void set_timer3(unsigned int16 value); 
.................... _bif unsigned int32 get_timer23(void); 
.................... _bif void set_timer23(unsigned int32 value); 
.................... _bif void setup_timer4(unsigned int16 mode); 
.................... _bif void setup_timer4(unsigned int16 mode, unsigned int16 period); 
.................... _bif unsigned int16 get_timer4(void); 
.................... _bif void set_timer4(unsigned int16 value); 
.................... _bif void setup_timer5(unsigned int16 mode); 
.................... _bif void setup_timer5(unsigned int16 mode, unsigned int16 period); 
.................... _bif unsigned int16 get_timer5(void); 
.................... _bif void set_timer5(unsigned int16 value); 
.................... _bif unsigned int32 get_timer45(void); 
.................... _bif void set_timer45(unsigned int32 value); 
.................... // Constants used for SETUP_TIMERx() are: 
.................... //      (or (via |) together constants from each group) 
.................... #define TMR_DISABLED 0x0000 
.................... #define TMR_INTERNAL 0x8000 
.................... #define TMR_EXTERNAL 0x8002 
.................... #define TMR_GATE     0x0040 
....................  
.................... #define TMR_DIV_BY_1   0x0000 
.................... #define TMR_DIV_BY_8   0x0010 
.................... #define TMR_DIV_BY_64  0x0020 
.................... #define TMR_DIV_BY_256 0x0030 
.................... #define TMR_32_BIT     0x0008 // Only for even numbered timers 
....................  
.................... #define TMR_HALT_IDLE      0x2000 
.................... #define TMR_CONTINUE_IDLE  0x0000 
....................  
.................... #define T1_EXTERNAL_SYNC  0x8006 //This only applies to Timer1 
.................... #define T1_EXTERNAL_RTC   0xC002 //This only applies to Timer1 
.................... /////////////////////////////////////////////////////////// INPUT CAPTURE 
.................... // Functions: SETUP_CAPTURE, GET_CAPTURE, 
.................... // IC Prototypes: 
.................... _bif void setup_capture(unsigned int8 module, unsigned int16 mode); 
.................... _bif unsigned int16 get_capture(unsigned int8 module); 
.................... _bif unsigned int16 get_capture(unsigned int8 module, int1 wait); 
.................... // Constants used for SETUP_CAPTURE() are: 
.................... #define CAPTURE_OFF               0x0000  // Capture OFF 
.................... #define CAPTURE_EE                0x0001  // Capture Every Edge 
.................... #define CAPTURE_FE                0x0002  // Capture Falling Edge 
.................... #define CAPTURE_RE                0x0003  // Capture Rising Edge 
.................... #define CAPTURE_DIV_4             0x0004  // Capture Every 4th Rising Edge 
.................... #define CAPTURE_DIV_16            0x0005  // Capture Every 16th Rising Edge 
.................... #define CAPTURE_INTERRUPT_ONLY    0x0007  // Interrupt on Rising Edge when in Sleep or Idle 
....................  
.................... // The following defines can be ORed | with above to configure interrupts 
.................... #define INTERRUPT_EVERY_CAPTURE   0x0000  // Interrupt on every capture event 
.................... #define INTERRUPT_SECOND_CAPTURE  0x0020  // Interrupt on every second capture event 
.................... #define INTERRUPT_THIRD_CAPTURE   0x0040  // Interrupt on every third capture event 
.................... #define INTERRUPT_FOURTH_CAPTURE  0x0060  // Interrupt on every fourth capture event 
....................  
.................... // The following defines can be ORed | with above to select timer 
.................... #define CAPTURE_TIMER2            0x0080  // On capture event Timer 2 is captured 
.................... #define CAPTURE_TIMER3            0x0000  // On capture event Timer 3 is captured 
....................  
.................... // The following defines can be ORed | with above to select idle operation mode 
.................... #define CAPTURE_HALT_IDLE         0x2000  // Capture module halts during idle mode 
.................... #define CAPTURE_CONTINUE_IDLE     0x0000  // Capture module continues during idle mode 
....................  
.................... /////////////////////////////////////////////////////////// OUTPUT COMPARE 
.................... // Functions: SETUP_COMPARE, SET_PWM_DUTY, SET_COMPARE_TIME 
.................... // OC Prototypes: 
.................... _bif void setup_compare(unsigned int8 module, unsigned int16 mode); 
.................... _bif void set_pwm_duty(unsigned int8 module, unsigned int16 duty); 
.................... _bif void set_compare_time(unsigned int8 module, unsigned int16 ocr); 
.................... _bif void set_compare_time(unsigned int8 module, unsigned int16 ocr, unsigned int16 ocrs); 
.................... // Constants used for SETUP_COMPARE() are: 
.................... #define COMPARE_OFF               0x0000  // Compare OFF 
.................... #define COMPARE_SET_ON_MATCH      0x0001  // Pin from low to high on match 
.................... #define COMPARE_CLR_ON_MATCH      0x0002  // Pin from high to low on match 
.................... #define COMPARE_TOGGLE            0x0003  // Pin will toggle on every match occurrence 
.................... #define COMPARE_SINGLE_PULSE      0x0004  // Pin will generate single pulse on first match 
.................... #define COMPARE_CONT_PULSE        0x0005  // Pin will pulse for every match 
.................... #define COMPARE_PWM               0x0006  // Compare operates as PWM with fault pin disabled 
.................... #define COMPARE_PWM_FAULT         0x0007  // Compare operates as PWM with fault pin enabled 
....................  
.................... // The following defines can be ORed | with above to select timer 
.................... #define COMPARE_TIMER2            0x0000  // Timer 2 is the base timer 
.................... #define COMPARE_TIMER3            0x0008  // Timer 3 is the base timer 
....................  
.................... // The following defines can be ORed | with above to select idle operation mode 
.................... #define COMPARE_HALT_IDLE         0x2000  // Compare module halts during idle mode 
.................... #define COMPARE_CONTINUE_IDLE     0x0000  // Compare module continues during idle mode 
....................  
.................... ////////////////////////////////////////////////////////////////// SPI 
.................... // SPI Functions: SETUP_SPI, SPI_WRITE, SPI_READ, SPI_DATA_IN 
.................... // SPI Prototypes: 
.................... _bif void setup_spi(unsigned int16 mode); 
.................... _bif void spi_write(unsigned int8 data); 
.................... _bif void spi_write(int1 wait, unsigned int8 data); 
.................... _bif void spi_write_16(unsigned int16 data); 
.................... _bif void spi_write_16(int1 wait, unsigned int16 data); 
.................... _bif unsigned int8 spi_read(void); 
.................... _bif unsigned int8 spi_read(unsigned int8 data); 
.................... _bif unsigned int16 spi_read_16(void); 
.................... _bif unsigned int16 spi_read_16(unsigned int16 data); 
.................... _bif int1 spi_data_in(void); 
.................... _bif void setup_spi2(unsigned int16 mode); 
.................... _bif void spi_write2(unsigned int8 data); 
.................... _bif void spi_write2(int1 wait, unsigned int8 data); 
.................... _bif void spi_write2_16(unsigned int16 data); 
.................... _bif void spi_write2_16(int1 wait, unsigned int16 data); 
.................... _bif unsigned int8 spi_read2(void); 
.................... _bif unsigned int8 spi_read2(unsigned int8 data); 
.................... _bif unsigned int16 spi_read2_16(void); 
.................... _bif unsigned int16 spi_read2_16(unsigned int16 data); 
.................... _bif int1 spi_data_in2(void); 
.................... // Constants used in SETUP_SPI() are: 
.................... //      (or (via |) together constants from each group) 
.................... #define SPI_MASTER                 0x0020 
.................... #define SPI_SLAVE                  0x0000 
....................  
.................... #define SPI_SCK_IDLE_HIGH          0x0040 
.................... #define SPI_SCK_IDLE_LOW           0x0000 
....................  
.................... #define SPI_XMIT_L_TO_H            0x0100 
.................... #define SPI_XMIT_H_TO_L            0x0000 
....................  
.................... #define SPI_MODE_16B               0x0400 
.................... #define SPI_MODE_8B                0x0000 
....................  
.................... #define SPI_SAMPLE_AT_END          0x0200 
.................... #define SPI_SAMPLE_AT_MIDDLE       0x0000 
....................  
.................... #define SPI_SS_ENABLED             0x0000 
.................... #define SPI_SS_DISABLED            0x0080 
....................  
.................... //or (via |) one of the following when operating as MASTER 
.................... #define SPI_CLK_DIV_1              0x001F 
.................... #define SPI_CLK_DIV_2              0x001B 
.................... #define SPI_CLK_DIV_3              0x0017 
.................... #define SPI_CLK_DIV_4              0x001E 
.................... #define SPI_CLK_DIV_5              0x000F 
.................... #define SPI_CLK_DIV_6              0x000B 
.................... #define SPI_CLK_DIV_7              0x0007 
.................... #define SPI_CLK_DIV_8              0x0003 
.................... #define SPI_CLK_DIV_12             0x0016 
.................... #define SPI_CLK_DIV_16             0x001D 
.................... #define SPI_CLK_DIV_20             0x000E 
.................... #define SPI_CLK_DIV_24             0x000A 
.................... #define SPI_CLK_DIV_28             0x0006 
.................... #define SPI_CLK_DIV_32             0x0002 
.................... #define SPI_CLK_DIV_48             0x0015 
.................... #define SPI_CLK_DIV_64             0x001C 
.................... #define SPI_CLK_DIV_80             0x000D 
.................... #define SPI_CLK_DIV_96             0x0009 
.................... #define SPI_CLK_DIV_112            0x0005 
.................... #define SPI_CLK_DIV_128            0x0001 
.................... #define SPI_CLK_DIV_192            0x0014 
.................... #define SPI_CLK_DIV_256            0x0010 
.................... #define SPI_CLK_DIV_320            0x000C 
.................... #define SPI_CLK_DIV_384            0x0008 
.................... #define SPI_CLK_DIV_448            0x0004 
.................... #define SPI_CLK_DIV_512            0x0000 
....................  
.................... //The following defines are provided for compatibility 
.................... #define SPI_L_TO_H         SPI_SCK_IDLE_LOW 
.................... #define SPI_H_TO_L         SPI_SCK_IDLE_HIGH 
....................  
.................... ////////////////////////////////////////////////////////////////// ADC 
.................... // ADC Functions: SETUP_ADC(), SETUP_ADC_PORTS() 
.................... //                SET_ADC_CHANNEL(), READ_ADC() 
.................... // ADC Prototypes: 
.................... _bif void setup_adc(unsigned int32 mode); 
.................... _bif void setup_adc_ports(unsigned int32 pins); 
.................... _bif void setup_adc_ports(unsigned int32 pins, unsigned int16 reference); 
.................... _bif void set_adc_channel(unsigned int8 channel); 
.................... _bif void set_adc_channel(unsigned int8 channel, unsigned int8 neg_channel); 
.................... _bif unsigned int16 read_adc(void); 
.................... _bif unsigned int16 read_adc(unsigned int8 mode); 
.................... _bif int1 adc_done(void); 
.................... // Constants used for SETUP_ADC() are: 
.................... // Clock is at ADCS<5:0> of ADCON3 Reg. (0x02A4) 
.................... // Tad = (Tcy/2)*(ADCS<5:0>+1) 
.................... #define ADC_OFF                 0x10000 
.................... #define ADC_CLOCK                0x0000 
.................... #define ADC_CLOCK_DIV_2          0x0001 
.................... #define ADC_CLOCK_DIV_4          0x0003 
.................... #define ADC_CLOCK_DIV_8          0x0007 
.................... #define ADC_CLOCK_DIV_16         0x000F 
.................... #define ADC_CLOCK_DIV_32         0x001F 
.................... #define ADC_CLOCK_DIV_64         0x003F 
.................... #define ADC_CLOCK_INTERNAL       0x8000     // Internal 
....................  
.................... // One of the following may be OR'ed in with the above using | 
.................... // Auto-Sample Time bits 
.................... #define ADC_TAD_MUL_0            0x1F00 
.................... #define ADC_TAD_MUL_2            0x1D00 
.................... #define ADC_TAD_MUL_4            0x1B00 
.................... #define ADC_TAD_MUL_8            0x1700 
.................... #define ADC_TAD_MUL_16           0x0F00 
.................... #define ADC_TAD_MUL_31           0x0000 
....................  
.................... // Constants used in READ_ADC() are: 
.................... #define ADC_START_AND_READ       0x07 
.................... #define ADC_START_ONLY           0x01 
.................... #define ADC_READ_ONLY            0x06 
....................  
.................... // Constants used in SET_ADC_CHANNEL() second parameter are: 
.................... #define VSS                      0 
....................  
.................... // Constants used in SETUP_ADC_PORTS() are: 
.................... // First argument: 
.................... // OR together desired pins 
.................... #define NO_ANALOGS      0           // None 
.................... #define ALL_ANALOG      0xFFFFFFFF  // All 
.................... #define sAN0      0x00000001 //| A0 
.................... #define sAN1      0x00000002 //| A1 
.................... #define sAN2      0x00000004 //| B0 
.................... #define sAN3      0x00000008 //| B1 
.................... #define sAN4      0x00000010 //| B2 
.................... #define sAN5      0x00000020 //| B3 
.................... #define sAN6      0x00000040 //| C0 
.................... #define sAN7      0x00000080 //| C1 
.................... #define sAN8      0x00000100 //| C2 
....................  
.................... // Optional Second argument: 
.................... #define VSS_VDD            0x0000 // Range 0-Vdd 
.................... #define VREF_VREF          0x6000 // Range VrefL-VrefH 
.................... #define VREF_VDD           0x4000 // Range VrefL-Vdd 
.................... #define VSS_VREF           0x2000 // Range 0-VrefH 
....................  
.................... ////////////////////////////////////////////////////////////////// COMP 
.................... // Comparator Functions: setup_comparator() 
.................... // Comparator Variables: C1OUT, C2OUT 
.................... // Comparator Prototypes: 
.................... _bif void setup_comparator(unsigned int16 mode); 
.................... // Constants used in setup_comparator() are: 
.................... #define NC_NC_NC_NC      0 
.................... #define B2_B3_NC_NC      0x401 
.................... #define B2_VR_NC_NC      0x400 
.................... #define B3_VR_NC_NC      0x402 
.................... #define NC_NC_B0_B1      0x804 
.................... #define NC_NC_B0_VR      0x800 
.................... #define NC_NC_B1_VR      0x808 
.................... #define B2_B3_B0_B1      B2_B3_NC_NC | NC_NC_B0_B1 
.................... #define B2_VR_B0_VR      B2_VR_NC_NC | NC_NC_B0_VR 
.................... #define B3_VR_B1_VR      B3_VR_NC_NC | NC_NC_B1_VR 
....................  
.................... #define C1_INVERT     0x10 
.................... #define C2_INVERT     0x20 
.................... #define C1_OUTPUT     0x100 
.................... #define C2_OUTPUT     0x200 
....................  
.................... #bit C1OUT = getenv("SFR:CMCON").6 
.................... #bit C2OUT = getenv("SFR:CMCON").7 
....................  
.................... ////////////////////////////////////////////////////////////////// VREF 
.................... // VREF Prototypes: 
.................... _bif void setup_vref(unsigned int16 mode); 
.................... // Constants used in setup_vref() are: 
.................... #define VREF_DISABLED  0x0000 
.................... #define VREF_VSS_VDD   0x0080 
.................... #define VREF_ANALOG    0x0090 
.................... // One of the following maybe OR'ed in with the above using | 
.................... #define VREF_HIGH      0x0080 
.................... #define VREF_LOW       0x00A0 
.................... // The following maybe OR'ed in with the above using | 
.................... #define VREF_OUTPUT    0x0040 
.................... // Or (with |) the above with a number 0-15 
....................  
.................... ////////////////////////////////////////////////////////////////// PMP 
.................... // PMP Functions: setup_pmp(), pmp_address(), psp_read(), pmp_read(), 
.................... // psp_write(), pmp_write(), psp_output_full(),psp_input_full(), 
.................... // psp_overflow(), pmp_output_full(), pmp_input_full(), 
.................... // pmp_overflow() 
.................... // PMP Prototypes: 
.................... _bif void setup_pmp(unsigned int32 mode, unsigned int16 address_mask); 
.................... _bif void pmp_address(unsigned int16 address); 
.................... _bif unsigned int8 pmp_read(void); 
.................... _bif void pmp_write(unsigned int8 data); 
.................... _bif int1 pmp_output_full(void); 
.................... _bif int1 pmp_input_full(void); 
.................... _bif int1 pmp_overflow(void); 
.................... _bif void setup_psp(unsigned int32 mode, unsigned int16 address_mask); 
.................... _bif unsigned int8 psp_read(void); 
.................... _bif unsigned int8 psp_read(unsigned int16 address); 
.................... _bif void psp_write(unsigned int8 data); 
.................... _bif void psp_write(unsigned int8 data, unsigned int16 address); 
.................... _bif int1 psp_output_full(void); 
.................... _bif int1 psp_input_full(void); 
.................... _bif int1 psp_overflow(void); 
.................... // Constants used in SETUP_PMP() and SETUP_PSP() are: 
.................... #define PAR_ENABLE                0x8000 
.................... #define PAR_DISABLE               0x0000    // Module enable/disable options 
.................... #define PAR_STOP_IN_IDLE          0x2000 
.................... #define PAR_CONTINUE_IN_IDLE      0x0000 
.................... #define PAR_ADDR_NOT_MULTIPLEXED  0x0000    // Address multiplexing options 
.................... #define PAR_LOW_ADDR_MULTIPLEXED  0x0800    // Address multiplexing options 
.................... #define PAR_FULL_ADDR_MULTIPLEXED 0x1000    // Address multiplexing options 
.................... #define PAR_PTBEEN_ENABLE         0x0400  // Byte Enable Port Enable bit 
.................... #define PAR_PTWREN_ENABLE         0x0200  // Write Enable Strobe bit 
.................... #define PAR_PTRDEN_ENABLE         0x0100  // Read/Write Strobe Port bit 
.................... #define PAR_ALP_ACTIVE_HIGH       0x0020 // Address latch polarity high 
.................... #define PAR_BEP_ACTIVE_HIGH       0x0004 // Byte Enable Polarity 
.................... #define PAR_WRSP_ACTIVE_HIGH      0x0002 // Write strobe Polarity bit 
.................... #define PAR_RDSP_ACTIVE_HIGH      0x0001 // Read strobe Polarity bit 
.................... #define PAR_CS_XX                 0x0000   // Chip select pins used for address 
.................... #define PAR_CS_X1                 0x0008   // Chip select pin 1 used, active high 
.................... #define PAR_CS_X0                 0x0000   // Chip select pin 1 used, active low 
.................... #define PAR_CS_1X                 0x0050   // Chip select pin 2 used, active high 
.................... #define PAR_CS_0X                 0x0040   // Chip select pin 2 used, active low 
.................... #define PAR_CS_00                 0x0080   // Chip select pins 1,2 used, active low 
.................... #define PAR_CS_11                 0x0098   // Chip select pins 1,2 used, active high 
.................... #define PAR_CS_10                 0x0090   // Chip select pins 1,2 used, 1 is active low, 2 is high 
.................... #define PAR_CS_01                 0x0088   // Chip select pins 1,2 used, 1 is active high, 2 is low 
.................... #define PAR_INTR_ON_RW                0x20000000  // Interrupt on read write 
.................... #define PAR_NO_INTR_STALL_ACTIVATED   0x40000000  // No interrupt, processor stall activated 
.................... #define PAR_INTR_ON_3_RW_BUF          0x60000000 // Interrupt on write to Buffer 3 or read from Buffer 3 
.................... #define PAR_PSP_AUTO_INC              0x18000000 // Read write buffers auto increment 
.................... #define PAR_DEC_ADDR                  0x10000000 // Increment the address 
.................... #define PAR_INC_ADDR                  0x08000000 // Decrement the address 
.................... #define PAR_MASTER_MODE_1             0x03000000  // Master mode 1 
.................... #define PAR_MASTER_MODE_2             0x02000000  // Master mode 2 
.................... #define PAR_WAITB1                    0x00000000 // 1 Tcy Wait state for data setup R/W 
.................... #define PAR_WAITB2                    0x00400000 // 2 Tcy Wait state for data setup R/W 
.................... #define PAR_WAITB3                    0x00800000 // 3 Tcy Wait state for data setup R/W 
.................... #define PAR_WAITB4                    0x00C00000 // 4 Tcy Wait state for data setup R/W 
.................... #define PAR_WAITM0                    0x00000000 // 0 wait state for Read to byte 
.................... #define PAR_WAITM1                    0x00040000 // 1 Tcy wait state for Read to byte 
.................... #define PAR_WAITM2                    0x00080000 // 2 Tcy wait state for Read to byte 
.................... #define PAR_WAITM3                    0x000C0000 // 3 Tcy wait state for Read to byte 
.................... #define PAR_WAITM15                   0x003C0000 // 15 wait states 
.................... #define PAR_WAITE1                    0x00000000  // 1 Tcy Wait for data hold after strobe 
.................... #define PAR_WAITE2                    0x00010000 // 2 Tcy Wait for data hold after strobe 
.................... #define PAR_WAITE3                    0x00020000 // 3 Tcy Wait for data hold after strobe 
.................... #define PAR_WAITE4                    0x00030000 // 4 Tcy Wait for data hold after strobe 
....................  
.................... ////////////////////////////////////////////////////////////////// CRC 
.................... // CRC Functions: setup_crc(), crc_init(), crc_calc(), crc_calc8() 
.................... // CRC Prototypes: 
.................... _bif void setup_crc(unsigned int8 poly_terms, ...); 
.................... _bif void crc_init(unsigned int16 value); 
.................... _bif unsigned int16 crc_calc(unsigned int16 data); 
.................... _bif unsigned int16 crc_calc(unsigned int16 *ptr, unsigned int16 count); 
.................... _bif unsigned int8 crc_calc8(unsigned int8 data); 
.................... _bif unsigned int8 crc_calc8(unsigned int8 *ptr, unsigned int16 count); 
....................  
.................... ////////////////////////////////////////////////////////////////// RTC 
.................... // RTC Functions: setup_rtc(), setup_rtc_alarm(), rtc_read(), 
.................... //                rtc_write(), rtc_alarm_read(), rtc_alarm_write() 
.................... // Structure used in read and write functions (pass pointer): 
.................... typedef struct { 
....................    unsigned int8 tm_year; 
....................    unsigned int8 tm_temp;  // Not used by built in functions, place holder only do not use 
....................    unsigned int8 tm_mday; 
....................    unsigned int8 tm_mon; 
....................    unsigned int8 tm_hour; 
....................    unsigned int8 tm_wday; 
....................    unsigned int8 tm_sec; 
....................    unsigned int8 tm_min; 
....................    unsigned int8 tm_isdst; // Not used by built in functions 
.................... } rtc_time_t; 
.................... // RTC Prototypes: 
.................... _bif void setup_rtc(unsigned int16 mode, unsigned int8 calibration); 
.................... _bif void setup_rtc_alarm(unsigned int16 mode, unsigned int16 mask, unsigned int8 repeat); 
.................... _bif void rtc_read(rtc_time_t *time); 
.................... _bif void rtc_write(rtc_time_t *time); 
.................... _bif void rtc_alarm_read(rtc_time_t *time); 
.................... _bif void rtc_alarm_write(rtc_time_t *time); 
.................... // Constants used in setup_rtc() are:  // Second param is calibration 
.................... #define RTC_ENABLE           0x8000 
.................... #define RTC_DISABLE          0 
.................... #define RTC_OUTPUT_SECONDS   0x20400 
.................... #define RTC_OUTPUT_ALARM     0x00400 
.................... // 
.................... // Constants used in setup_rtc_alarm() first param are: 
.................... #define RTC_ALARM_ENABLE     0x8000 
.................... #define RTC_ALARM_DISABLE    0 
.................... #define RTC_CHIME_ENABLE     0x4000 
.................... #define RTC_CHIME_DISABLE    0 
.................... // Constants used in setup_rtc_alarm() second param are:  // Third param is repeat# 
.................... #define RTC_ALARM_HALFSECOND 0x0000 
.................... #define RTC_ALARM_SECOND     0x0400 
.................... #define RTC_ALARM_10_SECONDS 0x0800 
.................... #define RTC_ALARM_MINUTE     0x0C00 
.................... #define RTC_ALARM_10_MINUTES 0x1000 
.................... #define RTC_ALARM_HOUR       0x1400 
.................... #define RTC_ALARM_DAY        0x1800 
.................... #define RTC_ALARM_WEEK       0x1C00 
.................... #define RTC_ALARM_MONTH      0x2000 
.................... #define RTC_ALARM_YEAR       0x2400 
....................  
.................... ////////////////////////////////////////////////////////////////// QEI 
.................... // QEI Functions: setup_qei(), qei_set_count(), qei_get_count(), 
.................... //                qei_status() 
.................... // QEI Prototypes: 
.................... _bif void setup_qei(unsigned int16 mode, unsigned int16 filter, unsigned int16 maxcount); 
.................... _bif void setup_qei(unsigned int8 unit, unsigned int16 mode, unsigned int16 filter, unsigned int16 maxcount); 
.................... _bif void qei_set_count(unsigned int16 count); 
.................... _bif void qei_set_count(unsigned int8 unit, unsigned int16 count); 
.................... _bif unsigned int16 qei_get_count(void); 
.................... _bif unsigned int16 qei_get_count(unsigned int8 unit); 
.................... _bif unsigned int16 qei_status(void); 
.................... _bif unsigned int16 qei_status(unsigned int8 unit); 
.................... // Constants used in setup_qei() first param are: 
.................... #define QEI_DISABLED        0 
.................... #define QEI_MODE_X2         0x0400 
.................... #define QEI_MODE_X4         0x0600 
.................... #define QEI_MODE_TIMER      0x0100 
.................... #define QEI_STOP_WHEN_IDLE  0x2000 
.................... #define QEI_SWAP_AB         0x0080 
.................... #define QEI_OUTPUT_ENABLE   0x0040 
.................... #define QEI_RESET_WHEN_MAXCOUNT  0x0100 
.................... #define QEI_RESET_WHEN_IDX_PULSE 0x0004 
.................... #define QEI_TIMER_GATED      0x0020 
.................... #define QEI_TIMER_INTERNAL   0x0000 
.................... #define QEI_TIMER_EXTERNAL   0x0002 
.................... #define QEI_TIMER_DIV_BY_1   0x0000 
.................... #define QEI_TIMER_DIV_BY_8   0x0008 
.................... #define QEI_TIMER_DIV_BY_64  0x0010 
.................... #define QEI_TIMER_DIV_BY_256 0x0018 
.................... // Constants used in setup_qei() second param are:   // Third param is MAXCOUNT 
.................... #define QEI_FILTER_DIV_1     0x0000 
.................... #define QEI_FILTER_DIV_2     0x0010 
.................... #define QEI_FILTER_DIV_4     0x0020 
.................... #define QEI_FILTER_DIV_16    0x0030 
.................... #define QEI_FILTER_DIV_32    0x0040 
.................... #define QEI_FILTER_DIV_64    0x0050 
.................... #define QEI_FILTER_DIV_128   0x0060 
.................... #define QEI_FILTER_DIV_256   0x0070 
.................... #define QEI_FILTER_OUTPUT    0x0080 
.................... #define QEI_NO_ERROR_INTS    0x0100 
.................... #define QEI_IDX_WHEN_A0      0x0000  // for 2X mode 
.................... #define QEI_IDX_WHEN_A1      0x0200  // for 2X mode 
.................... #define QEI_IDX_WHEN_B0      0x0400  // for 2X mode 
.................... #define QEI_IDX_WHEN_B1      0x0600  // for 2X mode 
.................... #define QEI_IDX_WHEN_A0_B0   0x0000  // for 4X mode 
.................... #define QEI_IDX_WHEN_A1_B0   0x0200  // for 4X mode 
.................... #define QEI_IDX_WHEN_A0_B1   0x0400  // for 4X mode 
.................... #define QEI_IDX_WHEN_A1_B1   0x0600  // for 4X mode 
.................... // Constants returned from qei_status() are: 
.................... #define QEI_POS_ERROR        0x8000 
.................... #define QEI_FORWARD          0x0800 
.................... #define QEI_INDEX_PIN        0x1000 
....................  
.................... ////////////////////////////////////////////////////////////////// MOTOR PWM 
.................... // MPWM Functions: setup_motor_pwm(), set_motor_unit(), 
.................... //                 set_motor_pwm_duty(), set_motor_pwm_event(), 
.................... //                 get_motor_pwm_count() 
.................... // MPWM Prototypes: 
.................... _bif void setup_motor_pwm(unsigned int8 pwm, unsigned int32 mode, unsigned int32 timebase); 
.................... _bif void setup_motor_pwm(unsigned int8 pwm, unsigned int32 mode, unsigned int8 prescale, unsigned int8 postscale, unsigned int16 period); 
.................... _bif void set_motor_unit(unsigned int8 pwm, unsigned int8 pin_pair, unsigned int16 mode, unsigned int8 active_deadtime, unsigned int8 inactive_deadtime); 
.................... _bif void set_motor_pwm_duty(unsigned int8 pwm, unsigned int8 pin_pair, unsigned int16 duty); 
.................... _bif void set_motor_pmw_event(unsigned int8, signed int16 time); 
.................... _bif unsigned int16 get_motor_pwm_count(unsigned int8 pwm); 
.................... // Constants used in setup_motor_pwm() second param are (first param is unit number 1,2...): 
.................... #define MPWM_DISABLED          0 
.................... #define MPWM_FREE_RUN          0x8000 
.................... #define MPWM_SINGLE_PULSE      0x8001 
.................... #define MPWM_UP_DOWN           0x8002 
.................... #define MPWM_UP_DOWN_WITH_INTS 0x8003 
.................... // OR in any of the following: 
.................... #define MPWM_HALT_WHEN_IDLE            0x2000 
.................... #define MPWM_DUTY_UPDATES_IMMEADIATE  0x40000 
.................... #define MPWM_SYNC_OVERRIDES           0x20000 
.................... #define MPWM_DISABLE_UPDATES          0x10000 
.................... #define MPWM_LATCH_FAULTS            0x100000 
....................  
.................... // Constants used in set_motor_unit() third param are:  (first param is unit number 1,2... and second param is pwm pin pair 1,2,3 or 4) 
.................... #define MPWM_INDEPENDENT     0x0001 
.................... #define MPWM_ENABLE          0x0006  // both H and L 
.................... #define MPWM_ENABLE_H        0x0004 
.................... #define MPWM_ENABLE_L        0x0002 
....................  
.................... #define MPWM_FORCE_L_0       0x0010 
.................... #define MPWM_FORCE_L_1       0x0050 
.................... #define MPWM_FORCE_H_0       0x0020 
.................... #define MPWM_FORCE_H_1       0x00A0 
....................  
.................... #define MPWM_FAULTA_LA_HA     0x0700 
.................... #define MPWM_FAULTA_LA_HI     0x0500 
.................... #define MPWM_FAULTA_LI_HA     0x0600 
.................... #define MPWM_FAULTA_LI_HI     0x0400 
.................... #define MPWM_FAULTB_LA_HA     0x7000 
.................... #define MPWM_FAULTB_LA_HI     0x5000 
.................... #define MPWM_FAULTB_LI_HA     0x6000 
.................... #define MPWM_FAULTB_LI_HI     0x4000 
.................... #define MPWM_FAULT_NO_CHANGE 0x0000 
....................  
.................... ////////////////////////////////////////////////////////////////// DCI 
.................... // DCI Functions: setup_dci(), dci_start(), dci_read(), dci_write(), 
.................... //                dci_data_received(), dci_transmit_ready() 
.................... // DCI Prototypes: 
.................... _bif void setup_dci(unsigned int16 mode, unsigned int16 size, unsigned int16 receive_slot, unsigned int16 transmit_slot, unsigned int16 sample_rate); 
.................... _bif void dci_start(void); 
.................... _bif signed int16 dci_read(void); 
.................... _bif void dci_write(signed int16); 
.................... _bif int1 dci_data_received(void); 
.................... _bif int1 dci_transmit_ready(void); 
.................... // Constants used in setup_dci() first param are: 
.................... #define MULTICHANNEL_MODE  0x0000 
.................... #define I2S_MODE           0x0001 
.................... #define AC97_16BIT_MODE    0x0002 
.................... #define AC97_20BIT_MODE    0x0003 
....................  
.................... #define JUSTIFY_DATA       0x0020 //Start data transmission on the same clock cycle as COFS pulses (multichannel) 
.................... #define MULTI_DEVICE_BUS   0x0040 //Tri-states the CSDO pin during unused time slots, normally drives '0' 
....................  
.................... #define UNDERFLOW_LAST     0x0080 //Transmits the last written value to the dci when data underflow occurs. Default is undeflow silence. 
.................... #define UNDERFLOW_SILENCE  0x0000 //Transmit '0's on data undeflow. This will cause a clicking noise if you are underflowing data while outputing to a codec. 
....................  
.................... #define DCI_SLAVE          0x0100 //Default is master 
.................... #define DCI_MASTER         0x0000 
....................  
.................... #define SAMPLE_FALLING_EDGE 0x0000 //Default is Sample on the rising edge of the clock 
.................... #define SAMPLE_RISING_EDGE 0x0200 
....................  
.................... #define DCI_CLOCK_INPUT    0x0400 //SCLK is an input (supplied by codec or external source) 
.................... #define DCI_CLOCK_OUTPUT   0x0000 //Default is clock output 
....................  
.................... #define ENABLE_LOOPBACK    0x0800 //Connect the CSDI/CSDO internally; loops all of the sound back onto the bus 
....................  
.................... #define CODEC_MULTICHANNEL  0x0000  //enables multichannel (generic) codec support 
.................... #define CODEC_I2S           0x0001  //enables the I2S protocol 
.................... #define CODEC_AC16          0x0002  //enables the AC-16 protocol, setupCodecTransmission has no effect 
.................... #define CODEC_AC20          0x0003  //enables the AC-20 protocol, setupCodecTransmission has no effect 
....................  
.................... #define BUS_MASTER          0x0000  //designates this device as the bus master 
.................... #define BUS_SLAVE           0x0300  //designates this device as a slave on a bus controlled by another codec 
....................  
.................... #define TRISTATE_BUS        0x0040        //when in master mode, the module will be in high impedance 
....................                                     //during disabled frames (default drives 0's onto bus) 
.................... #define SYNC_COFS_DATA_PULSE 0x0020 //signifies that data starts transmitting on the same SCK pulse as the edge of the COFS pulse 
....................                                     //(default data starts on the clock after the rising edge of COFS 
.................... /* Determines when a sample is taken */ 
.................... #define SAMPLE_RISING        0x0200 //sample data on the rising edge of the clock 
.................... #define SAMPLE_FALLING       0x0000 //sample data on the falling edge of the clock 
....................  
.................... // Constants used in setup_dci() second param are: 
.................... #define DCI_4BIT_WORD      0x0003 
.................... #define DCI_5BIT_WORD      0x0004 
.................... #define DCI_6BIT_WORD      0x0005 
.................... #define DCI_7BIT_WORD      0x0006 
.................... #define DCI_8BIT_WORD      0x0007 
.................... #define DCI_9BIT_WORD      0x0008 
.................... #define DCI_10BIT_WORD     0x0009 
.................... #define DCI_11BIT_WORD     0x000A 
.................... #define DCI_12BIT_WORD     0x000B 
.................... #define DCI_13BIT_WORD     0x000C 
.................... #define DCI_14BIT_WORD     0x000D 
.................... #define DCI_15BIT_WORD     0x000E 
.................... #define DCI_16BIT_WORD     0x000F 
....................  
.................... #define DCI_1WORD_FRAME    0x0000 
.................... #define DCI_2WORD_FRAME    0x0010 << 1 
.................... #define DCI_3WORD_FRAME    0x0020 << 1 
.................... #define DCI_4WORD_FRAME    0x0030 << 1 
.................... #define DCI_5WORD_FRAME    0x0040 << 1 
.................... #define DCI_6WORD_FRAME    0x0050 << 1 
.................... #define DCI_7WORD_FRAME    0x0060 << 1 
.................... #define DCI_8WORD_FRAME    0x0070 << 1 
.................... #define DCI_9WORD_FRAME    0x0080 << 1 
.................... #define DCI_10WORD_FRAME   0x0090 << 1 
.................... #define DCI_11WORD_FRAME   0x00A0 << 1 
.................... #define DCI_12WORD_FRAME   0x00B0 << 1 
.................... #define DCI_13WORD_FRAME   0x00C0 << 1 
.................... #define DCI_14WORD_FRAME   0x00D0 << 1 
.................... #define DCI_15WORD_FRAME   0x00E0 << 1 
.................... #define DCI_16WORD_FRAME   0x00F0 << 1 
....................  
.................... #define DCI_1WORD_INTERRUPT 0x0000 
.................... #define DCI_2WORD_INTERRUPT 0x0400 
.................... #define DCI_3WORD_INTERRUPT 0x0800 
.................... #define DCI_4WORD_INTERRUPT 0x0C00 
....................  
.................... // Constants used in setup_dci() third param are: 
.................... #define RECEIVE_NONE    0x0000 
.................... #define RECEIVE_ALL     0xFFFF 
.................... #define RECEIVE_SLOT0   0x0001 
.................... #define RECEIVE_SLOT1   0x0002 
.................... #define RECEIVE_SLOT2   0x0004 
.................... #define RECEIVE_SLOT3   0x0008 
.................... #define RECEIVE_SLOT4   0x0010 
.................... #define RECEIVE_SLOT5   0x0020 
.................... #define RECEIVE_SLOT6   0x0040 
.................... #define RECEIVE_SLOT7   0x0080 
.................... #define RECEIVE_SLOT8   0x0100 
.................... #define RECEIVE_SLOT9   0x0200 
.................... #define RECEIVE_SLOT10  0x0400 
.................... #define RECEIVE_SLOT11  0x0800 
.................... #define RECEIVE_SLOT12  0x1000 
.................... #define RECEIVE_SLOT13  0x2000 
.................... #define RECEIVE_SLOT14  0x4000 
.................... #define RECEIVE_SLOT15  0x8000 
....................  
.................... // Constants used in setup_dci() forth param are: 
.................... #define TRANSMIT_NONE   0x0000 
.................... #define TRANSMIT_ALL    0xFFFF 
.................... #define TRANSMIT_SLOT0  0x0001 
.................... #define TRANSMIT_SLOT1  0x0002 
.................... #define TRANSMIT_SLOT2  0x0004 
.................... #define TRANSMIT_SLOT3  0x0008 
.................... #define TRANSMIT_SLOT4  0x0010 
.................... #define TRANSMIT_SLOT5  0x0020 
.................... #define TRANSMIT_SLOT6  0x0040 
.................... #define TRANSMIT_SLOT7  0x0080 
.................... #define TRANSMIT_SLOT8  0x0100 
.................... #define TRANSMIT_SLOT9  0x0200 
.................... #define TRANSMIT_SLOT10 0x0400 
.................... #define TRANSMIT_SLOT11 0x0800 
.................... #define TRANSMIT_SLOT12 0x1000 
.................... #define TRANSMIT_SLOT13 0x2000 
.................... #define TRANSMIT_SLOT14 0x4000 
.................... #define TRANSMIT_SLOT15 0x8000 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// DMA 
.................... // DMA Functions: setup_dma(), dma_start(), dma_status() 
.................... // DMA Prototypes: 
.................... _bif void setup_dma(unsigned int8 channel, unsigned int32 pheripheral, unsigned int8 mode); 
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa); 
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 count); 
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 addressb); 
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 addressb, unsigned int16 count); 
.................... _bif unsigned int8 dma_status(unsigned int8 channel); 
.................... // Constants used in setup_dma() second param are: 
.................... #define DMA_IN_SPI1      (0x0A0000|getenv("sfr:SPI1BUF")) 
.................... #define DMA_OUT_SPI1     (0x8A0000|getenv("sfr:SPI1BUF")) 
.................... #define DMA_IN_SPI2      (0x210000|getenv("sfr:SPI2BUF")) 
.................... #define DMA_OUT_SPI2     (0xA10000|getenv("sfr:SPI2BUF")) 
.................... #define DMA_IN_UART1     (0x0B0000|getenv("sfr:U1RXREG")) 
.................... #define DMA_OUT_UART1    (0x8C0000|getenv("sfr:U1TXREG")) 
.................... #define DMA_IN_UART2     (0x1E0000|getenv("sfr:U2RXREG")) 
.................... #define DMA_OUT_UART2    (0x9F0000|getenv("sfr:U2TXREG")) 
.................... #define DMA_IN_ADC1      (0x0D0000|getenv("sfr:ADC1BUF0")) 
.................... ////////////////////////////////////////////////////////////////// DAC 
.................... // Digital to Analog Functions: SETUP_DAC(), DAC_WRITE() 
.................... // DAC Prototypes: 
.................... _bif void setup_dac(unsigned int32 mode); 
.................... _bif void setup_dac(unsigned int32 mode, unsigned int8 divisor); 
.................... _bif void dac_write(unsigned int8 channel, unsigned value); 
.................... // Constants used in SETUP_DAC() are: 
.................... #define DAC_OFF  0 
.................... #define DAC_RIGHT_ON   0x00808000 
.................... #define DAC_LEFT_ON    0x80008000 
.................... #define DAC_RIGHT_MIDPOINT 0x00A08000 
.................... #define DAC_LEFT_MIDPOINT  0xA0008000 
.................... #define DAC_SIGNED   0x100 
.................... #define DAC_SLEEP_ON 0x1000 
.................... #define DAC_IDLE_OFF 0x2000 
.................... // Constants used as the first param in DAC_WRITE() are: 
.................... #define DAC_DEFAULT  0 
.................... #define DAC_RIGHT    1 
.................... #define DAC_LEFT     2 
....................  
.................... #define DMA_IN_ECAN1     (0x220000|getenv("sfr:C1RXD")) 
.................... #define DMA_OUT_ECAN1    (0xC60000|getenv("sfr:C1TXD")) 
.................... #define DMA_INT0         0x000000 // or in direction and perif address 
.................... #define DMA_IC1          0x010000 // or in direction and perif address 
.................... #define DMA_IN_IC1       (0x010000|getenv("sfr:IC1BUF")) 
.................... #define DMA_IC2          0x050000 // or in direction and perif address 
.................... #define DMA_IN_IC2       (0x050000|getenv("sfr:IC2BUF")) 
.................... #define DMA_OC1          0x020000 // or in direction and perif address 
.................... #define DMA_OC2          0x060000 // or in direction and perif address 
.................... #define DMA_TIMER2       0x070000 // or in direction and perif address 
.................... #define DMA_TIMER3       0x080000 // or in direction and perif address 
.................... #define DMA_OUT_DCI      (0xBC0000|getenv("sfr:TXBUF0")) 
.................... #define DMA_IN_DCI       (0x3C0000|getenv("sfr:RXBUF0")) 
.................... #define DMA_OUT_DACR     (0xCE0000|getenv("sfr:DAC1RDAT")) 
.................... #define DMA_OUT_DACL     (0xCF0000|getenv("sfr:DAC1LDAT")) 
.................... #define DMA_IN          0x00 
.................... #define DMA_OUT         0x800000 
.................... // Constants used in setup_dma() third param are: 
.................... #define DMA_BYTE        0x40 
.................... #define DMA_WORD        0x00  // default 
.................... #define DMA_HALF_INT    0x10  // interrupt when half full 
.................... #define DMA_WRITE_NULL  0x08 
.................... // Constants used in dma_start() second param are: 
.................... #define DMA_CONTINOUS   0x00 
.................... #define DMA_ONE_SHOT    0x01 
.................... #define DMA_PING_PONG   0x02 
.................... #define DMA_NO_INC      0x10 
.................... #define DMA_PERIF_ADDR  0x20 // Device supplies address 
.................... #define DMA_FORCE_NOW  0x100 
.................... // Constants returned from dma_status() are: 
.................... #define DMA_IN_ERROR    0x01 
.................... #define DMA_OUT_ERROR   0x02 
.................... #define DMA_B_SELECT    0x04 
....................  
.................... ////////////////////////////////////////////////////////////////// BIF 
.................... // Built In Functions Prototypes 
.................... // 
.................... // Math Prototypes: 
.................... _bif signed int8 abs(signed int8 x); 
.................... _bif signed int16 abs(signed int16 x); 
.................... _bif signed int32 abs(signed int32 x); 
.................... _bif float32 abs(float32 x); 
.................... _bif unsigned int16 _mul(unsigned int8, unsigned int8); 
.................... _bif signed int16 _mul(signed int8, signed int8); 
.................... _bif unsigned int32 _mul(unsigned int16, unsigned int16); 
.................... _bif signed int32 _mul(signed int16, signed int16); 
.................... _bif signed int48 abs(signed int48 x); 
.................... _bif signed int64 abs(signed int64 x); 
.................... _bif float48 abs(float48 x); 
.................... _bif float64 abs(float64 x); 
.................... _bif unsigned int64 _mul(unsigned int32, unsigned int32); 
.................... _bif signed int64 _mul(signed int32, signed int32); 
.................... _bif unsigned int64 _mul(unsigned int48, unsigned int48); 
.................... _bif signed int64 _mul(signed int48, signed int48); 
....................  
.................... // Memory Manipulation Prototypes: 
.................... _bif void strcpy(char* dest, char* src); 
.................... _bif void memset(unsigned int8* destination, unsigned int8 value, unsigned int16 num); 
.................... _bif void memcpy(unsigned int8* destination, unsigned int8* source, unsigned int16 num); 
....................  
.................... // Data Manipulators Prototypes: 
.................... _bif int1 shift_left(unsigned int8* address, unsigned int8 bytes, int1 value); 
.................... _bif int1 shift_right(unsigned int8* address, unsigned int8 bytes, int1 value); 
.................... _bif void rotate_left(unsigned int8* address, unsigned int8 bytes); 
.................... _bif void rotate_right(unsigned int8* address, unsigned int8 bytes); 
.................... _bif void swap(unsigned int8 value); 
.................... _bif unsigned int8 make8(unsigned int16 var, unsigned int8 offset); 
.................... _bif unsigned int8 make8(unsigned int32 var, unsigned int8 offset); 
.................... _bif unsigned int16 make16(unsigned int8 varhigh, unsigned int8 varlow); 
.................... _bif unsigned int32 make32(unsigned int16 var1); 
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int16 var2); 
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int8 var2); 
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int8 var2, unsigned int8 var3); 
.................... _bif unsigned int32 make32(unsigned int8 var1); 
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2); 
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int8 var3); 
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int8 var3, unsigned int8 var4); 
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int16 var2); 
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int16 var2, unsigned int8 var3); 
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int16 var3); 
.................... _bif void bit_set(unsigned int8 var, unsigned int8 bit); 
.................... _bif void bit_set(unsigned int16 var, unsigned int8 bit); 
.................... _bif void bit_set(unsigned int32 var, unsigned int8 bit); 
.................... _bif void bit_clear(unsigned int8 var, unsigned int8 bit); 
.................... _bif void bit_clear(unsigned int16 var, unsigned int8 bit); 
.................... _bif void bit_clear(unsigned int32 var, unsigned int8 bit); 
.................... _bif int1 bit_test(unsigned int8 var, unsigned int8 bit); 
.................... _bif int1 bit_test(unsigned int16 var, unsigned int8 bit); 
.................... _bif int1 bit_test(unsigned int32 var, unsigned int8 bit); 
.................... _bif void bit_set(unsigned int48 var, unsigned int8 bit); 
.................... _bif void bit_set(unsigned int64 var, unsigned int8 bit); 
.................... _bif void bit_clear(unsigned int48 var, unsigned int8 bit); 
.................... _bif void bit_clear(unsigned int64 var, unsigned int8 bit); 
.................... _bif int1 bit_test(unsigned int48 var, unsigned int8 bit); 
.................... _bif int1 bit_test(unsigned int64 var, unsigned int8 bit); 
.................... _bif unsigned int8 bit_first(int1 value, unsigned int16 var); 
.................... _bif unsigned int8 bit_last(int16 var); 
.................... _bif unsigned int8 bit_last(int1 value, int16 var); 
....................  
.................... // #use delay() Prototypes: 
.................... _bif void delay_cycles(unsigned int16 count); 
.................... _bif void delay_ms(unsigned int16 time); 
.................... _bif void delay_us(unsigned int16 time); 
....................  
.................... // #use rs232() Prototypes: 
.................... _bif void putchar(char cdata); 
.................... _bif void putchar(char cdata, unsigned int8 stream); 
.................... _bif void puts(char* string); 
.................... _bif void puts(char* string, unsigned int8 stream); 
.................... _bif char getch(void); 
.................... _bif char getch(unsigned int8 stream); 
.................... _bif void gets(char* string); 
.................... _bif void gets(char* string, unsigned int8 stream); 
.................... _bif int1 kbhit(void); 
.................... _bif int1 kbhit(unsigned int8 stream); 
.................... _bif void printf(char* string, ...); 
.................... _bif void fprintf(unsigned int8 stream, char* string, ...); 
.................... _bif void putc_send(void); 
.................... _bif void fputc_send(unsigned int8 stream); 
.................... _bif int1 rcv_buffer_full(void); 
.................... _bif int1 rcv_buffer_full(unsigned int8 stream); 
.................... _bif unsigned int16 rcv_buffer_bytes(void); 
.................... _bif unsigned int16 rcv_buffer_bytes(unsigned int8 stream); 
.................... _bif int1 tx_buffer_full(void); 
.................... _bif int1 tx_buffer_full(unsigned int8 stream); 
.................... _bif unsigned int16 tx_buffer_bytes(void); 
.................... _bif unsigned int16 tx_buffer_bytes(unsigned int8 stream); 
....................  
.................... // #use i2c() Prototypes: 
.................... _bif unsigned int8 i2c_read(void); 
.................... _bif unsigned int8 i2c_read(unsigned int8 stream); 
.................... _bif unsigned int8 i2c_read(unsigned int8 stream, int1 ack); 
.................... _bif int1 i2c_write(unsigned int8 data); 
.................... _bif int1 i2c_write(unsigned int8 stream, unsigned int8 data); 
.................... _bif void i2c_start(void); 
.................... _bif void i2c_start(unsigned int8 stream); 
.................... _bif void i2c_start(unsigned int8 stream, unsigned int8 restart); 
.................... _bif void i2c_stop(void); 
.................... _bif void i2c_stop(unsigned int8 stream); 
.................... _bif int8 i2c_isr_state(void); 
.................... _bif void i2c_slaveaddr(unsigned int8 addr); 
.................... _bif void i2c_slaveaddr(unsigned int8 stream, unsigned int8 addr); 
.................... _bif int1 i2c_poll(void); 
.................... _bif int1 i2c_poll(unsigned int8 stream); 
.................... _bif void i2c_init(unsigned int32 baud); 
.................... _bif void i2c_init(unsigned int8 stream, unsigned int32 baud); 
....................  
.................... // #use spi() Prototypes: 
.................... _bif unsigned int8 spi_xfer(void); 
.................... _bif unsigned int16 spi_xfer(void); 
.................... _bif unsigned int32 spi_xfer(void); 
.................... _bif unsigned int8 spi_xfer(unsigned int8 data); 
.................... _bif unsigned int16 spi_xfer(unsigned int16 data); 
.................... _bif unsigned int32 spi_xfer(unsigned int32 data); 
.................... _bif unsigned int8 spi_xfer(unsigned int8 stream, unsigned int8 data); 
.................... _bif unsigned int16 spi_xfer(unsigned int8 stream, unsigned int16 data); 
.................... _bif unsigned int32 spi_xfer(unsigned int8 stream, unsigned int32 data); 
.................... _bif unsigned int8 spi_xfer(unsigned int8 stream, unsigned int8 data, unsigned int8 bits); 
.................... _bif unsigned int16 spi_xfer(unsigned int8 stream, unsigned int16 data, unsigned int8 bits); 
.................... _bif unsigned int32 spi_xfer(unsigned int8 stream, unsigned int32 data, unsigned int8 bits); 
.................... _bif void spi_init(unsigned int32 baud); 
.................... _bif void spi_init(unsigned int8 stream, unsigned int32 baud); 
.................... _bif void spi_speed(unsigned int32 baud); 
.................... _bif void spi_speed(unsigned int8 stream, unsigned int32 baud); 
.................... _bif void spi_speed(unsigned int8 stream, unsigned int32 baud, unsigned int32 clock); 
.................... _bif void spi_prewrite(unsigned int8 data); 
.................... _bif void spi_prewrite(unsigned int16 data); 
.................... _bif void spi_prewrite(unsigned int32 data); 
.................... _bif void spi_prewrite(unsigned int8, unsigned int8 data); 
.................... _bif void spi_prewrite(unsigned int8, unsigned int16 data); 
.................... _bif void spi_prewrite(unsigned int8, unsigned int32 data); 
.................... _bif unsigned int8 spi_xfer_in(void); 
.................... _bif unsigned int16 spi_xfer_in(void); 
.................... _bif unsigned int32 spi_xfer_in(void); 
.................... _bif unsigned int8 spi_xfer_in(unsigned int8 bits); 
.................... _bif unsigned int16 spi_xfer_in(unsigned int8 bits); 
.................... _bif unsigned int32 spi_xfer_in(unsigned int8 bits); 
.................... _bif unsigned int8 spi_xfer_in(unsigned int8 stream, unsigned int8 bits); 
.................... _bif unsigned int16 spi_xfer_in(unsigned int8 stream, unsigned int8 bits); 
.................... _bif unsigned int32 spi_xfer_in(unsigned int8 stream, unsigned int8 bits); 
....................  
.................... // #use rtos() Prototypes: 
.................... _bif void rtos_run(void); 
.................... _bif void rtos_yield(void); 
.................... _bif void rtos_enable(unsigned int8 task); 
.................... _bif void rtos_disable(unsigned int8 task); 
.................... _bif void rtos_terminate(void); 
.................... _bif void rtos_await(int1 flag); 
.................... _bif void rtos_wait(unsigned int8 sem); 
.................... _bif void rtos_signal(unsigned int8 sem); 
.................... _bif void rtos_msg_send(unsigned int8 task, unsigned int8 msg); 
.................... _bif unsigned int8 rtos_msg_read(void); 
.................... _bif unsigned int8 rtos_msg_poll(void); 
.................... _bif int1 rtos_overrun(unsigned int8 task); 
.................... _bif void rtos_stats(unsigned int8 task, unsigned int8* stat); 
....................  
.................... // #use timer() Prototypes: 
.................... _bif unsigned int8 get_ticks(void); 
.................... _bif unsigned int16 get_ticks(void); 
.................... _bif unsigned int32 get_ticks(void); 
.................... _bif unsigned int64 get_ticks(void); 
.................... _bif unsigned int8 get_ticks(unsigned int8 stream); 
.................... _bif unsigned int16 get_ticks(unsigned int8 stream); 
.................... _bif unsigned int32 get_ticks(unsigned int8 stream); 
.................... _bif unsigned int64 get_ticks(unsigned int8 stream); 
.................... _bif void set_ticks(unsigned int8 value); 
.................... _bif void set_ticks(unsigned int16 value); 
.................... _bif void set_ticks(unsigned int32 value); 
.................... _bif void set_ticks(unsigned int64 value); 
.................... _bif void set_ticks(unsigned int8 stream, unsigned int8 value); 
.................... _bif void set_ticks(unsigned int8 stream, unsigned int16 value); 
.................... _bif void set_ticks(unsigned int8 stream, unsigned int32 value); 
.................... _bif void set_ticks(unsigned int8 stream, unsigned int64 value); 
....................  
.................... // #use pwm() Prototypes: 
.................... _bif void pwm_on(void); 
.................... _bif void pwm_on(unsigned int8 stream); 
.................... _bif void pwm_off(void); 
.................... _bif void pwm_off(unsigned int8 stream); 
.................... _bif void pwm_set_duty(unsigned int16 duty); 
.................... _bif void pwm_set_duty(unsigned int8 stream, unsigned int16 duty); 
.................... _bif void pwm_set_duty_percent(unsigned int16 percent); 
.................... _bif void pwm_set_duty_percent(unsigned int8 stream, unsigned int16 percent); 
.................... _bif void pwm_set_frequency(unsigned int32 frequency); 
.................... _bif void pwm_set_frequency(unsigned int8 stream, unsigned int32 frequency); 
....................  
.................... // #use capture() Prototypes: 
.................... _bif unsigned int16 get_capture_time(void); 
.................... _bif unsigned int16 get_capture_time(unsigned int8 stream); 
.................... _bif int1 get_capture_event(void); 
.................... _bif int1 get_capture_event(unsigned int8 stream); 
....................  
.................... // Environment Prototypes: 
.................... //_bif unsigned int8 getenv(char* cstring); 
....................  
.................... // Address Prototypes: 
.................... #ifndef __ADDRESS__ 
.................... #define __ADDRESS__ unsigned int32 
.................... #endif 
.................... _bif void goto_address(__ADDRESS__ address); 
.................... _bif __ADDRESS__ label_address(__ADDRESS__ label); 
....................  
.................... // Program Memory Prototypes: 
.................... _bif void read_program_memory(__ADDRESS__ address, unsigned int8* dataptr, unsigned int16 count); 
.................... _bif void erase_program_memory(__ADDRESS__ address); 
.................... _bif void write_program_memory(__ADDRESS__ address, unsigned int8* dataptr, unsigned int16 count); 
.................... _bif void read_configuration_memory(unsigned int8* dataptr, unsigned int8 count); 
.................... _bif void write_configuration_memory(unsigned int8* dataptr, unsigned int8 count); 
....................  
.................... ////////////////////////////////////////////////////////////////// INT 
.................... // Interrupt Functions: ENABLE_INTERRUPTS(), DISABLE_INTERRUPTS(), 
.................... //                      CLEAR_INTERRUPT(), INTERRUPT_ACTIVE(), 
.................... //                      EXT_INT_EDGE() 
.................... // INT Prototypes: 
.................... _bif void enable_interrupts(unsigned int16 interrupt); 
.................... _bif void disable_interrupts(unsigned int16 interrupt); 
.................... _bif void clear_interrupt(unsigned int16 interrupt); 
.................... _bif int1 interrupt_active(unsigned int16 interrupt); 
.................... _bif int1 interrupt_enabled(unsigned int16 interrupt); 
.................... _bif void ext_int_edge(unsigned int8 source, unsigned int8 edge); 
.................... _bif void jump_to_isr(unsigned int16 address); 
.................... // Constants used in EXT_INT_EDGE() are: 
.................... #define L_TO_H              0x40 
.................... #define H_TO_L                 0 
.................... // 
.................... // Constants used in other interrupt functions are: 
.................... #define INTR_GLOBAL               0x400 
.................... #define GLOBAL                    0x400  // For compatibility with PIC16/18 
.................... #define INTR_NORMAL               0x100 
.................... #define INTR_ALTERNATE            0x200 
.................... #define INTR_LEVEL0               0x500 
.................... #define INTR_LEVEL1               0x501 
.................... #define INTR_LEVEL2               0x502 
.................... #define INTR_LEVEL3               0x503 
.................... #define INTR_LEVEL4               0x504 
.................... #define INTR_LEVEL5               0x505 
.................... #define INTR_LEVEL6               0x506 
.................... #define INTR_LEVEL7               0x507 
....................  
.................... #define INTR_CN_PIN              0x8000  // or in a PIN_xx constant 
....................  
.................... #define INT_OSCFAIL               1 
.................... #define INT_ADDRERR               2 
.................... #define INT_STACKERR              3 
.................... #define INT_MATHERR               4 
.................... #define INT_DMAERR                5 
.................... #define INT_EXT0                  6 
.................... #define INT_IC1                   7 
.................... #define INT_OC1                   8 
.................... #define INT_TIMER1                9 
.................... #define INT_DMA0                  69 
.................... #define INT_IC2                   70 
.................... #define INT_OC2                   71 
.................... #define INT_TIMER2                72 
.................... #define INT_TIMER3                73 
.................... #define INT_SPI1E                 74 
.................... #define INT_SPI1                  75 
.................... #define INT_RDA                   76 
.................... #define INT_TBE                   77 
.................... #define INT_ADC1                  78 
.................... #define INT_DMA1                  79 
.................... #define INT_SI2C                  81 
.................... #define INT_MI2C                  82 
.................... #define INT_CNI                   84 
.................... #define INT_EXT1                  85 
.................... #define INT_IC7                   87 
.................... #define INT_IC8                   88 
.................... #define INT_DMA2                  89 
.................... #define INT_OC3                   90 
.................... #define INT_OC4                   91 
.................... #define INT_TIMER4                92 
.................... #define INT_TIMER5                93 
.................... #define INT_EXT2                  94 
.................... #define INT_RDA2                  95 
.................... #define INT_TBE2                  96 
.................... #define INT_SPI2E                 97 
.................... #define INT_SPI2                  98 
.................... #define INT_C1RX                  99 
.................... #define INT_CAN1                  100 
.................... #define INT_DMA3                  101 
.................... #define INT_PWM1                  110 
.................... #define INT_DMA4                  111 
.................... #define INT_QEI                   123 
.................... #define INT_DMA5                  126 
.................... #define INT_PWM2                  127 
.................... #define INT_FAULTA                128 
.................... #define INT_UART1E                130 
.................... #define INT_UART2E                131 
.................... #define INT_QEI2                  132 
.................... #define INT_DMA6                  133 
.................... #define INT_DMA7                  134 
.................... #define INT_C1TX                  135 
.................... #define INT_FAULTA2               139 
.................... #define INT_COMP                  152 
.................... #define INT_PMP                   164 
.................... #define INT_RTC                   173 
.................... #define INT_CRC                   174 
.................... #define INT_DAC1R                 177 
.................... #define INT_DAC1L                 178 
....................  
.................... #list 
....................  
.................... #endif 
....................  
....................  
.................... #fuses NOJTAG      // JTAG port is disabled 
.................... #fuses NOPROTECT   // Code protection is disabled 
.................... #fuses NOWRT       // Writes to program memory are allowed 
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1 
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled 
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED) 
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled 
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV) 
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled 
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15) 
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #use delay(clock=7370000) 
*
0071A:  CP0     W0
0071C:  BTSC.B  42.1
0071E:  BRA     728
00720:  REPEAT  #E60
00722:  NOP     
00724:  DEC     W0,W0
00726:  BRA     NZ,720
00728:  RETURN  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #define ON(pin)   output_high(pin) 
.................... #define OFF(pin)   output_low( pin) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... //#define SDA1         PIN_B9  //                    ( 1) 
.................... #define BUZZER         PIN_C6  //                    ( 2) 
.................... #define LED1           PIN_C7  //                    ( 3) 
.................... #define LED2           PIN_C8  //                    ( 4) 
.................... #define LED3           PIN_C9  //                    ( 5) 
.................... //                     VSS     //                    ( 6) 
.................... //                     VCAP    //                    ( 7) 
.................... #define H3             PIN_B10 //                    ( 8) 
.................... #define L3             PIN_B11 //                    ( 9) 
.................... #define H2             PIN_B12 //                    (10) 
.................... #define L2             PIN_B13 //                    (11) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #define _I             PIN_A10 //                    (12) 
.................... #define BTOK           PIN_A7  //                    (13) 
.................... #define H1             PIN_B14 //                    (14) 
.................... #define L1             PIN_B15 //                    (15) 
.................... //                     AVSS    //                    (16) 
.................... //                     AVDD    //                    (17) 
.................... //                     ~MCLR   //                    (18) 
.................... #define BTIN           PIN_A0  //                    (19) 
.................... #define POT  		       PIN_A1  //                    (20) 
.................... //                     PIN_B0  //                    (21) 
.................... //                     PIN_B1  //                    (22) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #define ANL4           PIN_B2  //                    (23) 
.................... #define ANL3           PIN_B3  //                    (24) 
.................... #define ANL2           PIN_C0  //                    (25) 
.................... #define SD             PIN_C1  //                    (26) 
.................... #define ANL1           PIN_C2  //                    (27) 
.................... //                     VDD     //                    (28) 
.................... //                     VSS     //                    (29) 
.................... //                     PIN_A2  //                    (30) 
.................... //                     PIN_A3  //                    (31) 
.................... #define BTCM           PIN_A8  //                    (32) 
.................... //                     PIN_B4  //                    (33) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... //                     PIN_A4  //                    (34) 
.................... #define COMM           PIN_A9  //                    (35) 
.................... #pin_select U1TX =     PIN_C3  //                    (36) 
.................... #pin_select U1RX =     PIN_C4  //                    (37) 
.................... #define CS             PIN_C5  //                    (38) 
.................... //                     VSS     //                    (39) 
.................... //                     VDD     //                    (40) 
.................... #pin_select SDI1 =     PIN_B5  //                    (41) 
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42) 
.................... #pin_select SDO1 =     PIN_B7  //                    (43) 
.................... //#define SCL1         PIN_B8  //                    (44) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... #endif 
....................  
.................... #include "adc.h" 
.................... /** 
....................  @file    adc.h 
....................  @author  Ricardo Gomez 
....................  @brief   adc init and ISR 
.................... */ 
.................... // Do not write above this line (except comments)! 
....................  
.................... #ifndef __ADC_H 
.................... #define __ADC_H 
....................  
.................... #include "common.h" 
.................... #ifndef COMMON_h 
.................... #define COMMON_h 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... //#include "33FJ128MC804.h" 
.................... #include "Header.h" 
.................... #include "adc.h" 
.................... #include "lcd.h" 
.................... #include "algoritmo.h" 
.................... #include "SD_Card.h" 
.................... #include "BLUETOOTH.h" 
.................... #include "BEEP.h" 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #endif 
....................  
....................  
....................  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... void adcinit(void) //por comprobar en la placa 
.................... { 
....................     output_high(BTCM); 
*
0091C:  BCLR.B  2C1.0
0091E:  BSET.B  2C5.0
....................     setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_31); 
00920:  MOV     #9F00,W4
00922:  MOV     W4,324
00924:  MOV     #86E0,W4
00926:  MOV     W4,320
....................     setup_adc_ports(sAN4, VSS_VDD); 
00928:  MOV     #FFEF,W4
0092A:  MOV     W4,32C
0092C:  CLR     322
....................     set_adc_channel(4); 
0092E:  MOV     #4,W4
00930:  MOV     W4,328
00932:  RETURN  
.................... //   setup_timer3(TMR_INTERNAL, 18425); //  200 Hz. Ty/2/18425 
.................... //   ADC1CON2 = 0b0000000000000000; // voltage reference en ADC1CON2 
.................... //   ADC1CON3 = 0b1000000000000000; // select the analog conversion clock <7:0> y <15> para enable Tad 
.................... //   AD1PCFGL = 0b1111111111111110; // AN1 entrada analogica - RB1 - PGC en placa 
.................... //   AD1CHS0  = 0b0000000100000001; // AN1 entrada seleccionada para el CH0 
.................... //   AD1PCFGL = 0b0000000011110111; // AN4 entrada analogica - RB1 - PGC en placa 
.................... //   AD1CHS0  = 0b0000010000000100; // AN4 entrada seleccionada para el CH0 
.................... // 
.................... //   ADC1CON1 = 0b1011010101000110; // 12 bits - Signed Integer - <7:5> 010 Timer3 for ADC1 - <15> Sampling inmediatly after EOC <9:0> unsigned int 
....................  
.................... } 
....................  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #endif // __ADC_H 
....................  
.................... #include "lcd.h" 
.................... /** 
....................  @file    lcd.h 
....................  @author  Ricardo Gmez 
....................  @brief   LCD management 
.................... */ 
.................... // Do not write above this line (except comments)! 
....................  
.................... #ifndef __LCD_H 
.................... #define __LCD_H 
....................  
.................... #include "common.h" 
.................... #ifndef COMMON_h 
.................... #define COMMON_h 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... //#include "33FJ128MC804.h" 
.................... #include "Header.h" 
.................... #include "adc.h" 
.................... #include "lcd.h" 
.................... #include "algoritmo.h" 
.................... #include "SD_Card.h" 
.................... #include "BLUETOOTH.h" 
.................... #include "BEEP.h" 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #endif 
....................  
....................  
.................... /* SECTION 1: Included header files to compile this file           */ 
....................  
.................... /* SECTION 2: Public macros                                        */ 
....................  
.................... #define _CLEAR_DISPLAY 				0x01 
.................... #define _8BIT_4LINES_NORMAL_RE1_IS0		0x3A 
.................... #define _8BIT_4LINES_REVERSE_RE1_IS0		0x3B 
.................... #define _8BIT_4LINES_RE0_IS1			0x39 
.................... #define _8BIT_4LINES_RE0_IS0			0x38 
....................  
.................... #define _BS1_1					0x1E 
.................... #define _POWER_DOWN_DISABLE			0x02 
.................... #define _SEGMENT_NORMAL_WAY			0x05 
.................... #define _NW					0x09 
....................  
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_ON		0x0F 
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_OFF		0x0E 
.................... #define _DISPLAY_ON_CURSOR_OFF_BLINK_OFF	0x0C 
.................... #define _BS0_1					0x1C 
.................... #define _INTERNAL_DIVIDER			0x13 
.................... #define _CONTRAST				0x77 
.................... #define _POWER_ICON_CONTRAST			0x5C 
.................... #define _FOLLOWER_CONTROL			0x6E 
....................  
.................... #define ADDRESS_DDRAM				0x80 
....................  
....................  
.................... /* SECTION 3: Public types                                         */ 
....................  
....................  
.................... /* SECTION 4: Public variables :: declarations, extern mandatory   */ 
....................  
....................  
.................... /* SECTION 5: Public functions :: declarations, extern optional 
....................    Rule exception (callbacks)  :: declarations, extern recommended */ 
.................... void display_valueADC_title(void); 
.................... void LCD_command(unsigned int8); 
.................... void lcdi2cinit(void); 
.................... void LCD_write(char*); 
.................... void initmenu(void);                                      //Inicializa el menu principal 
.................... void display_frecuencia(void);       // Muestra frecuencia 
.................... void LCD_cursor_at(unsigned int8 line, unsigned int8 column); 
.................... void display_alarma_alto(void); // Limpia pantalla y escribe mensaje de alarma 
.................... void display_alarma_bajo(void); 
.................... void display_final(void); 
....................  
....................  
.................... void lcdi2cinit(void) 
.................... { 
....................  
....................   OFF(SD); 
*
00776:  BCLR.B  2D0.1
00778:  BCLR.B  2D4.1
....................   delay_ms(200); 
0077A:  MOV     #C8,W0
0077C:  CALL    71A
....................   ON(PIN_C1); 
00780:  BCLR.B  2D0.1
00782:  BSET.B  2D4.1
....................  
....................   //leds output en open drain 
....................   output_float(PIN_B8); 
00784:  BSET.B  2C9.0
....................   output_float(PIN_B9); 
00786:  BSET.B  2C9.1
....................  
....................   //pullups 
....................   set_pullup(TRUE, PIN_B8); 
00788:  BSET.B  6A.6
....................   set_pullup(TRUE, PIN_B9); 
0078A:  BSET.B  6A.5
....................  
....................  
....................   //dspic as master, velocidad, nombre de la conexion 
....................   #use i2c(Master, Fast=100000, i2c1) 
*
0072A:  MOV     #FFFF,W0
0072C:  BTSS.B  208.3
0072E:  BRA     73A
00730:  BTSC.B  209.6
00732:  BRA     730
00734:  MOV     W1,202
00736:  BTSC.B  209.6
00738:  BRA     736
0073A:  MOV     #0,W0
0073C:  BTSC.B  209.7
0073E:  INC     W0,W0
00740:  RETURN  
....................  
....................   LCD_command(_CLEAR_DISPLAY); 
*
0078C:  MOV.B   #1,W0L
0078E:  MOV.B   W0L,132E
00790:  CALL    742
....................   LCD_command(_8BIT_4LINES_NORMAL_RE1_IS0); 
00794:  MOV.B   #3A,W0L
00796:  MOV.B   W0L,132E
00798:  CALL    742
....................   LCD_command(_BS1_1); 
0079C:  MOV.B   #1E,W0L
0079E:  MOV.B   W0L,132E
007A0:  CALL    742
....................   LCD_command(_POWER_DOWN_DISABLE); 
007A4:  MOV.B   #2,W0L
007A6:  MOV.B   W0L,132E
007A8:  CALL    742
....................   LCD_command(_SEGMENT_NORMAL_WAY); 
007AC:  MOV.B   #5,W0L
007AE:  MOV.B   W0L,132E
007B0:  CALL    742
....................   LCD_command(_NW); 
007B4:  MOV.B   #9,W0L
007B6:  MOV.B   W0L,132E
007B8:  CALL    742
....................   LCD_command(_8BIT_4LINES_RE0_IS1); 
007BC:  MOV.B   #39,W0L
007BE:  MOV.B   W0L,132E
007C0:  CALL    742
....................   LCD_command(_DISPLAY_ON_CURSOR_ON_BLINK_OFF); 
007C4:  MOV.B   #E,W0L
007C6:  MOV.B   W0L,132E
007C8:  CALL    742
....................   LCD_command(_BS0_1); 
007CC:  MOV.B   #1C,W0L
007CE:  MOV.B   W0L,132E
007D0:  CALL    742
....................   LCD_command(_INTERNAL_DIVIDER); 
007D4:  MOV.B   #13,W0L
007D6:  MOV.B   W0L,132E
007D8:  CALL    742
....................   LCD_command(_CONTRAST); 
007DC:  MOV.B   #77,W0L
007DE:  MOV.B   W0L,132E
007E0:  CALL    742
....................   LCD_command(_POWER_ICON_CONTRAST); 
007E4:  MOV.B   #5C,W0L
007E6:  MOV.B   W0L,132E
007E8:  CALL    742
....................   LCD_command(_FOLLOWER_CONTROL); 
007EC:  MOV.B   #6E,W0L
007EE:  MOV.B   W0L,132E
007F0:  CALL    742
....................   LCD_command(_8BIT_4LINES_RE0_IS0); 
007F4:  MOV.B   #38,W0L
007F6:  MOV.B   W0L,132E
007F8:  CALL    742
007FC:  RETURN  
....................  
.................... } 
....................  
.................... void LCD_command(unsigned int8 cmd) 
.................... { 
....................   i2c_start(); 
*
00742:  BTSS.B  208.3
00744:  BRA     74E
00746:  BSET.B  206.1
00748:  BTSC.B  206.1
0074A:  BRA     748
0074C:  BRA     754
0074E:  BSET.B  206.0
00750:  BTSC.B  206.0
00752:  BRA     750
....................   i2c_write(0x78); 
00754:  MOV.B   #78,W1L
00756:  CALL    72A
....................   i2c_write(0x00); 
0075A:  CLR.B   W1
0075C:  CALL    72A
....................   i2c_write(cmd); 
00760:  MOV.B   132E,W0L
00762:  MOV.B   W0L,2
00764:  CALL    72A
....................   i2c_stop(); 
00768:  MOV     #1F,W0
0076A:  AND     206,W0
0076C:  BRA     NZ,768
0076E:  BSET.B  206.2
00770:  BTSC.B  206.2
00772:  BRA     770
00774:  RETURN  
.................... } 
....................  
.................... void LCD_write(char* cd) 
*
00838:  MOV     W5,[W15++]
0083A:  MOV     W6,[W15++]
0083C:  CLR.B   1328
.................... { 
....................   unsigned int8 c=0; 
....................   i2c_start(); 
0083E:  BTSS.B  208.3
00840:  BRA     84A
00842:  BSET.B  206.1
00844:  BTSC.B  206.1
00846:  BRA     844
00848:  BRA     850
0084A:  BSET.B  206.0
0084C:  BTSC.B  206.0
0084E:  BRA     84C
....................   i2c_write(0x78); 
00850:  MOV.B   #78,W1L
00852:  CALL    72A
....................   i2c_write(0x40); 
00856:  MOV.B   #40,W1L
00858:  CALL    72A
....................   while(cd[c]!=0) 
0085C:  MOV     1328,W4
0085E:  CLR.B   9
00860:  MOV     W4,W0
00862:  ADD     1326,W0
00864:  MOV.B   [W0],W5L
00866:  SE      W5,W5
00868:  CP0     W5
0086A:  BRA     Z,882
....................   { 
....................     i2c_write(cd[c]); 
0086C:  MOV     1328,W4
0086E:  CLR.B   9
00870:  MOV     W4,W0
00872:  ADD     1326,W0
00874:  MOV.B   [W0],W5L
00876:  MOV.B   W5L,W1L
00878:  CALL    72A
....................     c++; 
0087C:  INC.B   1328
0087E:  GOTO    85C
....................   } 
....................   i2c_stop(); 
00882:  MOV     #1F,W0
00884:  AND     206,W0
00886:  BRA     NZ,882
00888:  BSET.B  206.2
0088A:  BTSC.B  206.2
0088C:  BRA     88A
0088E:  MOV     [--W15],W6
00890:  MOV     [--W15],W5
00892:  RETURN  
.................... } 
....................  
.................... void LCD_cursor_at(unsigned int8 line, unsigned int8 column) 
*
00818:  MOV     W5,[W15++]
.................... { 
....................   LCD_command(0x80 | (line*0x20+column)); 
0081A:  MOV.B   1326,W0L
0081C:  CLR.B   1
0081E:  SL      W0,#5,W5
00820:  MOV     1326,W4
00822:  LSR     W4,#8,W4
00824:  ADD     W5,W4,W0
00826:  MOV     W0,W5
00828:  IOR     #80,W5
0082A:  PUSH    132E
0082C:  MOV.B   W5L,[W15-#2]
0082E:  POP     132E
00830:  CALL    742
00834:  MOV     [--W15],W5
00836:  RETURN  
.................... } 
....................  
.................... void initmenu(void) 
.................... { 
.................... 	char cabecera[]="----WELCOME-----"; 
*
00894:  MOV     #2D2D,W4
00896:  MOV     W4,12EC
00898:  MOV     #2D2D,W4
0089A:  MOV     W4,12EE
0089C:  MOV     #4557,W4
0089E:  MOV     W4,12F0
008A0:  MOV     #434C,W4
008A2:  MOV     W4,12F2
008A4:  MOV     #4D4F,W4
008A6:  MOV     W4,12F4
008A8:  MOV     #2D45,W4
008AA:  MOV     W4,12F6
008AC:  MOV     #2D2D,W4
008AE:  MOV     W4,12F8
008B0:  MOV     #2D2D,W4
008B2:  MOV     W4,12FA
008B4:  CLR.B   12FC
.................... 	char boton[]="-------------"; 
008B6:  MOV     #2D2D,W4
008B8:  MOV     W4,12FE
008BA:  MOV     #2D2D,W4
008BC:  MOV     W4,1300
008BE:  MOV     #2D2D,W4
008C0:  MOV     W4,1302
008C2:  MOV     #2D2D,W4
008C4:  MOV     W4,1304
008C6:  MOV     #2D2D,W4
008C8:  MOV     W4,1306
008CA:  MOV     #2D2D,W4
008CC:  MOV     W4,1308
008CE:  MOV     #2D,W4
008D0:  MOV     W4,130A
.................... 	char palabra1[]="PRESS OK"; 
008D2:  MOV     #5250,W4
008D4:  MOV     W4,130C
008D6:  MOV     #5345,W4
008D8:  MOV     W4,130E
008DA:  MOV     #2053,W4
008DC:  MOV     W4,1310
008DE:  MOV     #4B4F,W4
008E0:  MOV     W4,1312
008E2:  CLR.B   1314
.................... 	//char palabra2[]="OPCION 2"; 
.................... 	//char palabra3[]="OPCION 3"; 
.................... 	//char palabra4[]="OPCION 4"; 
....................  
.................... 	LCD_cursor_at(0,0); 
008E4:  CLR.B   1326
008E6:  CLR.B   1327
008E8:  CALL    818
.................... 	LCD_write(cabecera); 
008EC:  MOV     #12EC,W4
008EE:  MOV     W4,1326
008F0:  CALL    838
.................... 	LCD_cursor_at(1,0); 
008F4:  MOV.B   #1,W0L
008F6:  MOV.B   W0L,1326
008F8:  CLR.B   1327
008FA:  CALL    818
.................... 	LCD_write(boton); 
008FE:  MOV     #12FE,W4
00900:  MOV     W4,1326
00902:  CALL    838
.................... 	LCD_cursor_at(2,1); 
00906:  MOV.B   #2,W0L
00908:  MOV.B   W0L,1326
0090A:  MOV.B   #1,W0L
0090C:  MOV.B   W0L,1327
0090E:  CALL    818
.................... 	LCD_write(palabra1); 
00912:  MOV     #130C,W4
00914:  MOV     W4,1326
00916:  CALL    838
0091A:  RETURN  
.................... } 
....................  
.................... void errorfichero(void) 
.................... { 
.................... 	char cabecera[]="------ERROR------"; 
.................... 	char boton[]="NO CONFIG.TXT DETE"; 
.................... 	char palabra1[]="PRESS RESET"; 
.................... 	//char palabra2[]="OPCION 2"; 
.................... 	//char palabra3[]="OPCION 3"; 
.................... 	//char palabra4[]="OPCION 4"; 
....................  
.................... 	LCD_cursor_at(0,0); 
.................... 	LCD_write(cabecera); 
.................... 	LCD_cursor_at(1,0); 
.................... 	LCD_write(boton); 
.................... 	LCD_cursor_at(2,1); 
.................... 	LCD_write(palabra1); 
.................... } 
....................  
.................... void display_frecuencia(void) 
.................... { 
....................   LCD_command(_DISPLAY_ON_CURSOR_OFF_BLINK_OFF); 
*
00970:  MOV.B   #C,W0L
00972:  MOV.B   W0L,132E
00974:  CALL    742
....................   LCD_command(_CLEAR_DISPLAY); 
00978:  MOV.B   #1,W0L
0097A:  MOV.B   W0L,132E
0097C:  CALL    742
.................... 	char cabecera[]="FRECUENCIA PPM: "; 
00980:  MOV     #5246,W4
00982:  MOV     W4,12EC
00984:  MOV     #4345,W4
00986:  MOV     W4,12EE
00988:  MOV     #4555,W4
0098A:  MOV     W4,12F0
0098C:  MOV     #434E,W4
0098E:  MOV     W4,12F2
00990:  MOV     #4149,W4
00992:  MOV     W4,12F4
00994:  MOV     #5020,W4
00996:  MOV     W4,12F6
00998:  MOV     #4D50,W4
0099A:  MOV     W4,12F8
0099C:  MOV     #203A,W4
0099E:  MOV     W4,12FA
009A0:  CLR.B   12FC
....................   char palabra1[]="-------------------"; 
009A2:  MOV     #2D2D,W4
009A4:  MOV     W4,12FE
009A6:  MOV     #2D2D,W4
009A8:  MOV     W4,1300
009AA:  MOV     #2D2D,W4
009AC:  MOV     W4,1302
009AE:  MOV     #2D2D,W4
009B0:  MOV     W4,1304
009B2:  MOV     #2D2D,W4
009B4:  MOV     W4,1306
009B6:  MOV     #2D2D,W4
009B8:  MOV     W4,1308
009BA:  MOV     #2D2D,W4
009BC:  MOV     W4,130A
009BE:  MOV     #2D2D,W4
009C0:  MOV     W4,130C
009C2:  MOV     #2D2D,W4
009C4:  MOV     W4,130E
009C6:  MOV     #2D,W4
009C8:  MOV     W4,1310
....................   char palabra2[]="BTOK PARA FINALIZAR"; 
009CA:  MOV     #5442,W4
009CC:  MOV     W4,1312
009CE:  MOV     #4B4F,W4
009D0:  MOV     W4,1314
009D2:  MOV     #5020,W4
009D4:  MOV     W4,1316
009D6:  MOV     #5241,W4
009D8:  MOV     W4,1318
009DA:  MOV     #2041,W4
009DC:  MOV     W4,131A
009DE:  MOV     #4946,W4
009E0:  MOV     W4,131C
009E2:  MOV     #414E,W4
009E4:  MOV     W4,131E
009E6:  MOV     #494C,W4
009E8:  MOV     W4,1320
009EA:  MOV     #415A,W4
009EC:  MOV     W4,1322
009EE:  MOV     #52,W4
009F0:  MOV     W4,1324
.................... 	LCD_cursor_at(0,0); 
009F2:  CLR.B   1326
009F4:  CLR.B   1327
009F6:  CALL    818
....................   LCD_write(cabecera); 
009FA:  MOV     #12EC,W4
009FC:  MOV     W4,1326
009FE:  CALL    838
....................   LCD_cursor_at(1,0); 
00A02:  MOV.B   #1,W0L
00A04:  MOV.B   W0L,1326
00A06:  CLR.B   1327
00A08:  CALL    818
....................   LCD_write(palabra1); 
00A0C:  MOV     #12FE,W4
00A0E:  MOV     W4,1326
00A10:  CALL    838
....................   LCD_cursor_at(2,0); 
00A14:  MOV.B   #2,W0L
00A16:  MOV.B   W0L,1326
00A18:  CLR.B   1327
00A1A:  CALL    818
....................   LCD_write(palabra2); 
00A1E:  MOV     #1312,W4
00A20:  MOV     W4,1326
00A22:  CALL    838
00A26:  RETURN  
.................... } 
....................  
.................... void display_valueADC_title(void) 
.................... { 
....................   char cabecera[]="VALOR ADC: "; 
....................   //char palabra2[]="OPCION 2"; 
....................   //char palabra3[]="OPCION 3"; 
....................   //char palabra4[]="OPCION 4"; 
....................  
....................   LCD_cursor_at(0,0); 
....................   LCD_write(cabecera); 
.................... } 
....................  
.................... void display_alarma_bajo(void) 
.................... { 
....................   LCD_command(_CLEAR_DISPLAY); 
*
00A6C:  MOV.B   #1,W0L
00A6E:  MOV.B   W0L,132E
00A70:  CALL    742
....................   LCD_cursor_at(0,0); 
00A74:  CLR.B   1326
00A76:  CLR.B   1327
00A78:  CALL    818
....................   char peligro[]="PULSACIONES BAJAS"; 
00A7C:  MOV     #5550,W4
00A7E:  MOV     W4,12EC
00A80:  MOV     #534C,W4
00A82:  MOV     W4,12EE
00A84:  MOV     #4341,W4
00A86:  MOV     W4,12F0
00A88:  MOV     #4F49,W4
00A8A:  MOV     W4,12F2
00A8C:  MOV     #454E,W4
00A8E:  MOV     W4,12F4
00A90:  MOV     #2053,W4
00A92:  MOV     W4,12F6
00A94:  MOV     #4142,W4
00A96:  MOV     W4,12F8
00A98:  MOV     #414A,W4
00A9A:  MOV     W4,12FA
00A9C:  MOV     #53,W4
00A9E:  MOV     W4,12FC
....................   LCD_write(peligro); 
00AA0:  MOV     #12EC,W4
00AA2:  MOV     W4,1326
00AA4:  CALL    838
00AA8:  RETURN  
.................... } 
....................  
.................... void display_alarma_alto(void) 
.................... { 
....................   LCD_command(_CLEAR_DISPLAY); 
*
00A28:  MOV.B   #1,W0L
00A2A:  MOV.B   W0L,132E
00A2C:  CALL    742
....................   LCD_cursor_at(0,0); 
00A30:  CLR.B   1326
00A32:  CLR.B   1327
00A34:  CALL    818
....................   char peligro[]="PULSACIONES ELEVADAS"; 
00A38:  MOV     #5550,W4
00A3A:  MOV     W4,12EC
00A3C:  MOV     #534C,W4
00A3E:  MOV     W4,12EE
00A40:  MOV     #4341,W4
00A42:  MOV     W4,12F0
00A44:  MOV     #4F49,W4
00A46:  MOV     W4,12F2
00A48:  MOV     #454E,W4
00A4A:  MOV     W4,12F4
00A4C:  MOV     #2053,W4
00A4E:  MOV     W4,12F6
00A50:  MOV     #4C45,W4
00A52:  MOV     W4,12F8
00A54:  MOV     #5645,W4
00A56:  MOV     W4,12FA
00A58:  MOV     #4441,W4
00A5A:  MOV     W4,12FC
00A5C:  MOV     #5341,W4
00A5E:  MOV     W4,12FE
00A60:  CLR.B   1300
....................   LCD_write(peligro); 
00A62:  MOV     #12EC,W4
00A64:  MOV     W4,1326
00A66:  CALL    838
00A6A:  RETURN  
.................... } 
....................  
.................... void display_final(void) 
.................... { 
....................   LCD_command(_CLEAR_DISPLAY); 
*
00D56:  MOV.B   #1,W0L
00D58:  MOV.B   W0L,132E
00D5A:  CALL    742
....................   LCD_cursor_at(0,0); 
00D5E:  CLR.B   1326
00D60:  CLR.B   1327
00D62:  CALL    818
....................   char fin[]="Fin del programa"; 
00D66:  MOV     #6946,W4
00D68:  MOV     W4,12EC
00D6A:  MOV     #206E,W4
00D6C:  MOV     W4,12EE
00D6E:  MOV     #6564,W4
00D70:  MOV     W4,12F0
00D72:  MOV     #206C,W4
00D74:  MOV     W4,12F2
00D76:  MOV     #7270,W4
00D78:  MOV     W4,12F4
00D7A:  MOV     #676F,W4
00D7C:  MOV     W4,12F6
00D7E:  MOV     #6172,W4
00D80:  MOV     W4,12F8
00D82:  MOV     #616D,W4
00D84:  MOV     W4,12FA
00D86:  CLR.B   12FC
....................   LCD_write(fin); 
00D88:  MOV     #12EC,W4
00D8A:  MOV     W4,1326
00D8C:  CALL    838
00D90:  RETURN  
.................... } 
....................  
....................  
.................... #endif // __LCD_H 
.................... // Do not write below this line! 
....................  
.................... #include "algoritmo.h" 
.................... /** 
....................  @file    ALGORITMO.h 
....................  @author  Ricardo Gomez, Klaudija Ziliute 
....................  @brief   PanTompkins header file 
.................... */ 
....................  
....................  
.................... #ifndef __ALGORITMO_H 
.................... #define __ALGORITMO_H 
....................  
.................... #include "common.h" 
.................... #ifndef COMMON_h 
.................... #define COMMON_h 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... //#include "33FJ128MC804.h" 
.................... #include "Header.h" 
.................... #include "adc.h" 
.................... #include "lcd.h" 
.................... #include "algoritmo.h" 
.................... #include "SD_Card.h" 
.................... #include "BLUETOOTH.h" 
.................... #include "BEEP.h" 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #endif 
....................  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #include "adc.h" 
.................... /** 
....................  @file    adc.h 
....................  @author  Ricardo Gomez 
....................  @brief   adc init and ISR 
.................... */ 
.................... // Do not write above this line (except comments)! 
....................  
.................... #ifndef __ADC_H 
.................... #define __ADC_H 
....................  
.................... #include "common.h" 
....................  
....................  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... void adcinit(void) //por comprobar en la placa 
.................... { 
....................     output_high(BTCM); 
....................     setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_31); 
....................     setup_adc_ports(sAN4, VSS_VDD); 
....................     set_adc_channel(4); 
.................... //   setup_timer3(TMR_INTERNAL, 18425); //  200 Hz. Ty/2/18425 
.................... //   ADC1CON2 = 0b0000000000000000; // voltage reference en ADC1CON2 
.................... //   ADC1CON3 = 0b1000000000000000; // select the analog conversion clock <7:0> y <15> para enable Tad 
.................... //   AD1PCFGL = 0b1111111111111110; // AN1 entrada analogica - RB1 - PGC en placa 
.................... //   AD1CHS0  = 0b0000000100000001; // AN1 entrada seleccionada para el CH0 
.................... //   AD1PCFGL = 0b0000000011110111; // AN4 entrada analogica - RB1 - PGC en placa 
.................... //   AD1CHS0  = 0b0000010000000100; // AN4 entrada seleccionada para el CH0 
.................... // 
.................... //   ADC1CON1 = 0b1011010101000110; // 12 bits - Signed Integer - <7:5> 010 Timer3 for ADC1 - <15> Sampling inmediatly after EOC <9:0> unsigned int 
....................  
.................... } 
....................  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #endif // __ADC_H 
....................  
.................... #include "BEEP.h" 
.................... /** 
....................  @file    BEEP.h 
....................  @author  Julio Gomis-Tena 
....................  @brief   Generate n "beeps" of variable frequency 
.................... */ 
.................... // Do not write above this line (except comments)! 
....................  
.................... #ifndef __BEEP_H 
.................... #define __BEEP_H 
.................... #include "Header.h" 
.................... #ifndef HEADER_h 
.................... #define HEADER_h 
.................... //------------------------------------------------------------------- 
....................  
.................... #include "33FJ128MC804.h" 
....................  
.................... #fuses NOJTAG      // JTAG port is disabled 
.................... #fuses NOPROTECT   // Code protection is disabled 
.................... #fuses NOWRT       // Writes to program memory are allowed 
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1 
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled 
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED) 
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled 
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV) 
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled 
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15) 
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #use delay(clock=7370000) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #define ON(pin)   output_high(pin) 
.................... #define OFF(pin)   output_low( pin) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... //#define SDA1         PIN_B9  //                    ( 1) 
.................... #define BUZZER         PIN_C6  //                    ( 2) 
.................... #define LED1           PIN_C7  //                    ( 3) 
.................... #define LED2           PIN_C8  //                    ( 4) 
.................... #define LED3           PIN_C9  //                    ( 5) 
.................... //                     VSS     //                    ( 6) 
.................... //                     VCAP    //                    ( 7) 
.................... #define H3             PIN_B10 //                    ( 8) 
.................... #define L3             PIN_B11 //                    ( 9) 
.................... #define H2             PIN_B12 //                    (10) 
.................... #define L2             PIN_B13 //                    (11) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #define _I             PIN_A10 //                    (12) 
.................... #define BTOK           PIN_A7  //                    (13) 
.................... #define H1             PIN_B14 //                    (14) 
.................... #define L1             PIN_B15 //                    (15) 
.................... //                     AVSS    //                    (16) 
.................... //                     AVDD    //                    (17) 
.................... //                     ~MCLR   //                    (18) 
.................... #define BTIN           PIN_A0  //                    (19) 
.................... #define POT  		       PIN_A1  //                    (20) 
.................... //                     PIN_B0  //                    (21) 
.................... //                     PIN_B1  //                    (22) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #define ANL4           PIN_B2  //                    (23) 
.................... #define ANL3           PIN_B3  //                    (24) 
.................... #define ANL2           PIN_C0  //                    (25) 
.................... #define SD             PIN_C1  //                    (26) 
.................... #define ANL1           PIN_C2  //                    (27) 
.................... //                     VDD     //                    (28) 
.................... //                     VSS     //                    (29) 
.................... //                     PIN_A2  //                    (30) 
.................... //                     PIN_A3  //                    (31) 
.................... #define BTCM           PIN_A8  //                    (32) 
.................... //                     PIN_B4  //                    (33) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... //                     PIN_A4  //                    (34) 
.................... #define COMM           PIN_A9  //                    (35) 
.................... #pin_select U1TX =     PIN_C3  //                    (36) 
.................... #pin_select U1RX =     PIN_C4  //                    (37) 
.................... #define CS             PIN_C5  //                    (38) 
.................... //                     VSS     //                    (39) 
.................... //                     VDD     //                    (40) 
.................... #pin_select SDI1 =     PIN_B5  //                    (41) 
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42) 
.................... #pin_select SDO1 =     PIN_B7  //                    (43) 
.................... //#define SCL1         PIN_B8  //                    (44) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... #endif 
....................  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #pin_select OC2 = BUZZER 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... void BEEP_Init(void); //Inicializa las frecuencias de los beeps y la separacin entre ellos 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... void BEEP(unsigned int8); //Realiza n beeps 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... void BEEP_Init(void)		//4kHz -> T/2= 125us 
.................... { 
.................... 	setup_timer3(TMR_INTERNAL|TMR_DIV_BY_1, 737); // 5kHz. Frecuencia de los beeps 
*
007FE:  CLR     112
00800:  MOV     #2E1,W4
00802:  MOV     W4,10E
00804:  MOV     #8000,W4
00806:  MOV     W4,112
.................... 	set_compare_time(2, 0); 
00808:  CLR     188
.................... 	setup_compare(2, COMPARE_OFF); 
0080A:  CLR     18A
....................  
.................... 		// (11059200/2)/256/432 = 50 Hz  <-> 100ms 
.................... 	setup_timer4(TMR_INTERNAL|TMR_DIV_BY_8, 1843); 
0080C:  CLR     11E
0080E:  MOV     #733,W4
00810:  MOV     W4,11A
00812:  MOV     #8010,W4
00814:  MOV     W4,11E
00816:  RETURN  
.................... } 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... unsigned int8 N_beep; 
....................  
.................... void BEEP(unsigned int8 n) 
.................... { 
.................... 	if(n<127) 
*
00356:  MOV     1332,W4
00358:  MOV     #7F,W3
0035A:  CP.B    W3L,W4L
0035C:  BRA     LEU,368
.................... 		N_beep = 2*n; 
0035E:  MOV.B   1332,W0L
00360:  MOV.B   W0L,85A
00362:  SL.B    85A
00364:  GOTO    36A
.................... 	else 
.................... 		N_beep = 255; 
00368:  SETM.B  85A
....................  
.................... 	enable_interrupts(INT_TIMER4); 
0036A:  BSET.B  97.3
0036C:  RETURN  
.................... } 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #INT_TIMER4 
.................... void isr_TIMER4()			// Cada 100 ms. Espaciado entre beeps. Habra que asociarlo a una interrupcion por software 
*
0026C:  PUSH    42
0026E:  PUSH    36
00270:  PUSH    32
00272:  MOV     W0,[W15++]
00274:  MOV     #2,W0
00276:  REPEAT  #C
00278:  MOV     [W0++],[W15++]
.................... { 
.................... 		if((N_beep%2)==1) 
0027A:  MOV.B   85A,W0L
0027C:  CLR.B   1
0027E:  AND     W0,#1,W5
00280:  CP      W5,#1
00282:  BRA     NZ,28C
.................... 		{ 
.................... 			setup_compare(2, COMPARE_TOGGLE | COMPARE_TIMER3); 
00284:  MOV     #B,W4
00286:  MOV     W4,18A
.................... 		} 
00288:  GOTO    292
.................... 		else 
.................... 		{ 
.................... 			setup_compare(2, COMPARE_OFF); 
0028C:  CLR     18A
.................... 			OFF(BUZZER); 
0028E:  BCLR.B  2D0.6
00290:  BCLR.B  2D4.6
.................... 		} 
....................  
.................... 		if( N_beep>0 ) 
00292:  CP0.B   85A
00294:  BRA     Z,2A0
.................... 		{ 
.................... 		   	N_beep-=1; 
00296:  MOV     85A,W4
00298:  SUB.B   W4L,#1,W0L
0029A:  MOV.B   W0L,85A
.................... 		} 
0029C:  GOTO    2A2
.................... 		else 
.................... 		{ 
.................... 			disable_interrupts(INT_TIMER4); 
002A0:  BCLR.B  97.3
.................... 		} 
.................... } 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
002A2:  BCLR.B  87.3
002A4:  MOV     #1A,W0
002A6:  REPEAT  #C
002A8:  MOV     [--W15],[W0--]
002AA:  MOV     [--W15],W0
002AC:  POP     32
002AE:  POP     36
002B0:  POP     42
002B2:  RETFIE  
.................... #endif // __BEEP_H 
....................  
....................  
....................  
.................... int algoritmo(void); 
.................... void init_algoritmo(void); 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... unsigned int16 yECG[6]; 
.................... unsigned int16 der, maximo, maximo_ant; 
.................... float umbral; 
.................... unsigned int16 k; 
.................... int1 flag; 
.................... unsigned int16 BCL, BCL2; // contador interno (1 BCL=4ms) 
....................  
....................  
.................... void init_algoritmo() 
*
00934:  MOV     W5,[W15++]
.................... { 
.................... 	BCL=0; 
00936:  CLR     874
.................... 	k=0; 
00938:  CLR     872
.................... 	umbral=0; 
0093A:  CLR     86E
0093C:  CLR     870
.................... 	flag=0; 
0093E:  BCLR.B  85B.0
.................... 	maximo=0; 
00940:  CLR     86A
.................... 	maximo_ant=0; 
00942:  CLR     86C
.................... 	for(int e=0; e<6; e++) 
00944:  CLR     12EC
00946:  MOV     12EC,W4
00948:  CP      W4,#6
0094A:  BRA     GE,96A
.................... 	{ 
.................... 		yECG[e]=read_adc(); 
0094C:  MOV     12EC,W4
0094E:  MUL.UU  W4,#2,W0
00950:  MOV     #85C,W4
00952:  ADD     W0,W4,W5
00954:  BCLR.B  320.0
00956:  BSET.B  320.1
00958:  BTSS.B  320.0
0095A:  BRA     958
0095C:  MOV     300,W4
0095E:  MOV     W4,[W5+#0]
.................... 		delay_ms(4); 
00960:  REPEAT  #3992
00962:  NOP     
00964:  INC     12EC
00966:  GOTO    946
.................... 	} 
.................... 	enable_interrupts(INT_TIMER2); 
0096A:  BSET.B  94.7
0096C:  MOV     [--W15],W5
0096E:  RETURN  
.................... } 
....................  
.................... // Bucle principal del programa. Debe ejecutarse cada 4ms (250Hz). 
.................... int algoritmo(void) 
*
005E2:  MOV     W5,[W15++]
.................... { 
.................... 	int pulsaciones; 
.................... 	yECG[5] = yECG[4];		// Hace 20 ms 
005E4:  PUSH    864
005E6:  POP     866
.................... 	yECG[4] = yECG[3];		// Hace 16 ms 
005E8:  PUSH    862
005EA:  POP     864
.................... 	yECG[3] = yECG[2]; 		// Hace 12 ms 
005EC:  PUSH    860
005EE:  POP     862
.................... 	yECG[2] = yECG[1]; 		// Hace 8 ms 
005F0:  PUSH    85E
005F2:  POP     860
.................... 	yECG[1] = yECG[0]; 		// Hace 4 ms 
005F4:  PUSH    85C
005F6:  POP     85E
.................... 	yECG[0] = read_adc(); // Ahora 
005F8:  BCLR.B  320.0
005FA:  BSET.B  320.1
005FC:  BTSS.B  320.0
005FE:  BRA     5FC
00600:  PUSH    300
00602:  POP     85C
....................  
.................... 	//Valor absoluto de la derivada 
.................... 	der = (yECG[5] > yECG[0]) ? (yECG[5] - yECG[0]) : (yECG[0] - yECG[5]); 
00604:  MOV     85C,W0
00606:  MOV     866,W4
00608:  CP      W4,W0
0060A:  BRA     LEU,616
0060C:  MOV     866,W4
0060E:  MOV     85C,W3
00610:  SUB     W4,W3,W0
00612:  GOTO    61C
00616:  MOV     85C,W4
00618:  MOV     866,W3
0061A:  SUB     W4,W3,W0
0061C:  MOV     W0,868
....................  
.................... 	if(der > maximo) maximo = der; 
0061E:  MOV     86A,W0
00620:  MOV     868,W4
00622:  CP      W4,W0
00624:  BRA     LEU,62A
00626:  PUSH    868
00628:  POP     86A
....................  
.................... 	if(flag == 0) 
0062A:  BTSC.B  85B.0
0062C:  BRA     652
.................... 	{ 
.................... 		if(der > umbral) 
0062E:  MOV     868,W0
00630:  CALL    2B4
00634:  MOV     W0,W2
00636:  MOV     W1,W3
00638:  MOV     86E,W0
0063A:  MOV     870,W1
0063C:  CALL    2EE
00640:  BRA     NC,652
.................... 		{ 
.................... 			flag = 1; 
00642:  BSET.B  85B.0
.................... 			// basal cycle length 
.................... 			BCL2 = BCL; 
00644:  PUSH    874
00646:  POP     876
.................... 			BCL = 0; 
00648:  CLR     874
.................... 			BEEP(1); 
0064A:  MOV.B   #1,W0L
0064C:  MOV.B   W0L,1332
0064E:  CALL    356
.................... 		} 
.................... 	} 
....................  
.................... 	if (flag == 1) 
00652:  BTSS.B  85B.0
00654:  BRA     658
.................... 	{ 
.................... 		k++; 
00656:  INC     0872
.................... 	} 
....................  
.................... 	//Durante 60 puntos = RR min = 0.24seg = 250 bpm 
.................... 	//no se puede detectar otro punto RR 
.................... 	//solo pasado ese tiempo se hace el calculo 
....................  
.................... 	if(k >60) // hay que calcular el tiempo que son 0.24s para nuestra freq (60 no) 
00658:  MOV     872,W4
0065A:  MOV     #3C,W3
0065C:  CP      W3,W4
0065E:  BRA     C,698
.................... 	{ 
.................... 		k = 0; 
00660:  CLR     872
.................... 		flag = 0; 
00662:  BCLR.B  85B.0
....................  
.................... 		//Me quedo con la Media del incremento MAX 
.................... 		//De estos 200 puntos y del incremento de los anteriores 
....................  
.................... 		umbral = (maximo + maximo_ant)/2; 
00664:  MOV     86A,W0
00666:  ADD     86C,W0
00668:  MOV     W0,W5
0066A:  LSR     W5,#1,W0
0066C:  CALL    2B4
00670:  MOV     W0,86E
00672:  MOV     W1,870
.................... 		maximo_ant = maximo; 
00674:  PUSH    86A
00676:  POP     86C
.................... 		maximo = 0; 
00678:  CLR     86A
....................  
.................... 		//Reduzco el umbral al 66% 
....................  
.................... 		umbral = umbral -(umbral/3); 
0067A:  MOV     86E,W0
0067C:  MOV     870,W1
0067E:  MOV     #0,W2
00680:  MOV     #4040,W3
00682:  CALL    36E
00686:  BSET.B  43.0
00688:  MOV     W0,W2
0068A:  MOV     W1,W3
0068C:  MOV     86E,W0
0068E:  MOV     870,W1
00690:  CALL    438
00694:  MOV     W0,86E
00696:  MOV     W1,870
.................... 	} 
....................  
.................... 	//Si pasa un rato 
.................... 	//equivaldria a un pulso de 15bpm si se detectara punto R 
.................... 	//y no se ha superado el umbral se reinicia 
....................  
.................... 	if(BCL > 1000) 
00698:  MOV     874,W4
0069A:  MOV     #3E8,W3
0069C:  CP      W3,W4
0069E:  BRA     C,6AA
.................... 	{ 
.................... 		maximo = 0; 
006A0:  CLR     86A
.................... 		umbral = 0; 
006A2:  CLR     86E
006A4:  CLR     870
.................... 		flag = 1; 
006A6:  BSET.B  85B.0
.................... 		BCL = 0; 
006A8:  CLR     874
.................... 	} 
.................... 	//Calculo el ritmo cardiaco (si esta en rango fisiologico) 
.................... 	//y si no permanece el valor anteriore 
.................... 	//15000 son las muestras de 1 minuto (60000[ms]/4[ms/muestra]) 
....................  
.................... 	if((BCL2 > 65) && (BCL2 < 500)) 
006AA:  MOV     876,W4
006AC:  MOV     #41,W3
006AE:  CP      W3,W4
006B0:  BRA     C,6C4
006B2:  MOV     876,W4
006B4:  MOV     #1F4,W3
006B6:  CP      W3,W4
006B8:  BRA     LEU,6C4
.................... 	{ 
.................... 		pulsaciones = (int)(15000/BCL2); 
006BA:  MOV     #3A98,W4
006BC:  MOV     876,W3
006BE:  REPEAT  #11
006C0:  DIV.U   W4,W3
006C2:  MOV     W0,1330
.................... 	} 
.................... BCL=BCL+1;  // Actualiza la cuenta ente ciclos 
006C4:  MOV     874,W4
006C6:  ADD     W4,#1,W0
006C8:  MOV     W0,874
.................... return pulsaciones; 
006CA:  PUSH    1330
006CC:  POP     0
006CE:  MOV     [--W15],W5
006D0:  RETURN  
.................... } 
....................  
....................  
.................... #endif // __ALGORITMO_H 
....................  
.................... #include "SD_Card.h" 
.................... /** 
....................  @file    SD_CARD.h 
....................  @author  Ricardo Gomez, Klaudija Ziliute 
....................  @brief   PanTompkins header file 
.................... */ 
....................  
....................  
.................... #ifndef __SD_CARD_H 
.................... #define __SD_CARD_H 
....................  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #include "common.h" 
.................... #ifndef COMMON_h 
.................... #define COMMON_h 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... //#include "33FJ128MC804.h" 
.................... #include "Header.h" 
.................... #include "adc.h" 
.................... #include "lcd.h" 
.................... #include "algoritmo.h" 
.................... #include "SD_Card.h" 
.................... #include "BLUETOOTH.h" 
.................... #include "BEEP.h" 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #endif 
....................  
.................... #include "miFAT.h" 
....................  
.................... #ifndef __MIFAT_H 
.................... #define __MIFAT_H 
.................... // Definidos en sdcard.h - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... extern unsigned int8 dt[512]; 
.................... extern unsigned int32 LBA0; 
.................... extern unsigned int8 sd_init(); 
.................... extern unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr); 
.................... extern unsigned int8 sd_read_block( unsigned int32 address, unsigned char* ptr); 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
....................  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #define MAX_ENTRIES_SECTOR_FAT16        256 
.................... #define ENDFILE16                    0xFFFF 
.................... #define MAX_ENTRIES_SECTOR_FAT32        128 
.................... #define ENDFILE32                0x0FFFFFFF 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... typedef struct{ 
.................... 	union{ 
.................... 		unsigned int8 raw[32]; 
.................... 		struct fields{ 
.................... 			char name[8]; 
.................... 			char extension[3]; 
.................... 			unsigned int8 attrib;			///slo lectura, oculto, de sistema, directorio... 
.................... 			//unsigned int8 reserved[10]; 
.................... 			  unsigned int8  reserved; 
.................... 	 		  unsigned int8  createTimeMs; 
.................... 			  unsigned int16 create_hour; 
.................... 			  unsigned int16 create_date; 
.................... 			  unsigned int16 last_access; 
.................... 			  unsigned int16 eaIndex; 
.................... 			  unsigned int16 modif_hour; 
.................... 			  unsigned int16 modif_date; 
.................... 			  unsigned int16 first_cluster;	///primer cluster (direcciona tabla FAT y sector para escribir contenido) 
.................... 			  unsigned int32 size;			///tamao en bytes 
.................... 		}; 
.................... 	}; 
.................... } fileEntry; 
....................  
....................  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... typedef struct{ 
.................... 	unsigned int32 currentCluster; 
.................... 	unsigned int32 currentSector; 
.................... 	unsigned int16 posInSector;      //posicin actual al escribir en el sector 
.................... 	unsigned int32 sectorAtFAT;      //sector de la 1 FAT en el que tenemos el actual puntero de cierre de fichero 
....................  
.................... 	unsigned int32 sectorEntryFile; //direccin del sector de entradas de fichero 
.................... 	unsigned int8  EntryFile[512];  //sector donde est la entrada (root) del fichero (para actualizar tamao) 
.................... 	unsigned int16 offsetEntry;     //offset en el sector de entradas del fichero 
.................... 	unsigned int32 size;            //tamao del fichero 
.................... }_file; 
....................  
.................... _file file; 
....................  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... typedef struct _diskinforec{ 
....................    unsigned int8  jmpBoot[3];   // bytes  0.. 2: Salto a la rutina de arranque 
....................    unsigned int8  OEMName[8];   // bytes  3..10: Es una cadena "MSDOS5.0" 
....................    unsigned int16 BytsPerSec;   // bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes) 
....................    unsigned int8  SectPerClus;  // byte  13:    Numero de sectores contenidos en 1 cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes 
....................    unsigned int16 RsrvdCnt;     // bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente 
....................    unsigned int8  NumFATs;      // byte  16:    Numero de tablas FAT en el volumen. Habitualmente es 2 
....................    unsigned int16 RootEntCnt;   // bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0 
....................    unsigned int16 TotSect16;    // bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0) 
....................    unsigned int8  Media;        // byte  21:    Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0 
....................    unsigned int16 FATsz16;      // bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0) 
....................    unsigned int16 SectPerTrack; // bytes 24..25: Sectores por track 
....................    unsigned int16 NumHeads;     // bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.) 
....................    unsigned int32 HiddSec;      // bytes 28..31: Sectores ocultos que preceden a la particion (irrelevante en uSD) 
....................    unsigned int32 TotSect32;    // bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta 
....................    unsigned int32 FATsz32;      // bytes 36..39: Numero de sectores ocupados por una FAT 
....................    unsigned int16 ExtFlags;     // bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0) 
....................    unsigned int16 FSVer;        // bytes 42..43: Version del sistema de archivos (empleamos la 0.0) 
....................    unsigned int32 RootClus;     // bytes 44..47: Indica el numero del 1er cluster del directorio raiz. 
....................    unsigned int16 FSInfo;       // bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1) 
....................    unsigned int16 BkBootSec;    // bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque 
....................    unsigned int8  RsrvdSys[12]; // bytes 52..63: Bytes reservados para futuros usos del sistema 
....................    unsigned int8  DrvNum;       // byte  64:     Numero de la unidad (para MSDOS pero irrelevante en uSD). 
....................    unsigned int8  Reserved1;    // byte  65:     Windows NT para formatear un volumen pone este byte a 0 
....................    unsigned int8  BootSig;      // byte  66:     Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows) 
....................    unsigned int32 VolId;        // bytes 67..70: Numero de volumen (generado por el reloj del sistema). 
....................    unsigned int8  VolLab[11];   // bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME     ". Nosotros podemos poner "NUUBO_SD    " 
....................    unsigned int8  FilSysType[8];// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   " 
....................    unsigned int8  spam[420];    // bytes 90..509:Zona de codigo (no lo empleamos y esta a 0) 
....................    unsigned int16 firma;        // byte 510..511:Debe de vale 55 AA 
.................... } diskinforec; 
....................  
.................... diskinforec DiskInfo; 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... unsigned  int8 FATType; // FAT16 o FAT32 
.................... //variables clave: inicio de la FAT1 y la FAT2 y de las entradas de ficheros 
.................... unsigned  int8 sect_x_cluster; 
.................... unsigned int16 sect_fat_1; 
.................... unsigned int16 sect_fat_2; 
.................... unsigned int32 sect_ini_datos; 
.................... unsigned int32 sect_x_fat; 
.................... unsigned int32 sect_entry; 
.................... unsigned int16 sect_reserv; 
....................  
.................... //unsigned int8 dFil[32]; 
.................... unsigned int32 sector_fat32[MAX_ENTRIES_SECTOR_FAT32]; // 128 x 4 = 512 
.................... unsigned int16 sector_fat16[MAX_ENTRIES_SECTOR_FAT16]; // 256 x 2 = 512 
....................  
.................... //atributos 
.................... #define __FILE		0x20 
.................... #define _DIRECTORY	0x10 
.................... #define _VOLUMEN	0x08 
.................... #define _SYSTEM		0x04 
.................... #define _HIDDEN		0x02 
.................... #define READONLY	0x01 
....................  
.................... ///variables globales 
.................... unsigned int16 year = 2020; 
.................... unsigned int8 yearLo=   20; 
.................... unsigned int8 month =   10; 
.................... unsigned int8 day   =	15; 
.................... unsigned int8 hour	=   12; 
.................... unsigned int8 minute=   34; 
.................... unsigned int8 second=   56; 
....................  
.................... ///funciones 
.................... #define getHour() (int16)((int16)hour << 11) + (int16)((int16)minute << 5) + (int16) (second >> 1)		//5 bits: horas, 6 bits: minutos, 5 bits: segundos/2 
.................... #define getDate() (((int16)year - 1980) << 9 ) + ((int16)month << 5) + (int16)day	//7 bits: ao (desde 1980), 4 bits: mes, 5 bits: dia 
....................  
....................  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... void initFAT(){ 
....................    unsigned int32 startClusterOfRootDirectory = 2; 
....................    unsigned int32 sctrs; 
....................    unsigned  int8 *ptrSct; 
....................    diskinforec *ptrDiskInfo; 
....................  
.................... 	sd_read_block(LBA0, dt); 
....................     						ptrDiskInfo=&DiskInfo; 
....................     						ptrSct= &dt[0]; 
....................    	memcpy((*ptrDiskInfo).jmpBoot, (ptrSct +  0), 3); 			//DiskInfo.jmpBoot[3]	// bytes  0.. 2: Salto a la rutina de arranque 
....................    	memcpy((*ptrDiskInfo).OEMName, (ptrSct +  3), 8); 			//DiskInfo.OEMName[8]	// bytes  3..10: Es una cadena, habitualmente "MSDOS5.0" 
....................    	DiskInfo.BytsPerSec = make16(dt[12],dt[11]);   				// bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes) 
.................... 	DiskInfo.SectPerClus = dt[13];								// byte  13:	 Numero de sectores contenidos en un cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes 
.................... 	DiskInfo.RsrvdCnt = make16(dt[15],dt[14]);					// bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente 
....................    	DiskInfo.NumFATs = dt[16];									// byte  16:	 Numero de tablas FAT en el volumen. Habitualmente es 2 
.................... 	DiskInfo.RootEntCnt = make16(dt[18],dt[17]);				// bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0 
....................    	DiskInfo.TotSect16 = make16(dt[20],dt[19]);					// bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0) 
.................... 	DiskInfo.Media = dt[21];									// byte  21:	 Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0 
.................... 	DiskInfo.FATsz16 = make16(dt[23],dt[22]);					// bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0) 
.................... 	DiskInfo.SectPerTrack = make16(dt[25],dt[24]); 				// bytes 24..25: Sectores por track 
....................    	DiskInfo.NumHeads = make16(dt[27],dt[26]);					// bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.) 
.................... 	DiskInfo.HiddSec = make32(dt[31],dt[30],dt[29],dt[28]);		// bytes 28..31: Sectores ocultos que preceden a la particion 
.................... 	DiskInfo.TotSect32=make32(dt[35],dt[34],dt[33],dt[32]);		// bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta 
.................... 	DiskInfo.FATsz32 = make32(dt[39],dt[38],dt[37],dt[36]);		// bytes 36..39: Numero de sectores ocupados por una FAT 
.................... 	DiskInfo.ExtFlags = make16(dt[41],dt[40]); 					// bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0) 
.................... 	DiskInfo.FSVer = make16(dt[43],dt[42]); 					// bytes 42..43: Version del sistema de archivos (empleamos la 0.0) 
.................... 	DiskInfo.RootClus= make32(dt[47],dt[46],dt[45],dt[44]);		// bytes 44..47: Indica el numero del 1er cluster del directorio raiz. 
.................... 	DiskInfo.FSInfo = make16(dt[49],dt[48]); 					// bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1) 
.................... 	DiskInfo.BkBootSec = make16(dt[51],dt[50]); 				// bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque 
.................... 	//  Estructura en el caso de FAT32                                                                                                                          
.................... 	memcpy((*ptrDiskInfo).RsrvdSys, (ptrSct +  52), 12);		//DiskInfo.RsrvdSys[12] 	// bytes 52..63: Bytes reservados para futuros usos del sistema 
.................... 	DiskInfo.DrvNum = dt[64];								 	// byte  64: 	 Numero de la unidad 
.................... 	DiskInfo.Reserved1 = dt[65];								// byte  65: 	 Windows NT para formatear un volumen pone este byte a 0 
.................... 	DiskInfo.BootSig = dt[66]; 									// byte  66: 	 Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows) 
.................... 	DiskInfo.VolId = make32(dt[70],dt[69],dt[68],dt[67]); 		// bytes 67..70: Numero de volumen (generado por el reloj del sistema). 
.................... 	memcpy((*ptrDiskInfo).VolLab, (ptrSct +  71), 11);			//DiskInfo.VolLab[11]	// bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME    " 
.................... 	memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  82), 8);		//DiskInfo.FilSysType[8] 	// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   " 
.................... 	memcpy((*ptrDiskInfo).spam, (ptrSct +  90),420);			//DiskInfo.spam[420]		// bytes 90..509:Zona de codigo (en uSD no se emplea y suele estar a 0) 
.................... 	DiskInfo.firma = make16(dt[510],dt[511]);								// byte 510..511:Debe de vale 55 AA 
....................  
....................    		FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'3''2' 
....................  
....................    if(FATType == 32){ 
.................... 						sect_x_fat  = DiskInfo.FATsz32;		// Sectores reservados para la FAT 
.................... 						startClusterOfRootDirectory = DiskInfo.RootClus; 
....................  	}else{ 
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);	//DiskInfo.FilSysType[8] 	// bytes 54..61: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT16   " 
.................... 						FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'1''6' 
.................... 	} 
....................  
.................... 	if(FATType == 16){ 
.................... 						DiskInfo.VolId = make32(dt[42],dt[41],dt[40],dt[39]); 
.................... 						memcpy((*ptrDiskInfo).VolLab, (ptrSct +  43), 11); 
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8); 
....................  
.................... 						sect_x_fat  = DiskInfo.FATsz16;		// Sectores reservados para la FAT 
.................... 						startClusterOfRootDirectory = DiskInfo.RootEntCnt; 
....................  					} 
....................  
....................   	sect_x_cluster = DiskInfo.SectPerClus;					// Cada cluster tiene este numero de sectores 
....................  
....................     			      sctrs  = LBA0; 
.................... 				  	  sctrs += DiskInfo.RsrvdCnt; 
.................... 	sect_reserv 	= sctrs;								// sectores reservados por el sistema 
....................  
....................     sect_fat_1  	= sctrs;               					// A partir de ah: FAT 1 
.................... 				  	  sctrs += sect_x_fat; 
.................... 	sect_fat_2  	= sctrs;;								// A partir de ah: FAT 2 (copia de seguridad) 
.................... 				  	  sctrs += sect_x_fat; 
.................... 	sect_entry  	= sctrs ;      							// A partir de ah empieza el raz (la lista de ficheros) 
.................... 					  sctrs += sect_x_cluster; 
.................... 	sect_ini_datos 	= sctrs ;								// A partir de ahi los datos del fichero 
....................  
....................     if(FATType == 16)										// RootEntCnt: Numero de entradas de 32 bytes al 
....................     sect_ini_datos = sect_entry+(DiskInfo.RootEntCnt>>4);	// directorio raiz. Habitualmente FAT16= 512 y FAT32= 0 
....................  
.................... }//fin initFAT() 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... void cargaConfig(unsigned int32 j); 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... // unsigned int8 encontrar_fichero(){ 
.................... //    unsigned int8 FicheroEncontrado = 0; 
.................... //    unsigned int32 i; 
.................... //    unsigned int16 j; 
.................... //    unsigned int32 SctStart = sect_entry;			//inicio Root 
.................... //    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root 
.................... //    unsigned int32 ClstIni  = ((FATType==16)?1:2); 
.................... // 
.................... //    unsigned int32 ClstNxt; 
.................... //    unsigned int32 sctrClstr; 
.................... //    unsigned int32 posSctr; 
.................... //    unsigned int32 clstrSig; 
.................... // 
.................... //    for(i = SctStart; i < SctEnd; i++){ 
.................... // 	      sd_read_block(i, dt); 
.................... // 		 for(j = 0; j < 512; j += 32){ 
.................... // 										if(	(dt[j + 0] == 'C')&& 
.................... // 											(dt[j + 1] == 'O')&& 
.................... // 											(dt[j + 2] == 'N')&& 
.................... // 											(dt[j + 3] == 'F')&& 
.................... // 											(dt[j + 4] == 'I')&& 
.................... // 											(dt[j + 5] == 'G')&& 
.................... // 											(dt[j + 6] == ' ')&& 
.................... // 											(dt[j + 7] == ' ')&& 
.................... // 											(dt[j + 8] == 'T')&& 
.................... // 											(dt[j + 9] == 'X')&& 
.................... // 											(dt[j + 10]== 'T')){ 
.................... // 																 cargaConfig(j); 
.................... // 																 FicheroEncontrado = 1; 
.................... // 																 return FicheroEncontrado; 
.................... // 																}//fin if(CNF) 
.................... // 
.................... // 		}//j 
.................... //    }//i 
.................... //    return FicheroEncontrado; 
.................... // } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... void cargaConfig(unsigned int32 j){ 
....................    unsigned int32 direccion; 
....................    unsigned int32 _sector; 
....................  
.................... 	if(FATType==16){ 
.................... 	   	direccion = make32(0,0,dt[j+27],dt[j+26]); 
.................... 		_sector = ((unsigned int32)direccion - 2) * sect_x_cluster + sect_ini_datos; 
.................... 	} 
.................... 	if(FATType==32){ 
.................... 	   direccion = make32(dt[j+21],dt[j+20],dt[j+27],dt[j+26]); //en FAT32 se usa EAIndex + first cluster 
.................... 	   _sector = ((unsigned int32)direccion - 3) * sect_x_cluster + sect_ini_datos; 
....................    } 
....................    sd_read_block(_sector, dt); //leer el primer sector de los datos del fichero 
....................  
....................    // Ahora en el vector dt tengo los datos del fichero y puedo emplearlo 
....................    // Por ejemplo: el texto que indica la hora y minutos del ensayo lo obtendria como: 
....................    // hora   = (dt[140]-'0')*10 + dt[141]-'0' ; 
....................    // minutos= (dt[143]-'0')*10 + dt[144]-'0' ; 
....................    // ... Y con esos datos haria algo util 
....................  
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
....................  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart); 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... unsigned int8 inicializa_fichero(){ 
....................    unsigned int8 FicheroIncializado = 0; 
....................    unsigned int32 i; 
....................    unsigned int16 j; 
....................    unsigned int32 SctStart = sect_entry;			//inicio Root 
....................    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root 
....................    unsigned int32 ClstIni  = ((FATType==16)?0:1); 
....................  
....................    unsigned int32 ClstNxt; 
....................    unsigned int32 sctrClstr; 
....................    unsigned int32 posSctr; 
....................    unsigned int32 clstrSig; 
....................  
....................    unsigned int32 startCluster;      //cluster donde empezaran los datos del fichero 
....................    fileEntry newFile; 
....................  
....................    for(i = SctStart; i < SctEnd; i++){ 
.................... 	      sd_read_block(i, dt); 
.................... 		  for(j = 0; j < 512; j += 32){ 
.................... 			if((dt[j] == 0x00) || dt[j] == 0xFF){ 
.................... 					   newFile.fields.name[0] = 		'L'; 
.................... 					   newFile.fields.name[1] = 		'A'; 
.................... 					   newFile.fields.name[2] = 		'T'; 
.................... 					   newFile.fields.name[3] = 		'I'; 
.................... 					   newFile.fields.name[4] = 		'D'; 
.................... 					   newFile.fields.name[5] = 		'O'; 
.................... 					   newFile.fields.name[6] = 		'S'; 
.................... 					   newFile.fields.name[7] = 		'_'; 
.................... 					   newFile.fields.extension[0] = 	'T'; 
.................... 					   newFile.fields.extension[1] = 	'X'; 
.................... 					   newFile.fields.extension[2] = 	'T'; 
.................... 					   newFile.fields.reserved = 0; 
.................... 					   newFile.fields.createTimeMs = 0; 
.................... 					   newFile.fields.create_hour = getHour(); 
.................... 					   newFile.fields.create_date = getDate(); 
.................... 					   newFile.fields.last_access = newFile.fields.create_date; 
.................... 					   newFile.fields.eaIndex = 0; 
.................... 					   newFile.fields.attrib = __FILE | READONLY;   //archivo normal + slo lectura 
.................... 					   newFile.fields.modif_hour = newFile.fields.create_hour; 
.................... 					   newFile.fields.modif_date = newFile.fields.create_date; 
.................... 					   newFile.fields.first_cluster = 0; 
.................... 					   newFile.fields.size = 0; 
....................  
.................... 					   file.offsetEntry = j; 
.................... 					   file.sectorEntryFile = i; 
.................... 					   sd_read_block(file.sectorEntryFile, file.EntryFile); 
....................  
.................... 					   for(i = 0; i < 32; j++, i++)  dt[j] = newFile.raw[i]; 
.................... 					   for(i = 0; i < 512; i++)      file.EntryFile[i] = dt[i]; 
.................... 					   file.posInSector    = 0;   															//empezamos en un sector y cluster nuevos 
.................... 					   if(FATType==16){ 
.................... 					   startCluster = encontrarCluster(2);         											//busco cluster donde empezara a almacenarse los datos 
.................... 					   file.currentCluster = startCluster;   												//que ser el cluster en el que escribiremos 
.................... 					   file.currentSector  = (file.currentCluster -  2) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster) 
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 8) + sect_reserv;						//sector en la FAT donde marcar el cluster usado 
.................... 					   } 
.................... 					   if(FATType==32){ 
.................... 					   startCluster = encontrarCluster(3);         											//busco cluster donde empezara a almacenarse los datos 
.................... 					   file.currentCluster = startCluster;   												//que ser el cluster en el que escribiremos 
.................... 					   file.currentSector  = (file.currentCluster -  3) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster) 
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 7) + sect_reserv;						//sector en la FAT donde marcar el cluster usado 
.................... 					   } 
.................... 					   file.EntryFile[file.offsetEntry + 27] = make8(file.currentCluster, 1); 					//1er cluster del archivo 
.................... 					   file.EntryFile[file.offsetEntry + 26] = make8(file.currentCluster, 0); 
.................... 					   file.EntryFile[file.offsetEntry + 21] = make8(file.currentCluster, 3); 
.................... 					   file.EntryFile[file.offsetEntry + 20] = make8(file.currentCluster, 2); 
.................... 					   file.size = 0;																			//Inicialmente el tamao es cero 
....................  
.................... 					   if(FATType==16){ 
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile); 
.................... 						sd_read_block (file.sectorAtFAT, sector_fat16); 
.................... 						sector_fat16[file.currentCluster % MAX_ENTRIES_SECTOR_FAT16] = ENDFILE16;				//marco el cluster como usado 
.................... 						sd_write_block( file.sectorAtFAT, sector_fat16); 
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat16);   //FAT2					//Ojo! la cosa puede ser mas complicada... 
.................... 						} 
.................... 					   if(FATType==32){ 
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile); 
.................... 						sd_read_block (file.sectorAtFAT,sector_fat32); 
.................... 						sector_fat32[file.currentCluster % MAX_ENTRIES_SECTOR_FAT32] = ENDFILE32;				//marco el cluster como usado 
.................... 						sd_write_block( file.sectorAtFAT, sector_fat32); 
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat32);   //FAT2					//Ojo! la cosa puede ser mas complicada... 
.................... 						} 
.................... 					   FicheroIncializado = 1; 
.................... 					   return FicheroIncializado; 
.................... 					   } 
....................  
.................... 		}//j 
....................    }//i 
....................    return FicheroIncializado; 
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart){ 
....................    unsigned int32 cluster; 
....................    unsigned int32 _sector;   //recorrer sectores 
....................    unsigned int32 bytes;     //recorrer bytes en cada sector 
....................  
....................    cluster =  clusterStart; 
....................    if(FATType==16) 
....................    _sector = (clusterStart >> 2) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante 
....................    if(FATType==32) 
....................    _sector = (clusterStart >> 3) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante 
....................    bytes = (clusterStart % ((FATType==16) ? MAX_ENTRIES_SECTOR_FAT16 : MAX_ENTRIES_SECTOR_FAT32)); 
....................  
....................    if(FATType==32){ 
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT 
.................... 		  sd_read_block(_sector,sector_fat32); 							//leemos el sector 
....................     					      for(; bytes < MAX_ENTRIES_SECTOR_FAT32; bytes++){ //recorremos el sector para buscar un puntero a cluster libre 
.................... 					         if(sector_fat32[bytes]== 0){ 
.................... 					            if(cluster < 3)               continue;  	//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando 
.................... 					            return cluster; 
.................... 					         }//fin if 
.................... 					         cluster++; 
.................... 					      }//fin for de recorrer bytes dentro de un sector 
.................... 	      bytes = 0; 
.................... 	   }//fin for de recorrer sectores 
....................    }else 
....................     if(FATType==16){ 
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT 
.................... 		  sd_read_block(_sector,sector_fat16); 							//leemos el sector 
....................  
.................... 					      for(; bytes < MAX_ENTRIES_SECTOR_FAT16; bytes++){ 	//recorremos el sector para buscar un puntero a cluster libre 
.................... 					         if(sector_fat16[bytes]== 0){ 
.................... 					            if(cluster < 2)               continue;		//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando 
.................... 					            return cluster; 
.................... 					         }//fin if 
.................... 					         cluster++; 
.................... 					      }//fin for de recorrer bytes dentro de un sector 
.................... 	      bytes = 0; 
.................... 	   }//fin for de recorrer sectores 
.................... 	} 
....................    return ((FATType==16)?ENDFILE16:ENDFILE32); 
.................... }//fin encontrarCluster 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... void escribe_datos_en_fichero(){ 
....................    unsigned int32 relSector; 
....................    unsigned int32 nextCluster; 
....................    unsigned int32  oldCluster; 
....................    unsigned int16 _hour, date; 
....................  
.................... 	sd_write_block(file.currentSector, dt); 
....................  
....................  
....................  
....................  
.................... 		file.currentSector++;																					//actualizar las FATs 
.................... 		if(FATType==16) 
.................... 	    relSector= file.currentSector - ((file.currentCluster -  2) * sect_x_cluster + sect_ini_datos); 
.................... 		if(FATType==32) 
.................... 	    relSector= file.currentSector - ((file.currentCluster -  3) * sect_x_cluster + sect_ini_datos); 
....................  
.................... 	    if((relSector % sect_x_cluster) == 0){   											//el siguiente sector est en cluster nuevo? 
.................... 	      oldCluster = 	file.currentCluster; 
.................... 	      nextCluster = encontrarCluster(oldCluster);   									//siguiente cluster 
.................... 	      //escribirCluster(oldCluster, nextCluster);  										//marcar actual cluster para que apunte al siguiente 
.................... 	      file.currentCluster = nextCluster; 
.................... 		  if(FATType==16) 
.................... 	      file.currentSector = (nextCluster - 2) * sect_x_cluster + sect_ini_datos; 
.................... 		  if(FATType==32) 
.................... 	      file.currentSector = (nextCluster - 3) * sect_x_cluster + sect_ini_datos; 
.................... 	   } 
....................  
.................... 	   //actualizar el tamao del fichero y fechas 
.................... 	   file.size += 512; 
.................... 	   file.EntryFile[file.offsetEntry + 28] = make8(file.size, 0);   //tamao 
.................... 	   file.EntryFile[file.offsetEntry + 29] = make8(file.size, 1); 
.................... 	   file.EntryFile[file.offsetEntry + 30] = make8(file.size, 2); 
.................... 	   file.EntryFile[file.offsetEntry + 31] = make8(file.size, 3); 
.................... 	   //ActualizaReloj(); 
.................... 	   _hour = getHour(); 
.................... 	   date = getDate(); 
.................... 	   file.EntryFile[file.offsetEntry + 24] = make8(date, 0);       //fecha modif 
.................... 	   file.EntryFile[file.offsetEntry + 25] = make8(date, 1); 
.................... 	   file.EntryFile[file.offsetEntry + 22] = make8(_hour, 0);      //hora modif 
.................... 	   file.EntryFile[file.offsetEntry + 23] = make8(_hour, 1); 
.................... 	   file.EntryFile[file.offsetEntry + 18] = file.EntryFile[file.offsetEntry + 24];   //fecha ltimo acceso 
.................... 	   file.EntryFile[file.offsetEntry + 19] = file.EntryFile[file.offsetEntry + 25]; 
....................  
.................... 	   sd_write_block(file.sectorEntryFile, file.EntryFile);  	// Actualiza root 
....................  
.................... } 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #endif // __MIFAT_H 
....................  
.................... #include "sdcard.h" 
....................  
.................... #ifndef __SDCARD_H 
.................... #define __SDCARD_H 
....................  
.................... #bit  SPIRBF    = getenv("SFR:SPI1STAT").0 
.................... #bit  SPITBF    = getenv("SFR:SPI1STAT").1 
.................... #bit  SPIROV    = getenv("SFR:SPI1STAT").6 
.................... #byte SPI1BUF   = getenv("SFR:SPI1BUF") 
.................... #byte SPI1STAT  = getenv("SFR:SPI1STAT") 
.................... #byte SPI1CON1  = getenv("SFR:SPI1CON1") 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #define   CMD0              		0x40      //go to idle				//Commands 
.................... #define   CMD1               		0x41      //initialization process 
.................... #define   CMD8               		0x48      //verify interface 
.................... #define   CMD17              		0x51      //read single block 
.................... #define   CMD24              		0x58      //write single block 
.................... #define   CMD55              		0x77      //escape for app specific command 
.................... #define   CMD58              		0x7a      //read OCR 
.................... #define   ACMD41             		0x69      //poll operation range 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #define   R1_READY_STATE          	0x00      //sd ready				//Responses 
.................... #define   R1_IDLE_STATE           	0x01      //card in idle state 
.................... #define   R1_ILLEGAL_COMMAND      	0x04      //illegal command 
.................... #define   DATA_START_BLOCK       	0xFE      //start token for read or write 
.................... #define   DATA_RES_MASK          	0x1F      //mask for data response 
.................... #define   DATA_RES_ACCEPTED      	0x05      //write accepted 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... unsigned int8 sdhc; 
.................... unsigned int8 dt[512];            /// Buffer de escritura  en uSD 
.................... unsigned int32 LBA0 = 0; 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... inline unsigned int8 xfer_spi(char envio){ 
....................    SPIROV = 0; 
....................    SPI1BUF= envio; 
....................    while( SPITBF); 
....................    while(!SPIRBF); 
....................    return SPI1BUF; 
.................... }//fin xfer_spi 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... unsigned int8 Commnd(char befF, int32 SD_Adress, char befH){ 
....................    unsigned int8 iC1; 
....................    xfer_spi(0xFF); 
....................    xfer_spi(befF); 
....................    xfer_spi(make8(SD_Adress, 3)); 
....................    xfer_spi(make8(SD_Adress, 2)); 
....................    xfer_spi(make8(SD_Adress, 1)); 
....................    xfer_spi(make8(SD_Adress, 0)); 
....................    xfer_spi(befH); 
....................     do{iC1 = xfer_spi(0xFF); 
....................    }while(iC1 == 0xFF); 
....................    return iC1; 
.................... }//fin Commnd 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr); 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... unsigned int8 sd_init(){ 
....................  unsigned  int8 R[17]={0}, versionSD= 1, crc; 
....................  unsigned int16 iI; 
....................  unsigned int32 arg=0; 
....................  
....................  setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_16); 
....................  
....................  memset(dt,0,512); 
....................  // CMD0 - GO_IDLE_STATE  (R1)  Card Reset                         
.................... 	do{	output_high(CS);   	// tarjeta deshabilitada 
.................... 		for (iI = 0; iI < 10; iI++)  	xfer_spi(0xFF); 
.................... 		output_low(CS); 	// tarjeta habilitada 
.................... 		R[0] = Commnd( CMD0 , 0x00000000 , 0x95); //go to idle 
.................... 	}while( R[0] != R1_IDLE_STATE); 
....................   // CMD8 - SEND_IF_COND (R7)   Send Interface Condition Command              
....................   // Argument 00 - 00 - 01 (Voltage supplied = 2.7-3.6V) - AA (Check pattern) 
....................   // Response: illegal command -> Version 1 
....................   // Response: echo-back 	   -> Version 2 
.................... 	R[0] = Commnd(CMD8, 0x000001AA, 0x87); 
....................     if(R[0]& R1_ILLEGAL_COMMAND){	  			versionSD = 1; 
....................    			}else{	R[1] = xfer_spi(0xFF); 
.................... 					R[2] = xfer_spi(0xFF); 
.................... 					R[3] = xfer_spi(0xFF); 
.................... 					R[4] = xfer_spi(0xFF); 
.................... 				    if(R[4]!=0xAA){	output_high(CS); return 1; }		//error 
....................       											versionSD = 2; 
....................    			} 
....................  
....................   // ACMD41 - SD_SEND_OP_ COND (R1)   Initialization Command                 
....................   // If host supports SDHC or SDXC: HCS (Host Capacity Support) is set to 1 (arg= 0x40000000) 
....................   // If host only support SDSC:     HCS (Host Capacity Support) is set to 0 (arg= 0) 
....................    arg = (versionSD == 2) ? 0x40000000 : 0; 
....................    crc = (versionSD == 2) ? 0x77 : 0xFF; 
....................  
....................  
....................    do{            Commnd(CMD55,    0, 0x65);	// El proceso puede llegar a durar hasta 1 segundo 
....................            R[0] = Commnd(ACMD41, arg, crc);		// Application-Specific Command  APP_CMD (CMD55) 
.................... 		   delay_ms(4); 
....................    }while(R[0] != R1_READY_STATE); 
....................  
....................   if(versionSD == 2){ 
....................  
....................   //                                             
....................   // CMD58 - READ_OCR (R3)                                  
....................   // Bit 30 - Card Capacity Status bit: 	0 indicates that the card is SDSC. 
....................   //										1 indicates that the card is SDHC or SDXC 
.................... 	R[0] = Commnd(CMD58, 0x00000000, 0xFF); 
....................     if(R[0] == R1_READY_STATE){	R[1] = xfer_spi(0xFF); 
.................... 								R[2] = xfer_spi(0xFF); 
.................... 								R[3] = xfer_spi(0xFF); 
.................... 								R[4] = xfer_spi(0xFF); 
.................... 								sdhc = ((R[1]& 0xC0) == 0xC0) ? 1 : 0; 
....................    			}else{				output_high(CS); return 1; }		//error 
....................   //                                             
....................  
....................   }// versionSD == 2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
....................   setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_1); 
....................  
....................   //                                             
.................... 	sd_read_block(0, dt);	//Lee el sector fisico 0 para obtener el LBA0 
.................... 	if(dt[510]==0x55) 
.................... 	if(dt[511]==0xAA){ 		// Efectivamente parece que estoy en sct 0 
.................... 							// Tabla de particiones 
.................... 								LBA0 = make32(dt[457],dt[456],dt[455],dt[454]); 
.................... 								if(dt[0]==0xEB) // MBR 
....................  								LBA0 = 0; 
.................... 						  }//55AA 
....................   //                                             
....................  
....................   output_high(CS);   									// tarjeta deshabilitada 
....................   return 0; 
.................... }//char sd_init()- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr){ 
....................    unsigned int16 iW; 
....................  
....................    if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores 
....................    output_low(CS); 
....................  
.................... 		iW = Commnd(CMD24, address, 0xFF); 
....................     if( iW == R1_READY_STATE){ 
....................              								              		xfer_spi(0xFF); 
....................                               									xfer_spi(DATA_START_BLOCK);   // Data start token 
....................                            			for(iW = 0; iW < 512; iW++)  xfer_spi(ptr[iW]); 
....................                            							xfer_spi(0xFF);   // Dummy bytes 
....................                           							xfer_spi(0xFF);   // en lugar del CRC16 
....................  
....................                         do{       iW = xfer_spi(0xFF); 
....................                         }while( (iW & DATA_RES_MASK) != DATA_RES_ACCEPTED); 
....................  
....................                         do{       iW = xfer_spi(0xFF); delay_us(100); 
....................                         }while(   iW == 0 ); 
....................  
.................... 						xfer_spi(0xFF); 
.................... 						xfer_spi(0xFF); 
....................  
....................    						output_high(CS);   return 0; //correcto 
.................... 						} 
....................    						output_high(CS);   return 1; //error 
.................... }//fin sd_write_block 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr){ 
....................    unsigned int16 jR; 
....................    unsigned int8  iR; 
....................  
....................     if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores 
....................     output_low(CS); 
....................  
....................        iR  = Commnd(CMD17, address, 0xFF); 
....................     if(iR == R1_READY_STATE){ 
.................... 								do{     iR  = xfer_spi(0xFF); 
.................... 								}while( iR != DATA_START_BLOCK); 
....................  
.................... 								if(iR == DATA_START_BLOCK){ 
.................... 								for(jR = 0; jR < 512; jR++) 
.................... 								         ptr[jR] = xfer_spi(0xFF); 
.................... 								xfer_spi(0xFF); 
.................... 								xfer_spi(0xFF); 
.................... 								xfer_spi(0xFF); 
....................   								} 
....................  
....................    							output_high(CS);      return 0; 
.................... 							} 
.................... 							output_high(CS);      return 1; 
.................... }//fin sd_read_block 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #endif // __SDCARD_H 
....................  
....................  
.................... void sd_init_global(); 
.................... void escritura_sd(); 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... //Inicializacin de la SD 
.................... void sd_init_global(){ 
....................   set_tris_b(0b1111111110011111); 
....................   set_tris_c(0b1111111111011111); 
....................   delay_ms(30); 
....................  
....................   sd_init();	// Inicializa micro SD 
....................  
....................   initFAT();	// Carga los parametros del sistema de ficheros 
....................  
.................... } 
....................  
.................... //Escritura en el fichero LATIDOS 
.................... void escritura_sd(){ 
....................   inicializa_fichero(); 
....................   enable_interrupts(INT_TIMER2); 
....................   memset(dt,0,512); 
....................   k = 0; 
....................   OFF(H2); 
....................  
....................   while(k<15); 
....................   disable_interrupts(INT_TIMER2); 
....................   escribe_datos_en_fichero(); 
....................   for(;;) 
....................   { 
....................     ON(H2); 
....................   } 
.................... } 
....................  
.................... #endif // __SD_CARD_H 
....................  
.................... #include "BLUETOOTH.h" 
.................... #ifndef Bluetooth_h 
.................... #define Bluetooth_h 
.................... #include "Header.h" 
.................... #ifndef HEADER_h 
.................... #define HEADER_h 
.................... //------------------------------------------------------------------- 
....................  
.................... #include "33FJ128MC804.h" 
....................  
.................... #fuses NOJTAG      // JTAG port is disabled 
.................... #fuses NOPROTECT   // Code protection is disabled 
.................... #fuses NOWRT       // Writes to program memory are allowed 
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1 
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled 
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED) 
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled 
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV) 
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled 
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15) 
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #use delay(clock=7370000) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #define ON(pin)   output_high(pin) 
.................... #define OFF(pin)   output_low( pin) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... //#define SDA1         PIN_B9  //                    ( 1) 
.................... #define BUZZER         PIN_C6  //                    ( 2) 
.................... #define LED1           PIN_C7  //                    ( 3) 
.................... #define LED2           PIN_C8  //                    ( 4) 
.................... #define LED3           PIN_C9  //                    ( 5) 
.................... //                     VSS     //                    ( 6) 
.................... //                     VCAP    //                    ( 7) 
.................... #define H3             PIN_B10 //                    ( 8) 
.................... #define L3             PIN_B11 //                    ( 9) 
.................... #define H2             PIN_B12 //                    (10) 
.................... #define L2             PIN_B13 //                    (11) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #define _I             PIN_A10 //                    (12) 
.................... #define BTOK           PIN_A7  //                    (13) 
.................... #define H1             PIN_B14 //                    (14) 
.................... #define L1             PIN_B15 //                    (15) 
.................... //                     AVSS    //                    (16) 
.................... //                     AVDD    //                    (17) 
.................... //                     ~MCLR   //                    (18) 
.................... #define BTIN           PIN_A0  //                    (19) 
.................... #define POT  		       PIN_A1  //                    (20) 
.................... //                     PIN_B0  //                    (21) 
.................... //                     PIN_B1  //                    (22) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #define ANL4           PIN_B2  //                    (23) 
.................... #define ANL3           PIN_B3  //                    (24) 
.................... #define ANL2           PIN_C0  //                    (25) 
.................... #define SD             PIN_C1  //                    (26) 
.................... #define ANL1           PIN_C2  //                    (27) 
.................... //                     VDD     //                    (28) 
.................... //                     VSS     //                    (29) 
.................... //                     PIN_A2  //                    (30) 
.................... //                     PIN_A3  //                    (31) 
.................... #define BTCM           PIN_A8  //                    (32) 
.................... //                     PIN_B4  //                    (33) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... //                     PIN_A4  //                    (34) 
.................... #define COMM           PIN_A9  //                    (35) 
.................... #pin_select U1TX =     PIN_C3  //                    (36) 
.................... #pin_select U1RX =     PIN_C4  //                    (37) 
.................... #define CS             PIN_C5  //                    (38) 
.................... //                     VSS     //                    (39) 
.................... //                     VDD     //                    (40) 
.................... #pin_select SDI1 =     PIN_B5  //                    (41) 
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42) 
.................... #pin_select SDO1 =     PIN_B7  //                    (43) 
.................... //#define SCL1         PIN_B8  //                    (44) 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... #endif 
....................  
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #use rs232(UART1,baud=115200,STREAM=BT) 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... void init_BT(void); //inits and enables uart isr 
.................... void enviar_datos(unsigned int16 ppm); 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... void init_BT(void) 
.................... { 
....................   	fprintf(BT,"$$$");	     delay_ms(500); // command mode 
....................   	fprintf(BT,"SF,1\r");      delay_ms(500); // factory defaults 
....................   	fprintf(BT,"SA,0\r");      delay_ms(500); // authentication 'Open' 
....................   	fprintf(BT,"R,1\r");       delay_ms(500); // Run device 
.................... } 
....................  
.................... void enviar_datos(unsigned int16 ppm) 
.................... { 
.................... 	COM: 
.................... 	while(!input(COMM)); 
*
00CE8:  BSET.B  2C1.1
00CEA:  BTSS.B  2C3.1
00CEC:  BRA     CE8
.................... 		fprintf(BT,"$Representacion grafica,Funcion,datos 1\n"); 
00CEE:  MOV     #0,W1
00CF0:  MOV     W1,W0
00CF2:  CLR.B   1
00CF4:  CALL    200
00CF8:  INC     W1,W1
00CFA:  BTSC.B  223.1
00CFC:  BRA     CFA
00CFE:  MOV     W0,224
00D00:  MOV     #27,W0
00D02:  CPSGT   W1,W0
00D04:  BRA     CF0
....................  		fprintf(BT,"&0,1000,0,1,0\n"); 
00D06:  MOV     #0,W1
00D08:  MOV     W1,W0
00D0A:  CLR.B   1
00D0C:  CALL    236
00D10:  INC     W1,W1
00D12:  BTSC.B  223.1
00D14:  BRA     D12
00D16:  MOV     W0,224
00D18:  MOV     #D,W0
00D1A:  CPSGT   W1,W0
00D1C:  BRA     D08
....................  		fprintf(BT,"#0,200,0,1,0\n"); 
00D1E:  MOV     #0,W1
00D20:  MOV     W1,W0
00D22:  CLR.B   1
00D24:  CALL    252
00D28:  INC     W1,W1
00D2A:  BTSC.B  223.1
00D2C:  BRA     D2A
00D2E:  MOV     W0,224
00D30:  MOV     #C,W0
00D32:  CPSGT   W1,W0
00D34:  BRA     D20
....................  
....................  		fprintf(BT, "%03d\n", ppm); 
00D36:  MOV     12EC,W0
00D38:  MOV     #8003,W4
00D3A:  CALL    BE8
00D3E:  BTSC.B  223.1
00D40:  BRA     D3E
00D42:  MOV     #A,W4
00D44:  MOV     W4,224
.................... 		delay_ms(4); 
00D46:  REPEAT  #3992
00D48:  NOP     
.................... 		if(!input(COMM)) 
00D4A:  BSET.B  2C1.1
00D4C:  BTSC.B  2C3.1
00D4E:  BRA     D54
.................... 		goto COM; 
00D50:  GOTO    CE8
00D54:  RETURN  
.................... } 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... #endif 
....................  
.................... #include "BEEP.h" 
.................... /** 
....................  @file    BEEP.h 
....................  @author  Julio Gomis-Tena 
....................  @brief   Generate n "beeps" of variable frequency 
.................... */ 
.................... // Do not write above this line (except comments)! 
....................  
.................... #ifndef __BEEP_H 
.................... #define __BEEP_H 
.................... #include "Header.h" 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #pin_select OC2 = BUZZER 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... void BEEP_Init(void); //Inicializa las frecuencias de los beeps y la separacin entre ellos 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... void BEEP(unsigned int8); //Realiza n beeps 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... void BEEP_Init(void)		//4kHz -> T/2= 125us 
.................... { 
.................... 	setup_timer3(TMR_INTERNAL|TMR_DIV_BY_1, 737); // 5kHz. Frecuencia de los beeps 
.................... 	set_compare_time(2, 0); 
.................... 	setup_compare(2, COMPARE_OFF); 
....................  
.................... 		// (11059200/2)/256/432 = 50 Hz  <-> 100ms 
.................... 	setup_timer4(TMR_INTERNAL|TMR_DIV_BY_8, 1843); 
.................... } 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... unsigned int8 N_beep; 
....................  
.................... void BEEP(unsigned int8 n) 
.................... { 
.................... 	if(n<127) 
.................... 		N_beep = 2*n; 
.................... 	else 
.................... 		N_beep = 255; 
....................  
.................... 	enable_interrupts(INT_TIMER4); 
.................... } 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #INT_TIMER4 
.................... void isr_TIMER4()			// Cada 100 ms. Espaciado entre beeps. Habra que asociarlo a una interrupcion por software 
.................... { 
.................... 		if((N_beep%2)==1) 
.................... 		{ 
.................... 			setup_compare(2, COMPARE_TOGGLE | COMPARE_TIMER3); 
.................... 		} 
.................... 		else 
.................... 		{ 
.................... 			setup_compare(2, COMPARE_OFF); 
.................... 			OFF(BUZZER); 
.................... 		} 
....................  
.................... 		if( N_beep>0 ) 
.................... 		{ 
.................... 		   	N_beep-=1; 
.................... 		} 
.................... 		else 
.................... 		{ 
.................... 			disable_interrupts(INT_TIMER4); 
.................... 		} 
.................... } 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
....................  
.................... #endif // __BEEP_H 
....................  
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
.................... #endif 
....................  
....................  
.................... unsigned int16 ppm; 
.................... int1 datos_flag; 
.................... char cadena[32]; 
.................... int jj; 
....................  
.................... #INT_TIMER2 
....................  
.................... void timer2_isr() 
*
006D2:  PUSH    42
006D4:  PUSH    36
006D6:  PUSH    32
006D8:  MOV     W0,[W15++]
006DA:  MOV     #2,W0
006DC:  REPEAT  #C
006DE:  MOV     [W0++],[W15++]
.................... { 
.................... 	ppm=algoritmo(); 
006E0:  CALL    5E2
006E4:  MOV     W0,12B8
.................... 	//sprintf(cadena,"%04d\n",ppm); //Escribe ppm en el archivo LATIDOS 
.................... 	// output_toggle(H1); 
.................... 	// 
.................... 	// for(jj=0;jj<5;jj++) 
.................... 	// { 
.................... 	// 	dt[jj+(k*5)] = cadena[jj]; 
.................... 	// } 
.................... 	// k++; 
.................... } 
....................  
006E6:  BCLR.B  84.7
006E8:  MOV     #1A,W0
006EA:  REPEAT  #C
006EC:  MOV     [--W15],[W0--]
006EE:  MOV     [--W15],W0
006F0:  POP     32
006F2:  POP     36
006F4:  POP     42
006F6:  RETFIE  
.................... #INT_TIMER5 
.................... void timer5_isr() 
006F8:  PUSH    42
006FA:  PUSH    36
006FC:  PUSH    32
006FE:  MOV     W0,[W15++]
00700:  MOV     #2,W0
00702:  REPEAT  #C
00704:  MOV     [W0++],[W15++]
.................... { 
.................... 	datos_flag=1; 
00706:  BSET.B  85B.1
00708:  BCLR.B  87.4
0070A:  MOV     #1A,W0
0070C:  REPEAT  #C
0070E:  MOV     [--W15],[W0--]
00710:  MOV     [--W15],W0
00712:  POP     32
00714:  POP     36
00716:  POP     42
00718:  RETFIE  
.................... } 
....................  
.................... void main(void) 
*
00D92:  MOV     #4760,W15
00D94:  MOV     #47FF,W0
00D96:  MOV     W0,20
00D98:  NOP     
00D9A:  MOV     #4444,W0
00D9C:  MOV     W0,A6
00D9E:  MOV     #4444,W0
00DA0:  MOV     W0,B0
00DA2:  BSET.B  81.7
00DA4:  MOV     #46,W0
00DA6:  MOV.B   W0L,742
00DA8:  MOV     #57,W0
00DAA:  MOV.B   W0L,742
00DAC:  BCLR.B  742.6
00DAE:  MOV     #3F14,W0
00DB0:  MOV     W0,6A4
00DB2:  MOV     #3F05,W0
00DB4:  MOV     W0,6A8
00DB6:  MOV     #708,W0
00DB8:  MOV     W0,6C6
00DBA:  MOV     #300,W0
00DBC:  MOV     W0,6D2
00DBE:  MOV     #13,W0
00DC0:  MOV     W0,6D6
00DC2:  MOV     #46,W0
00DC4:  MOV.B   W0L,742
00DC6:  MOV     #57,W0
00DC8:  MOV.B   W0L,742
00DCA:  BSET.B  742.6
00DCC:  BCLR.B  2CD.1
00DCE:  BSET.B  207.7
00DD0:  BSET.B  207.5
00DD2:  BSET.B  206.6
00DD4:  BCLR.B  207.3
00DD6:  BSET.B  206.7
00DD8:  BCLR.B  207.0
00DDA:  BSET.B  207.1
00DDC:  BCLR.B  207.2
00DDE:  CLR     20A
00DE0:  MOV     #22,W4
00DE2:  MOV     W4,204
00DE4:  MOV     #7E4,W4
00DE6:  MOV     W4,12AE
00DE8:  MOV.B   #14,W0L
00DEA:  MOV.B   W0L,12B0
00DEC:  MOV.B   #A,W0L
00DEE:  MOV.B   W0L,12B1
00DF0:  MOV.B   #F,W0L
00DF2:  MOV.B   W0L,12B2
00DF4:  MOV.B   #C,W0L
00DF6:  MOV.B   W0L,12B3
00DF8:  MOV.B   #22,W0L
00DFA:  MOV.B   W0L,12B4
00DFC:  MOV.B   #38,W0L
00DFE:  MOV.B   W0L,12B5
00E00:  CLR     A78
00E02:  CLR     A7A
00E04:  MOV     #8000,W4
00E06:  MOV     W4,220
00E08:  MOV     #400,W4
00E0A:  MOV     W4,222
00E0C:  BCLR.B  220.3
00E0E:  MOV     #1,W4
00E10:  MOV     W4,228
00E12:  CLR     12DC
00E14:  SETM    32C
00E16:  CLR     12EA
.................... { 
....................   //Declaracin e inicializacin de variables 
....................  
....................   char ppm_string[9]; 
....................  
.................... 	// Flags del programa 
....................   int1 peligro_flag, peligro_flag_ant, altas, bajas; 
....................  
....................   unsigned int16 ppm_anterior=0; 
....................  
....................  
.................... 	peligro_flag_ant=0; 
00E18:  BCLR.B  12E9.1
.................... 	altas=0; 
00E1A:  BCLR.B  12E9.2
.................... 	bajas=0; 
00E1C:  BCLR.B  12E9.3
....................  
....................   //para debugging. Eliminar al final 
....................   datos_flag=1; 
00E1E:  BSET.B  85B.1
....................  
....................  
....................   // ----------------------------------------- 
....................  
....................   // 1. Inicializacin de mdulos (BT, LCD) 
....................   // 2. Menu de bienvenida y espera a BTOK 
.................... 	// 3. Inicializar ADC y rutina del algoritmo 
....................   // 4. Bucle de programa. Finalizar al pulsar BTOK 
.................... 	//			4.1 Un ISR temporizado calcula las ppm 
....................   //      4.2 Generar alarmas si es necesario 
....................   //      4.3 Mostrar por pantalla 
....................   //      4.4 Envo de datos 
....................  
....................  
....................   //1. 
....................   //init_BT(); 
....................   lcdi2cinit(); 
00E20:  CALL    776
....................   BEEP_Init(); 
00E24:  CALL    7FE
....................   //sd_init(); 
....................  
....................   //2. Menu bienvenida 
....................   initmenu(); 
00E28:  CALL    894
....................   while(input(BTOK)) 
00E2C:  BSET.B  2C0.7
00E2E:  BTSS.B  2C2.7
00E30:  BRA     E3C
....................   { 
....................     delay_ms(50); 
00E32:  MOV     #32,W0
00E34:  CALL    71A
00E38:  GOTO    E2C
....................   } 
....................   while(!input(BTOK)) // para evitar rebotes y finalizar el programa 
00E3C:  BSET.B  2C0.7
00E3E:  BTSC.B  2C2.7
00E40:  BRA     E4C
....................   { 
....................     delay_ms(50); 
00E42:  MOV     #32,W0
00E44:  CALL    71A
00E48:  GOTO    E3C
....................   } 
....................  
....................  
....................   //3. Inicializar algoritmo, adc y timer2 a 250 Hz 
....................   adcinit(); 
00E4C:  CALL    91C
....................   setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8, 1843); // 7370000/2/8/1843 = 4 ms 
00E50:  CLR     110
00E52:  MOV     #733,W4
00E54:  MOV     W4,10C
00E56:  MOV     #8010,W4
00E58:  MOV     W4,110
.................... 	setup_timer5(TMR_INTERNAL | TMR_DIV_BY_8, 1843); // 7370000/2/8/1843 = 4 ms 
00E5A:  CLR     120
00E5C:  MOV     #733,W4
00E5E:  MOV     W4,11C
00E60:  MOV     #8010,W4
00E62:  MOV     W4,120
....................   init_algoritmo(); 
00E64:  CALL    934
....................  
....................   //Mostrar pantalla de frecuencia 
....................   display_frecuencia(); 
00E68:  CALL    970
....................   delay_ms(4); // que al menos se ejecute el algoritmo una vez para no tener valores raros 
00E6C:  REPEAT  #3992
00E6E:  NOP     
....................  
....................   //4. Bucle del programa 
....................   while(input(BTOK)) 
00E70:  BSET.B  2C0.7
00E72:  BTSS.B  2C2.7
00E74:  BRA     F20
....................   { 
....................  
....................     //4.1 Generar alarmas si es necesario 
....................     if(ppm>=250 || ppm<=35) 
00E76:  MOV     12B8,W4
00E78:  MOV     #FA,W3
00E7A:  CP      W3,W4
00E7C:  BRA     GTU,E80
00E7E:  BRA     E88
00E80:  MOV     12B8,W4
00E82:  MOV     #23,W3
00E84:  CP      W3,W4
00E86:  BRA     NC,EC2
....................     { 
....................       if(peligro_flag_ant==0) // si no ha habido peligro antes hay que actualizar la pantalla y el buzzer 
00E88:  BTSC.B  12E9.1
00E8A:  BRA     EBC
....................       { 
.................... 				if(ppm>=250) // caso alto 
00E8C:  MOV     12B8,W4
00E8E:  MOV     #FA,W3
00E90:  CP      W3,W4
00E92:  BRA     GTU,EA4
.................... 				{ 
.................... 					if(!altas) // Solo actualizar pantalla si corresponde 
00E94:  BTSC.B  12E9.2
00E96:  BRA     EA4
.................... 					{ 
.................... 						display_alarma_alto(); 
00E98:  CALL    A28
.................... 						altas=1; 
00E9C:  BSET.B  12E9.2
.................... 						bajas=0; 
00E9E:  BCLR.B  12E9.3
.................... 						ON(BUZZER); 
00EA0:  BCLR.B  2D0.6
00EA2:  BSET.B  2D4.6
.................... 					} 
.................... 				} 
.................... 				if(ppm<=35) // caso bajo 
00EA4:  MOV     12B8,W4
00EA6:  MOV     #23,W3
00EA8:  CP      W3,W4
00EAA:  BRA     NC,EBC
.................... 				{ 
.................... 					if(!bajas) 
00EAC:  BTSC.B  12E9.3
00EAE:  BRA     EBC
.................... 					{ 
.................... 						display_alarma_bajo(); 
00EB0:  CALL    A6C
.................... 						bajas=1; 
00EB4:  BSET.B  12E9.3
.................... 						altas=0; 
00EB6:  BCLR.B  12E9.2
.................... 						ON(BUZZER); 
00EB8:  BCLR.B  2D0.6
00EBA:  BSET.B  2D4.6
.................... 					} 
.................... 				} 
....................       } 
....................       peligro_flag=1; 
00EBC:  BSET.B  12E9.0
....................  
....................     }//fin bloque de alarmas 
00EBE:  GOTO    F08
....................  
....................  
.................... 		//4.2 Mostrar por pantalla en funcionamiento normal 
....................     else 
....................     { 
....................       if(peligro_flag_ant) // si antes ha habido peligro pero ahora no. hay que actualizar pantalla y apagar el buzzer 
00EC2:  BTSS.B  12E9.1
00EC4:  BRA     ECE
....................       { 
....................         display_frecuencia(); 
00EC6:  CALL    970
.................... 				OFF(BUZZER); 
00ECA:  BCLR.B  2D0.6
00ECC:  BCLR.B  2D4.6
....................       } 
....................       peligro_flag=0; // actualizar flag 
00ECE:  BCLR.B  12E9.0
.................... 			bajas=0; 
00ED0:  BCLR.B  12E9.3
.................... 			altas=0; 
00ED2:  BCLR.B  12E9.2
....................  
.................... 			if(ppm!=ppm_anterior) // mostrar por pantalla si ha cambiado el valor 
00ED4:  MOV     12B8,W0
00ED6:  CP      12EA
00ED8:  BRA     Z,F08
.................... 			{ 
.................... 				sprintf(ppm_string,"%d  ",ppm); // crear cadena con espacios para borrar el valor anterior 
00EDA:  MOV     #12E0,W4
00EDC:  MOV     W4,12DC
00EDE:  MOV     12B8,W0
00EE0:  MOV     #0,W4
00EE2:  CALL    AB8
00EE6:  MOV.B   #20,W0L
00EE8:  CALL    AAA
00EEC:  MOV.B   #20,W0L
00EEE:  CALL    AAA
.................... 				LCD_cursor_at(0,16); 
00EF2:  CLR.B   1326
00EF4:  MOV.B   #10,W0L
00EF6:  MOV.B   W0L,1327
00EF8:  CALL    818
.................... 				LCD_write(ppm_string); 
00EFC:  MOV     #12E0,W4
00EFE:  MOV     W4,1326
00F00:  CALL    838
.................... 				ppm_anterior=ppm; 							// actualizar pulsaciones anteriores 
00F04:  PUSH    12B8
00F06:  POP     12EA
.................... 			} 
....................     } 
....................  
....................     //4.3 Enviar datos y escribir cada x segundos 
....................     if(datos_flag) 
00F08:  BTSS.B  85B.1
00F0A:  BRA     F16
....................     { 
....................       enviar_datos(ppm); 
00F0C:  PUSH    12B8
00F0E:  POP     12EC
00F10:  CALL    CE8
.................... 			 
.................... 			//sd_init_global(); 
.................... 			//escritura_sd(); 
.................... 			datos_flag=0; 
00F14:  BCLR.B  85B.1
.................... 		} 
....................  
....................     //fin del bucle 
....................     peligro_flag_ant=peligro_flag; 
00F16:  BCLR.B  12E9.1
00F18:  BTSC.B  12E9.0
00F1A:  BSET.B  12E9.1
00F1C:  GOTO    E70
....................   } 
....................  
.................... 	//fin de programa 
.................... 	display_final(); 
00F20:  CALL    D56
.................... } 
00F24:  BRA     F24

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: 0000  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: 0000  
   Word  3L: 0007   NOWRT NOPROTECT
          H: 0000  
   Word  4L: 0007   FRC_PS NOIESO
          H: 0000  
   Word  5L: 0063   NOPR OSCIO IOL1WAY CKSNOFSM
          H: 0000  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: 0000  
   Word  7L: 00F0   NOPUT NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: 0000  
   Word  8L: 0043   ICSP1 NOJTAG DEBUG
          H: 0000  

   Some fuses have been forced to be compatible with the ICD debugger.
