CCS PCD C Compiler, Version 5.091, 43599               17-ene.-21 13:59

               Filename:   F:\Industriales\Especialidad\SDM\Trabajo-EEC\eec.lst

               ROM used:   4320 bytes (5%)
                           Largest free fragment is 61216
               RAM used:   13364 (82%) at main() level
                           13433 (82%) worst case
               Stack used: 76 locations (20 in main + 56 for interrupts)
               Stack size: 160

00000:  GOTO    E44
*
00022:  DATA    EA,06,00
*
0004A:  DATA    6C,02,00
0004C:  DATA    10,07,00
.................... #import(file="adc.o")
.................... /**
.................... /**
....................  @file    adc.c
....................  @author  Ricardo Gomez
.................... 
....................  @brief   adc functions
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #ifndef LIB_h
.................... #define LIB_h
.................... 
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device DSPIC33FJ128MC804
.................... 
.................... #list
.................... 
.................... #endif
.................... 
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... 
.................... #WORD ADC1BUF0 = 0x0300;
.................... #WORD ADC1CON1 = 0x0320;
.................... #WORD ADC1CON2 = 0x0322;
.................... #WORD ADC1CON3 = 0x0324;
.................... #WORD AD1CHS0 = 0x0328;
.................... #WORD AD1PCFGL = 0x032C;
.................... #WORD IFS0 = 0x0084;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "lcd.h"
.................... /**
....................  @file    lcd.h
....................  @author  Ricardo Gï¿½mez
....................  @brief   LCD management
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __LCD_H
.................... #define __LCD_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... /* SECTION 1: Included header files to compile this file           */
.................... 
.................... /* SECTION 2: Public macros                                        */
.................... 
.................... #define _CLEAR_DISPLAY 				0x01
.................... #define _8BIT_4LINES_NORMAL_RE1_IS0		0x3A
.................... #define _8BIT_4LINES_REVERSE_RE1_IS0		0x3B
.................... #define _8BIT_4LINES_RE0_IS1			0x39
.................... #define _8BIT_4LINES_RE0_IS0			0x38
.................... 
.................... #define _BS1_1					0x1E
.................... #define _POWER_DOWN_DISABLE			0x02
.................... #define _SEGMENT_NORMAL_WAY			0x05
.................... #define _NW					0x09
.................... 
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_ON		0x0F
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_OFF		0x0E
.................... #define _DISPLAY_ON_CURSOR_OFF_BLINK_OFF	0x0C
.................... #define _BS0_1					0x1C
.................... #define _INTERNAL_DIVIDER			0x13
.................... #define _CONTRAST				0x77
.................... #define _POWER_ICON_CONTRAST			0x5C
.................... #define _FOLLOWER_CONTROL			0x6E
.................... 
.................... #define ADDRESS_DDRAM				0x80
.................... 
.................... 
.................... /* SECTION 3: Public types                                         */
.................... 
.................... 
.................... /* SECTION 4: Public variables :: declarations, extern mandatory   */
.................... 
.................... 
.................... /* SECTION 5: Public functions :: declarations, extern optional
....................    Rule exception (callbacks)  :: declarations, extern recommended */
.................... void display_valueADC_title(void);
.................... void LCD_command(unsigned int8);
.................... void lcdi2cinit(void);
.................... void LCD_write(char*);
.................... void initmenu(void);                                      //Inicializa el menu principal
.................... void display_frecuencia(void);       // Muestra frecuencia
.................... void LCD_cursor_at(unsigned int8 line, unsigned int8 column);
.................... void display_alarma_alto(void); // Limpia pantalla y escribe mensaje de alarma
.................... void display_alarma_bajo(void);
.................... void display_final(void);
.................... 
.................... 
.................... #endif // __LCD_H
.................... // Do not write below this line!
.................... 
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #ifndef LIB_h
.................... #define LIB_h
.................... 
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device DSPIC33FJ128MC804
.................... 
.................... #nolist
.................... //////// Program memory: 44032x24  Data RAM: 16384  Stack: 31
.................... //////// I/O: 35   Analog Pins: 9
.................... //////// Fuses: WRTB,NOWRTB,BSSHL,BSSHM,BSSHS,BSSSL,BSSSM,BSSSS,NOBSS
.................... //////// Fuses: RBS1024,RBS256,RBS128,NORBS,WRTSS,NOWRTSS,SSSHL,SSSHM,SSSHS
.................... //////// Fuses: SSSSL,SSSSM,SSSSS,NOSSS,RSS4096,RSS2048,RSS256,NORSS,WRT
.................... //////// Fuses: NOWRT,PROTECT_HIGH,PROTECT,NOPROTECT,FRC,FRC_PLL,PR,PR_PLL
.................... //////// Fuses: SOSC,LPRC,FRC_DIV_BY_16,FRC_PS,NOIESO,IESO,EC,XT,HS,NOPR
.................... //////// Fuses: OSCIO,NOOSCIO,NOIOL1WAY,IOL1WAY,CKSFSM,CKSNOFSM,NOCKSFSM
.................... //////// Fuses: WPOSTS1,WPOSTS2,WPOSTS3,WPOSTS4,WPOSTS5,WPOSTS6,WPOSTS7
.................... //////// Fuses: WPOSTS8,WPOSTS9,WPOSTS10,WPOSTS11,WPOSTS12,WPOSTS13,WPOSTS14
.................... //////// Fuses: WPOSTS15,WPOSTS16,WPRES32,WPRES128,NOWINDIS,WINDIS,NOWDT,WDT
.................... //////// Fuses: NOPUT,PUT2,PUT4,PUT8,PUT16,PUT32,PUT64,PUT128,ALTI2C1
.................... //////// Fuses: NOALTI2C1,LPOL_LOW,LPOL_HIGH,HPOL_LOW,HPOL_HIGH,PWMPIN
.................... //////// Fuses: NOPWMPIN,ICSP3,ICSP2,ICSP1,NOJTAG,JTAG,DEBUG,NODEBUG
.................... ////////
.................... #if (!defined(__PCD__)||defined(__ISNT_CCS__))
.................... #define _bif
.................... #define int8 char
.................... #define int16 int
.................... #define int32 long
.................... #define int48 long
.................... #define int64 long long
.................... #define float32 float
.................... #define float48 float
.................... #define float64 double
.................... #define int1 char
.................... 
.................... #endif
.................... ////////////////////////////////////////////////////////////////// PIN_SELECT
.................... // #pin_select function=pin
.................... // Valid Pins:
.................... //    PIN_B0,PIN_B1,PIN_B2,PIN_B3,PIN_B4,PIN_B5,PIN_B6,PIN_B7,PIN_B8,PIN_B9,
.................... //    PIN_B10,PIN_B11,PIN_B12,PIN_B13,PIN_B14,PIN_B15,PIN_C0,PIN_C1,PIN_C2,
.................... //    PIN_C3,PIN_C4,PIN_C5,PIN_C6,PIN_C7,PIN_C8,PIN_C9
.................... // Input Functions:
.................... //    INT1,INT2,T2CK,T3CK,T4CK,T5CK,IC1,IC2,IC3,IC4,IC5,OCFA,OCFB,U1RX,U1CTS,
.................... //    U2RX,U2CTS,SDI1,SCK1IN,SS1IN,SDI2,SCK2IN,SS2IN,C1RX,IC7,IC8,CSDI,CSCK,COFS,
.................... //    FLTA1,FLTA2,QEA1,QEB1,INDX1,QEA2,QEB2,INDX2,T1CK,FLT1,FLT2,FLT3,FLT4,FLT5,
.................... //    FLT6,FLT7,FLT8,SYNCI1,SYNCI2
.................... // Output Functions:
.................... //    NULL,C1OUT,C2OUT,U1TX,U1RTS,U2TX,U2RTS,SDO1,SCK1OUT,SS1OUT,SDO2,SCK2OUT,
.................... //    SS2OUT,OC1,OC2,OC3,OC4,OC5,C1TX,CSDO,CSCKOUT,COFSOUT,UPDN1,UPDN2,CTPLS,
.................... //    C3OUT,SYNCO1,REFCLKO,CMP1,CMP2,CMP3,CMP4,PWM4H,PWM4L
.................... //
.................... 
.................... ////////////////////////////////////////////////////////////////// I/O
.................... // Discrete I/O Functions: SET_TRIS_x(), OUTPUT_x(), INPUT_x(),
.................... //                         SET_PULLUP(), INPUT(),
.................... //                         OUTPUT_LOW(), OUTPUT_HIGH(),
.................... //                         OUTPUT_FLOAT(), OUTPUT_BIT()
.................... // Discrete I/O Prototypes:
.................... _bif void set_tris_a(unsigned int16 value);
.................... _bif void set_tris_b(unsigned int16 value);
.................... _bif void set_tris_c(unsigned int16 value);
.................... _bif unsigned int16 get_tris_a(void);
.................... _bif unsigned int16 get_tris_b(void);
.................... _bif unsigned int16 get_tris_c(void);
.................... _bif void output_a(unsigned int16 value);
.................... _bif void output_b(unsigned int16 value);
.................... _bif void output_c(unsigned int16 value);
.................... _bif unsigned int16 input_a(void);
.................... _bif unsigned int16 input_b(void);
.................... _bif unsigned int16 input_c(void);
.................... _bif int16 input_change_a(void);
.................... _bif int16 input_change_b(void);
.................... _bif int16 input_change_c(void);
.................... _bif void set_pullup(int1 state);
.................... _bif void set_pullup(int1 state, unsigned int16 pin);
.................... _bif void set_pulldown(int1 state);
.................... _bif void set_pulldown(int1 state, unsigned int16 pin);
.................... _bif int1 input(unsigned int16 pin);
.................... _bif int1 input_state(unsigned int16 pin);
.................... _bif void output_low(unsigned int16 pin);
.................... _bif void output_high(unsigned int16 pin);
.................... _bif void output_toggle(unsigned int16 pin);
.................... _bif void output_bit(unsigned int16 pin, int1 level);
.................... _bif void output_float(unsigned int16 pin);
.................... _bif void output_drive(unsigned int16 pin);
.................... // Constants used to identify pins in the above are:
.................... 
.................... #define PIN_A0  5648
.................... #define PIN_A1  5649
.................... #define PIN_A2  5650
.................... #define PIN_A3  5651
.................... #define PIN_A4  5652
.................... #define PIN_A7  5655
.................... #define PIN_A8  5656
.................... #define PIN_A9  5657
.................... #define PIN_A10  5658
.................... 
.................... #define PIN_B0  5712
.................... #define PIN_B1  5713
.................... #define PIN_B2  5714
.................... #define PIN_B3  5715
.................... #define PIN_B4  5716
.................... #define PIN_B5  5717
.................... #define PIN_B6  5718
.................... #define PIN_B7  5719
.................... #define PIN_B8  5720
.................... #define PIN_B9  5721
.................... #define PIN_B10  5722
.................... #define PIN_B11  5723
.................... #define PIN_B12  5724
.................... #define PIN_B13  5725
.................... #define PIN_B14  5726
.................... #define PIN_B15  5727
.................... 
.................... #define PIN_C0  5776
.................... #define PIN_C1  5777
.................... #define PIN_C2  5778
.................... #define PIN_C3  5779
.................... #define PIN_C4  5780
.................... #define PIN_C5  5781
.................... #define PIN_C6  5782
.................... #define PIN_C7  5783
.................... #define PIN_C8  5784
.................... #define PIN_C9  5785
.................... 
.................... ////////////////////////////////////////////////////////////////// Useful defines
.................... #define FALSE 0
.................... #define TRUE 1
.................... 
.................... #define BYTE unsigned int8
.................... #define BOOLEAN int1
.................... 
.................... #define getc getch
.................... #define fgetc getch
.................... #define getchar getch
.................... #define putc putchar
.................... #define fputc putchar
.................... #define fgets gets
.................... #define fputs puts
.................... 
.................... ////////////////////////////////////////////////////////////////// UART
.................... // UART Prototypes:
.................... _bif void setup_uart(unsigned int32 baud);
.................... _bif void setup_uart(unsigned int32 baud, unsigned int8 stream);
.................... _bif void setup_uart(unsigned int32 baud, unsigned int8 stream, unsigned int32 clock);
.................... _bif void set_uart_speed(unsigned int32 baud);
.................... _bif void set_uart_speed(unsigned int32 baud, unsigned int8 stream);
.................... _bif void set_uart_speed(unsigned int32 baud, unsigned int8 stream, unsigned int32 clock);
.................... // Constants used in setup_uart() are:
.................... // FALSE - Turn UART off
.................... // TRUE  - Turn UART on
.................... #define UART_ADDRESS           2
.................... #define UART_DATA              4
.................... #define UART_AUTODETECT        8
.................... #define UART_AUTODETECT_NOWAIT 9
.................... #define UART_WAKEUP_ON_RDA     10
.................... #define UART_SEND_BREAK        13
.................... 
.................... ////////////////////////////////////////////////////////////////// WDT
.................... // Watch Dog Timer Functions: SETUP_WDT() and RESTART_WDT()
.................... // WDT Prototypes:
.................... _bif void setup_wdt(unsigned int8 mode);
.................... _bif void restart_wdt(void);
.................... // Constants used for SETUP_WDT() are:
.................... #define WDT_ON      1
.................... #define WDT_OFF     0
.................... 
.................... #define  WDT_1MS    0x002
.................... #define  WDT_2MS    0x003
.................... #define  WDT_4MS    0x004
.................... #define  WDT_8MS    0x005
.................... #define  WDT_16MS   0x006
.................... #define  WDT_32MS   0x007
.................... #define  WDT_64MS   0x008
.................... #define  WDT_128MS  0x009
.................... #define  WDT_256MS  0x00A
.................... #define  WDT_512MS  0x00B
.................... #define  WDT_1S     0x00C
.................... #define  WDT_2S     0x00D
.................... #define  WDT_4S     0x00E
.................... #define  WDT_8S     0x00F
.................... #define  WDT_16S    0x010
.................... #define  WDT_33S    0x011
.................... #define  WDT_65S    0x030
.................... #define  WDT_131S   0x031
.................... 
.................... ////////////////////////////////////////////////////////////////// Control
.................... // Control Functions:  RESET_CPU(), SLEEP(), RESTART_CAUSE()
.................... // Prototypes:
.................... _bif unsigned int8 restart_cause(void);
.................... _bif void reset_cpu(void);
.................... _bif void sleep(void);
.................... _bif void sleep(unsigned int8 mode);
.................... // Constants passed into RESTART_CAUSE() are:
.................... #define RESTART_POWER_UP      0
.................... #define RESTART_BROWNOUT      1
.................... #define RESTART_WATCHDOG      4
.................... #define RESTART_SOFTWARE      6
.................... #define RESTART_MCLR          7
.................... #define RESTART_ILLEGAL_OP    14
.................... #define RESTART_TRAP_CONFLICT 15
.................... //
.................... // Constants passed into SLEEP() are:
.................... #define SLEEP_FULL      0  // Default
.................... #define SLEEP_IDLE      1  // Clock and peripherals don't stop
.................... 
.................... ////////////////////////////////////////////////////////////////// INTERNAL RC
.................... // Oscillator Prototypes:
.................... _bif void setup_oscillator(unsigned int8 type, unsigned int32 target);
.................... _bif void setup_oscillator(unsigned int8 type, unsigned int32 target, unsigned int32 source);
.................... // Constants used in setup_oscillator() are:
.................... #define OSC_INTERNAL     32
.................... #define OSC_CRYSTAL       1
.................... #define OSC_CLOCK         2
.................... #define OSC_RC            3
.................... #define OSC_SECONDARY    16
.................... 
.................... ////////////////////////////////////////////////////////////////// Timer
.................... // Timer Functions: SETUP_TIMERx, GET_TIMERx, GET_TIMERxy,
.................... // SET_TIMERx, SET_TIMERxy
.................... // Timer x Prototypes:
.................... _bif void setup_timer1(unsigned int16 mode);
.................... _bif void setup_timer1(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer1(void);
.................... _bif void set_timer1(unsigned int16 value);
.................... _bif void setup_timer2(unsigned int16 mode);
.................... _bif void setup_timer2(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer2(void);
.................... _bif void set_timer2(unsigned int16 value);
.................... _bif void setup_timer3(unsigned int16 mode);
.................... _bif void setup_timer3(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer3(void);
.................... _bif void set_timer3(unsigned int16 value);
.................... _bif unsigned int32 get_timer23(void);
.................... _bif void set_timer23(unsigned int32 value);
.................... _bif void setup_timer4(unsigned int16 mode);
.................... _bif void setup_timer4(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer4(void);
.................... _bif void set_timer4(unsigned int16 value);
.................... _bif void setup_timer5(unsigned int16 mode);
.................... _bif void setup_timer5(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer5(void);
.................... _bif void set_timer5(unsigned int16 value);
.................... _bif unsigned int32 get_timer45(void);
.................... _bif void set_timer45(unsigned int32 value);
.................... // Constants used for SETUP_TIMERx() are:
.................... //      (or (via |) together constants from each group)
.................... #define TMR_DISABLED 0x0000
.................... #define TMR_INTERNAL 0x8000
.................... #define TMR_EXTERNAL 0x8002
.................... #define TMR_GATE     0x0040
.................... 
.................... #define TMR_DIV_BY_1   0x0000
.................... #define TMR_DIV_BY_8   0x0010
.................... #define TMR_DIV_BY_64  0x0020
.................... #define TMR_DIV_BY_256 0x0030
.................... #define TMR_32_BIT     0x0008 // Only for even numbered timers
.................... 
.................... #define TMR_HALT_IDLE      0x2000
.................... #define TMR_CONTINUE_IDLE  0x0000
.................... 
.................... #define T1_EXTERNAL_SYNC  0x8006 //This only applies to Timer1
.................... #define T1_EXTERNAL_RTC   0xC002 //This only applies to Timer1
.................... /////////////////////////////////////////////////////////// INPUT CAPTURE
.................... // Functions: SETUP_CAPTURE, GET_CAPTURE,
.................... // IC Prototypes:
.................... _bif void setup_capture(unsigned int8 module, unsigned int16 mode);
.................... _bif unsigned int16 get_capture(unsigned int8 module);
.................... _bif unsigned int16 get_capture(unsigned int8 module, int1 wait);
.................... // Constants used for SETUP_CAPTURE() are:
.................... #define CAPTURE_OFF               0x0000  // Capture OFF
.................... #define CAPTURE_EE                0x0001  // Capture Every Edge
.................... #define CAPTURE_FE                0x0002  // Capture Falling Edge
.................... #define CAPTURE_RE                0x0003  // Capture Rising Edge
.................... #define CAPTURE_DIV_4             0x0004  // Capture Every 4th Rising Edge
.................... #define CAPTURE_DIV_16            0x0005  // Capture Every 16th Rising Edge
.................... #define CAPTURE_INTERRUPT_ONLY    0x0007  // Interrupt on Rising Edge when in Sleep or Idle
.................... 
.................... // The following defines can be ORed | with above to configure interrupts
.................... #define INTERRUPT_EVERY_CAPTURE   0x0000  // Interrupt on every capture event
.................... #define INTERRUPT_SECOND_CAPTURE  0x0020  // Interrupt on every second capture event
.................... #define INTERRUPT_THIRD_CAPTURE   0x0040  // Interrupt on every third capture event
.................... #define INTERRUPT_FOURTH_CAPTURE  0x0060  // Interrupt on every fourth capture event
.................... 
.................... // The following defines can be ORed | with above to select timer
.................... #define CAPTURE_TIMER2            0x0080  // On capture event Timer 2 is captured
.................... #define CAPTURE_TIMER3            0x0000  // On capture event Timer 3 is captured
.................... 
.................... // The following defines can be ORed | with above to select idle operation mode
.................... #define CAPTURE_HALT_IDLE         0x2000  // Capture module halts during idle mode
.................... #define CAPTURE_CONTINUE_IDLE     0x0000  // Capture module continues during idle mode
.................... 
.................... /////////////////////////////////////////////////////////// OUTPUT COMPARE
.................... // Functions: SETUP_COMPARE, SET_PWM_DUTY, SET_COMPARE_TIME
.................... // OC Prototypes:
.................... _bif void setup_compare(unsigned int8 module, unsigned int16 mode);
.................... _bif void set_pwm_duty(unsigned int8 module, unsigned int16 duty);
.................... _bif void set_compare_time(unsigned int8 module, unsigned int16 ocr);
.................... _bif void set_compare_time(unsigned int8 module, unsigned int16 ocr, unsigned int16 ocrs);
.................... // Constants used for SETUP_COMPARE() are:
.................... #define COMPARE_OFF               0x0000  // Compare OFF
.................... #define COMPARE_SET_ON_MATCH      0x0001  // Pin from low to high on match
.................... #define COMPARE_CLR_ON_MATCH      0x0002  // Pin from high to low on match
.................... #define COMPARE_TOGGLE            0x0003  // Pin will toggle on every match occurrence
.................... #define COMPARE_SINGLE_PULSE      0x0004  // Pin will generate single pulse on first match
.................... #define COMPARE_CONT_PULSE        0x0005  // Pin will pulse for every match
.................... #define COMPARE_PWM               0x0006  // Compare operates as PWM with fault pin disabled
.................... #define COMPARE_PWM_FAULT         0x0007  // Compare operates as PWM with fault pin enabled
.................... 
.................... // The following defines can be ORed | with above to select timer
.................... #define COMPARE_TIMER2            0x0000  // Timer 2 is the base timer
.................... #define COMPARE_TIMER3            0x0008  // Timer 3 is the base timer
.................... 
.................... // The following defines can be ORed | with above to select idle operation mode
.................... #define COMPARE_HALT_IDLE         0x2000  // Compare module halts during idle mode
.................... #define COMPARE_CONTINUE_IDLE     0x0000  // Compare module continues during idle mode
.................... 
.................... ////////////////////////////////////////////////////////////////// SPI
.................... // SPI Functions: SETUP_SPI, SPI_WRITE, SPI_READ, SPI_DATA_IN
.................... // SPI Prototypes:
.................... _bif void setup_spi(unsigned int16 mode);
.................... _bif void spi_write(unsigned int8 data);
.................... _bif void spi_write(int1 wait, unsigned int8 data);
.................... _bif void spi_write_16(unsigned int16 data);
.................... _bif void spi_write_16(int1 wait, unsigned int16 data);
.................... _bif unsigned int8 spi_read(void);
.................... _bif unsigned int8 spi_read(unsigned int8 data);
.................... _bif unsigned int16 spi_read_16(void);
.................... _bif unsigned int16 spi_read_16(unsigned int16 data);
.................... _bif int1 spi_data_in(void);
.................... _bif void setup_spi2(unsigned int16 mode);
.................... _bif void spi_write2(unsigned int8 data);
.................... _bif void spi_write2(int1 wait, unsigned int8 data);
.................... _bif void spi_write2_16(unsigned int16 data);
.................... _bif void spi_write2_16(int1 wait, unsigned int16 data);
.................... _bif unsigned int8 spi_read2(void);
.................... _bif unsigned int8 spi_read2(unsigned int8 data);
.................... _bif unsigned int16 spi_read2_16(void);
.................... _bif unsigned int16 spi_read2_16(unsigned int16 data);
.................... _bif int1 spi_data_in2(void);
.................... // Constants used in SETUP_SPI() are:
.................... //      (or (via |) together constants from each group)
.................... #define SPI_MASTER                 0x0020
.................... #define SPI_SLAVE                  0x0000
.................... 
.................... #define SPI_SCK_IDLE_HIGH          0x0040
.................... #define SPI_SCK_IDLE_LOW           0x0000
.................... 
.................... #define SPI_XMIT_L_TO_H            0x0100
.................... #define SPI_XMIT_H_TO_L            0x0000
.................... 
.................... #define SPI_MODE_16B               0x0400
.................... #define SPI_MODE_8B                0x0000
.................... 
.................... #define SPI_SAMPLE_AT_END          0x0200
.................... #define SPI_SAMPLE_AT_MIDDLE       0x0000
.................... 
.................... #define SPI_SS_ENABLED             0x0000
.................... #define SPI_SS_DISABLED            0x0080
.................... 
.................... //or (via |) one of the following when operating as MASTER
.................... #define SPI_CLK_DIV_1              0x001F
.................... #define SPI_CLK_DIV_2              0x001B
.................... #define SPI_CLK_DIV_3              0x0017
.................... #define SPI_CLK_DIV_4              0x001E
.................... #define SPI_CLK_DIV_5              0x000F
.................... #define SPI_CLK_DIV_6              0x000B
.................... #define SPI_CLK_DIV_7              0x0007
.................... #define SPI_CLK_DIV_8              0x0003
.................... #define SPI_CLK_DIV_12             0x0016
.................... #define SPI_CLK_DIV_16             0x001D
.................... #define SPI_CLK_DIV_20             0x000E
.................... #define SPI_CLK_DIV_24             0x000A
.................... #define SPI_CLK_DIV_28             0x0006
.................... #define SPI_CLK_DIV_32             0x0002
.................... #define SPI_CLK_DIV_48             0x0015
.................... #define SPI_CLK_DIV_64             0x001C
.................... #define SPI_CLK_DIV_80             0x000D
.................... #define SPI_CLK_DIV_96             0x0009
.................... #define SPI_CLK_DIV_112            0x0005
.................... #define SPI_CLK_DIV_128            0x0001
.................... #define SPI_CLK_DIV_192            0x0014
.................... #define SPI_CLK_DIV_256            0x0010
.................... #define SPI_CLK_DIV_320            0x000C
.................... #define SPI_CLK_DIV_384            0x0008
.................... #define SPI_CLK_DIV_448            0x0004
.................... #define SPI_CLK_DIV_512            0x0000
.................... 
.................... //The following defines are provided for compatibility
.................... #define SPI_L_TO_H         SPI_SCK_IDLE_LOW
.................... #define SPI_H_TO_L         SPI_SCK_IDLE_HIGH
.................... 
.................... ////////////////////////////////////////////////////////////////// ADC
.................... // ADC Functions: SETUP_ADC(), SETUP_ADC_PORTS()
.................... //                SET_ADC_CHANNEL(), READ_ADC()
.................... // ADC Prototypes:
.................... _bif void setup_adc(unsigned int32 mode);
.................... _bif void setup_adc_ports(unsigned int32 pins);
.................... _bif void setup_adc_ports(unsigned int32 pins, unsigned int16 reference);
.................... _bif void set_adc_channel(unsigned int8 channel);
.................... _bif void set_adc_channel(unsigned int8 channel, unsigned int8 neg_channel);
.................... _bif unsigned int16 read_adc(void);
.................... _bif unsigned int16 read_adc(unsigned int8 mode);
.................... _bif int1 adc_done(void);
.................... // Constants used for SETUP_ADC() are:
.................... // Clock is at ADCS<5:0> of ADCON3 Reg. (0x02A4)
.................... // Tad = (Tcy/2)*(ADCS<5:0>+1)
.................... #define ADC_OFF                 0x10000
.................... #define ADC_CLOCK                0x0000
.................... #define ADC_CLOCK_DIV_2          0x0001
.................... #define ADC_CLOCK_DIV_4          0x0003
.................... #define ADC_CLOCK_DIV_8          0x0007
.................... #define ADC_CLOCK_DIV_16         0x000F
.................... #define ADC_CLOCK_DIV_32         0x001F
.................... #define ADC_CLOCK_DIV_64         0x003F
.................... #define ADC_CLOCK_INTERNAL       0x8000     // Internal
.................... 
.................... // One of the following may be OR'ed in with the above using |
.................... // Auto-Sample Time bits
.................... #define ADC_TAD_MUL_0            0x1F00
.................... #define ADC_TAD_MUL_2            0x1D00
.................... #define ADC_TAD_MUL_4            0x1B00
.................... #define ADC_TAD_MUL_8            0x1700
.................... #define ADC_TAD_MUL_16           0x0F00
.................... #define ADC_TAD_MUL_31           0x0000
.................... 
.................... // Constants used in READ_ADC() are:
.................... #define ADC_START_AND_READ       0x07
.................... #define ADC_START_ONLY           0x01
.................... #define ADC_READ_ONLY            0x06
.................... 
.................... // Constants used in SET_ADC_CHANNEL() second parameter are:
.................... #define VSS                      0
.................... 
.................... // Constants used in SETUP_ADC_PORTS() are:
.................... // First argument:
.................... // OR together desired pins
.................... #define NO_ANALOGS      0           // None
.................... #define ALL_ANALOG      0xFFFFFFFF  // All
.................... #define sAN0      0x00000001 //| A0
.................... #define sAN1      0x00000002 //| A1
.................... #define sAN2      0x00000004 //| B0
.................... #define sAN3      0x00000008 //| B1
.................... #define sAN4      0x00000010 //| B2
.................... #define sAN5      0x00000020 //| B3
.................... #define sAN6      0x00000040 //| C0
.................... #define sAN7      0x00000080 //| C1
.................... #define sAN8      0x00000100 //| C2
.................... 
.................... // Optional Second argument:
.................... #define VSS_VDD            0x0000 // Range 0-Vdd
.................... #define VREF_VREF          0x6000 // Range VrefL-VrefH
.................... #define VREF_VDD           0x4000 // Range VrefL-Vdd
.................... #define VSS_VREF           0x2000 // Range 0-VrefH
.................... 
.................... ////////////////////////////////////////////////////////////////// COMP
.................... // Comparator Functions: setup_comparator()
.................... // Comparator Variables: C1OUT, C2OUT
.................... // Comparator Prototypes:
.................... _bif void setup_comparator(unsigned int16 mode);
.................... // Constants used in setup_comparator() are:
.................... #define NC_NC_NC_NC      0
.................... #define B2_B3_NC_NC      0x401
.................... #define B2_VR_NC_NC      0x400
.................... #define B3_VR_NC_NC      0x402
.................... #define NC_NC_B0_B1      0x804
.................... #define NC_NC_B0_VR      0x800
.................... #define NC_NC_B1_VR      0x808
.................... #define B2_B3_B0_B1      B2_B3_NC_NC | NC_NC_B0_B1
.................... #define B2_VR_B0_VR      B2_VR_NC_NC | NC_NC_B0_VR
.................... #define B3_VR_B1_VR      B3_VR_NC_NC | NC_NC_B1_VR
.................... 
.................... #define C1_INVERT     0x10
.................... #define C2_INVERT     0x20
.................... #define C1_OUTPUT     0x100
.................... #define C2_OUTPUT     0x200
.................... 
.................... #bit C1OUT = getenv("SFR:CMCON").6
.................... #bit C2OUT = getenv("SFR:CMCON").7
.................... 
.................... ////////////////////////////////////////////////////////////////// VREF
.................... // VREF Prototypes:
.................... _bif void setup_vref(unsigned int16 mode);
.................... // Constants used in setup_vref() are:
.................... #define VREF_DISABLED  0x0000
.................... #define VREF_VSS_VDD   0x0080
.................... #define VREF_ANALOG    0x0090
.................... // One of the following maybe OR'ed in with the above using |
.................... #define VREF_HIGH      0x0080
.................... #define VREF_LOW       0x00A0
.................... // The following maybe OR'ed in with the above using |
.................... #define VREF_OUTPUT    0x0040
.................... // Or (with |) the above with a number 0-15
.................... 
.................... ////////////////////////////////////////////////////////////////// PMP
.................... // PMP Functions: setup_pmp(), pmp_address(), psp_read(), pmp_read(),
.................... // psp_write(), pmp_write(), psp_output_full(),psp_input_full(),
.................... // psp_overflow(), pmp_output_full(), pmp_input_full(),
.................... // pmp_overflow()
.................... // PMP Prototypes:
.................... _bif void setup_pmp(unsigned int32 mode, unsigned int16 address_mask);
.................... _bif void pmp_address(unsigned int16 address);
.................... _bif unsigned int8 pmp_read(void);
.................... _bif void pmp_write(unsigned int8 data);
.................... _bif int1 pmp_output_full(void);
.................... _bif int1 pmp_input_full(void);
.................... _bif int1 pmp_overflow(void);
.................... _bif void setup_psp(unsigned int32 mode, unsigned int16 address_mask);
.................... _bif unsigned int8 psp_read(void);
.................... _bif unsigned int8 psp_read(unsigned int16 address);
.................... _bif void psp_write(unsigned int8 data);
.................... _bif void psp_write(unsigned int8 data, unsigned int16 address);
.................... _bif int1 psp_output_full(void);
.................... _bif int1 psp_input_full(void);
.................... _bif int1 psp_overflow(void);
.................... // Constants used in SETUP_PMP() and SETUP_PSP() are:
.................... #define PAR_ENABLE                0x8000
.................... #define PAR_DISABLE               0x0000    // Module enable/disable options
.................... #define PAR_STOP_IN_IDLE          0x2000
.................... #define PAR_CONTINUE_IN_IDLE      0x0000
.................... #define PAR_ADDR_NOT_MULTIPLEXED  0x0000    // Address multiplexing options
.................... #define PAR_LOW_ADDR_MULTIPLEXED  0x0800    // Address multiplexing options
.................... #define PAR_FULL_ADDR_MULTIPLEXED 0x1000    // Address multiplexing options
.................... #define PAR_PTBEEN_ENABLE         0x0400  // Byte Enable Port Enable bit
.................... #define PAR_PTWREN_ENABLE         0x0200  // Write Enable Strobe bit
.................... #define PAR_PTRDEN_ENABLE         0x0100  // Read/Write Strobe Port bit
.................... #define PAR_ALP_ACTIVE_HIGH       0x0020 // Address latch polarity high
.................... #define PAR_BEP_ACTIVE_HIGH       0x0004 // Byte Enable Polarity
.................... #define PAR_WRSP_ACTIVE_HIGH      0x0002 // Write strobe Polarity bit
.................... #define PAR_RDSP_ACTIVE_HIGH      0x0001 // Read strobe Polarity bit
.................... #define PAR_CS_XX                 0x0000   // Chip select pins used for address
.................... #define PAR_CS_X1                 0x0008   // Chip select pin 1 used, active high
.................... #define PAR_CS_X0                 0x0000   // Chip select pin 1 used, active low
.................... #define PAR_CS_1X                 0x0050   // Chip select pin 2 used, active high
.................... #define PAR_CS_0X                 0x0040   // Chip select pin 2 used, active low
.................... #define PAR_CS_00                 0x0080   // Chip select pins 1,2 used, active low
.................... #define PAR_CS_11                 0x0098   // Chip select pins 1,2 used, active high
.................... #define PAR_CS_10                 0x0090   // Chip select pins 1,2 used, 1 is active low, 2 is high
.................... #define PAR_CS_01                 0x0088   // Chip select pins 1,2 used, 1 is active high, 2 is low
.................... #define PAR_INTR_ON_RW                0x20000000  // Interrupt on read write
.................... #define PAR_NO_INTR_STALL_ACTIVATED   0x40000000  // No interrupt, processor stall activated
.................... #define PAR_INTR_ON_3_RW_BUF          0x60000000 // Interrupt on write to Buffer 3 or read from Buffer 3
.................... #define PAR_PSP_AUTO_INC              0x18000000 // Read write buffers auto increment
.................... #define PAR_DEC_ADDR                  0x10000000 // Increment the address
.................... #define PAR_INC_ADDR                  0x08000000 // Decrement the address
.................... #define PAR_MASTER_MODE_1             0x03000000  // Master mode 1
.................... #define PAR_MASTER_MODE_2             0x02000000  // Master mode 2
.................... #define PAR_WAITB1                    0x00000000 // 1 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB2                    0x00400000 // 2 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB3                    0x00800000 // 3 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB4                    0x00C00000 // 4 Tcy Wait state for data setup R/W
.................... #define PAR_WAITM0                    0x00000000 // 0 wait state for Read to byte
.................... #define PAR_WAITM1                    0x00040000 // 1 Tcy wait state for Read to byte
.................... #define PAR_WAITM2                    0x00080000 // 2 Tcy wait state for Read to byte
.................... #define PAR_WAITM3                    0x000C0000 // 3 Tcy wait state for Read to byte
.................... #define PAR_WAITM15                   0x003C0000 // 15 wait states
.................... #define PAR_WAITE1                    0x00000000  // 1 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE2                    0x00010000 // 2 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE3                    0x00020000 // 3 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE4                    0x00030000 // 4 Tcy Wait for data hold after strobe
.................... 
.................... ////////////////////////////////////////////////////////////////// CRC
.................... // CRC Functions: setup_crc(), crc_init(), crc_calc(), crc_calc8()
.................... // CRC Prototypes:
.................... _bif void setup_crc(unsigned int8 poly_terms, ...);
.................... _bif void crc_init(unsigned int16 value);
.................... _bif unsigned int16 crc_calc(unsigned int16 data);
.................... _bif unsigned int16 crc_calc(unsigned int16 *ptr, unsigned int16 count);
.................... _bif unsigned int8 crc_calc8(unsigned int8 data);
.................... _bif unsigned int8 crc_calc8(unsigned int8 *ptr, unsigned int16 count);
.................... 
.................... ////////////////////////////////////////////////////////////////// RTC
.................... // RTC Functions: setup_rtc(), setup_rtc_alarm(), rtc_read(),
.................... //                rtc_write(), rtc_alarm_read(), rtc_alarm_write()
.................... // Structure used in read and write functions (pass pointer):
.................... typedef struct {
....................    unsigned int8 tm_year;
....................    unsigned int8 tm_temp;  // Not used by built in functions, place holder only do not use
....................    unsigned int8 tm_mday;
....................    unsigned int8 tm_mon;
....................    unsigned int8 tm_hour;
....................    unsigned int8 tm_wday;
....................    unsigned int8 tm_sec;
....................    unsigned int8 tm_min;
....................    unsigned int8 tm_isdst; // Not used by built in functions
.................... } rtc_time_t;
.................... // RTC Prototypes:
.................... _bif void setup_rtc(unsigned int16 mode, unsigned int8 calibration);
.................... _bif void setup_rtc_alarm(unsigned int16 mode, unsigned int16 mask, unsigned int8 repeat);
.................... _bif void rtc_read(rtc_time_t *time);
.................... _bif void rtc_write(rtc_time_t *time);
.................... _bif void rtc_alarm_read(rtc_time_t *time);
.................... _bif void rtc_alarm_write(rtc_time_t *time);
.................... // Constants used in setup_rtc() are:  // Second param is calibration
.................... #define RTC_ENABLE           0x8000
.................... #define RTC_DISABLE          0
.................... #define RTC_OUTPUT_SECONDS   0x20400
.................... #define RTC_OUTPUT_ALARM     0x00400
.................... //
.................... // Constants used in setup_rtc_alarm() first param are:
.................... #define RTC_ALARM_ENABLE     0x8000
.................... #define RTC_ALARM_DISABLE    0
.................... #define RTC_CHIME_ENABLE     0x4000
.................... #define RTC_CHIME_DISABLE    0
.................... // Constants used in setup_rtc_alarm() second param are:  // Third param is repeat#
.................... #define RTC_ALARM_HALFSECOND 0x0000
.................... #define RTC_ALARM_SECOND     0x0400
.................... #define RTC_ALARM_10_SECONDS 0x0800
.................... #define RTC_ALARM_MINUTE     0x0C00
.................... #define RTC_ALARM_10_MINUTES 0x1000
.................... #define RTC_ALARM_HOUR       0x1400
.................... #define RTC_ALARM_DAY        0x1800
.................... #define RTC_ALARM_WEEK       0x1C00
.................... #define RTC_ALARM_MONTH      0x2000
.................... #define RTC_ALARM_YEAR       0x2400
.................... 
.................... ////////////////////////////////////////////////////////////////// QEI
.................... // QEI Functions: setup_qei(), qei_set_count(), qei_get_count(),
.................... //                qei_status()
.................... // QEI Prototypes:
.................... _bif void setup_qei(unsigned int16 mode, unsigned int16 filter, unsigned int16 maxcount);
.................... _bif void setup_qei(unsigned int8 unit, unsigned int16 mode, unsigned int16 filter, unsigned int16 maxcount);
.................... _bif void qei_set_count(unsigned int16 count);
.................... _bif void qei_set_count(unsigned int8 unit, unsigned int16 count);
.................... _bif unsigned int16 qei_get_count(void);
.................... _bif unsigned int16 qei_get_count(unsigned int8 unit);
.................... _bif unsigned int16 qei_status(void);
.................... _bif unsigned int16 qei_status(unsigned int8 unit);
.................... // Constants used in setup_qei() first param are:
.................... #define QEI_DISABLED        0
.................... #define QEI_MODE_X2         0x0400
.................... #define QEI_MODE_X4         0x0600
.................... #define QEI_MODE_TIMER      0x0100
.................... #define QEI_STOP_WHEN_IDLE  0x2000
.................... #define QEI_SWAP_AB         0x0080
.................... #define QEI_OUTPUT_ENABLE   0x0040
.................... #define QEI_RESET_WHEN_MAXCOUNT  0x0100
.................... #define QEI_RESET_WHEN_IDX_PULSE 0x0004
.................... #define QEI_TIMER_GATED      0x0020
.................... #define QEI_TIMER_INTERNAL   0x0000
.................... #define QEI_TIMER_EXTERNAL   0x0002
.................... #define QEI_TIMER_DIV_BY_1   0x0000
.................... #define QEI_TIMER_DIV_BY_8   0x0008
.................... #define QEI_TIMER_DIV_BY_64  0x0010
.................... #define QEI_TIMER_DIV_BY_256 0x0018
.................... // Constants used in setup_qei() second param are:   // Third param is MAXCOUNT
.................... #define QEI_FILTER_DIV_1     0x0000
.................... #define QEI_FILTER_DIV_2     0x0010
.................... #define QEI_FILTER_DIV_4     0x0020
.................... #define QEI_FILTER_DIV_16    0x0030
.................... #define QEI_FILTER_DIV_32    0x0040
.................... #define QEI_FILTER_DIV_64    0x0050
.................... #define QEI_FILTER_DIV_128   0x0060
.................... #define QEI_FILTER_DIV_256   0x0070
.................... #define QEI_FILTER_OUTPUT    0x0080
.................... #define QEI_NO_ERROR_INTS    0x0100
.................... #define QEI_IDX_WHEN_A0      0x0000  // for 2X mode
.................... #define QEI_IDX_WHEN_A1      0x0200  // for 2X mode
.................... #define QEI_IDX_WHEN_B0      0x0400  // for 2X mode
.................... #define QEI_IDX_WHEN_B1      0x0600  // for 2X mode
.................... #define QEI_IDX_WHEN_A0_B0   0x0000  // for 4X mode
.................... #define QEI_IDX_WHEN_A1_B0   0x0200  // for 4X mode
.................... #define QEI_IDX_WHEN_A0_B1   0x0400  // for 4X mode
.................... #define QEI_IDX_WHEN_A1_B1   0x0600  // for 4X mode
.................... // Constants returned from qei_status() are:
.................... #define QEI_POS_ERROR        0x8000
.................... #define QEI_FORWARD          0x0800
.................... #define QEI_INDEX_PIN        0x1000
.................... 
.................... ////////////////////////////////////////////////////////////////// MOTOR PWM
.................... // MPWM Functions: setup_motor_pwm(), set_motor_unit(),
.................... //                 set_motor_pwm_duty(), set_motor_pwm_event(),
.................... //                 get_motor_pwm_count()
.................... // MPWM Prototypes:
.................... _bif void setup_motor_pwm(unsigned int8 pwm, unsigned int32 mode, unsigned int32 timebase);
.................... _bif void setup_motor_pwm(unsigned int8 pwm, unsigned int32 mode, unsigned int8 prescale, unsigned int8 postscale, unsigned int16 period);
.................... _bif void set_motor_unit(unsigned int8 pwm, unsigned int8 pin_pair, unsigned int16 mode, unsigned int8 active_deadtime, unsigned int8 inactive_deadtime);
.................... _bif void set_motor_pwm_duty(unsigned int8 pwm, unsigned int8 pin_pair, unsigned int16 duty);
.................... _bif void set_motor_pmw_event(unsigned int8, signed int16 time);
.................... _bif unsigned int16 get_motor_pwm_count(unsigned int8 pwm);
.................... // Constants used in setup_motor_pwm() second param are (first param is unit number 1,2...):
.................... #define MPWM_DISABLED          0
.................... #define MPWM_FREE_RUN          0x8000
.................... #define MPWM_SINGLE_PULSE      0x8001
.................... #define MPWM_UP_DOWN           0x8002
.................... #define MPWM_UP_DOWN_WITH_INTS 0x8003
.................... // OR in any of the following:
.................... #define MPWM_HALT_WHEN_IDLE            0x2000
.................... #define MPWM_DUTY_UPDATES_IMMEADIATE  0x40000
.................... #define MPWM_SYNC_OVERRIDES           0x20000
.................... #define MPWM_DISABLE_UPDATES          0x10000
.................... #define MPWM_LATCH_FAULTS            0x100000
.................... 
.................... // Constants used in set_motor_unit() third param are:  (first param is unit number 1,2... and second param is pwm pin pair 1,2,3 or 4)
.................... #define MPWM_INDEPENDENT     0x0001
.................... #define MPWM_ENABLE          0x0006  // both H and L
.................... #define MPWM_ENABLE_H        0x0004
.................... #define MPWM_ENABLE_L        0x0002
.................... 
.................... #define MPWM_FORCE_L_0       0x0010
.................... #define MPWM_FORCE_L_1       0x0050
.................... #define MPWM_FORCE_H_0       0x0020
.................... #define MPWM_FORCE_H_1       0x00A0
.................... 
.................... #define MPWM_FAULTA_LA_HA     0x0700
.................... #define MPWM_FAULTA_LA_HI     0x0500
.................... #define MPWM_FAULTA_LI_HA     0x0600
.................... #define MPWM_FAULTA_LI_HI     0x0400
.................... #define MPWM_FAULTB_LA_HA     0x7000
.................... #define MPWM_FAULTB_LA_HI     0x5000
.................... #define MPWM_FAULTB_LI_HA     0x6000
.................... #define MPWM_FAULTB_LI_HI     0x4000
.................... #define MPWM_FAULT_NO_CHANGE 0x0000
.................... 
.................... ////////////////////////////////////////////////////////////////// DCI
.................... // DCI Functions: setup_dci(), dci_start(), dci_read(), dci_write(),
.................... //                dci_data_received(), dci_transmit_ready()
.................... // DCI Prototypes:
.................... _bif void setup_dci(unsigned int16 mode, unsigned int16 size, unsigned int16 receive_slot, unsigned int16 transmit_slot, unsigned int16 sample_rate);
.................... _bif void dci_start(void);
.................... _bif signed int16 dci_read(void);
.................... _bif void dci_write(signed int16);
.................... _bif int1 dci_data_received(void);
.................... _bif int1 dci_transmit_ready(void);
.................... // Constants used in setup_dci() first param are:
.................... #define MULTICHANNEL_MODE  0x0000
.................... #define I2S_MODE           0x0001
.................... #define AC97_16BIT_MODE    0x0002
.................... #define AC97_20BIT_MODE    0x0003
.................... 
.................... #define JUSTIFY_DATA       0x0020 //Start data transmission on the same clock cycle as COFS pulses (multichannel)
.................... #define MULTI_DEVICE_BUS   0x0040 //Tri-states the CSDO pin during unused time slots, normally drives '0'
.................... 
.................... #define UNDERFLOW_LAST     0x0080 //Transmits the last written value to the dci when data underflow occurs. Default is undeflow silence.
.................... #define UNDERFLOW_SILENCE  0x0000 //Transmit '0's on data undeflow. This will cause a clicking noise if you are underflowing data while outputing to a codec.
.................... 
.................... #define DCI_SLAVE          0x0100 //Default is master
.................... #define DCI_MASTER         0x0000
.................... 
.................... #define SAMPLE_FALLING_EDGE 0x0000 //Default is Sample on the rising edge of the clock
.................... #define SAMPLE_RISING_EDGE 0x0200
.................... 
.................... #define DCI_CLOCK_INPUT    0x0400 //SCLK is an input (supplied by codec or external source)
.................... #define DCI_CLOCK_OUTPUT   0x0000 //Default is clock output
.................... 
.................... #define ENABLE_LOOPBACK    0x0800 //Connect the CSDI/CSDO internally; loops all of the sound back onto the bus
.................... 
.................... #define CODEC_MULTICHANNEL  0x0000  //enables multichannel (generic) codec support
.................... #define CODEC_I2S           0x0001  //enables the I2S protocol
.................... #define CODEC_AC16          0x0002  //enables the AC-16 protocol, setupCodecTransmission has no effect
.................... #define CODEC_AC20          0x0003  //enables the AC-20 protocol, setupCodecTransmission has no effect
.................... 
.................... #define BUS_MASTER          0x0000  //designates this device as the bus master
.................... #define BUS_SLAVE           0x0300  //designates this device as a slave on a bus controlled by another codec
.................... 
.................... #define TRISTATE_BUS        0x0040        //when in master mode, the module will be in high impedance
....................                                     //during disabled frames (default drives 0's onto bus)
.................... #define SYNC_COFS_DATA_PULSE 0x0020 //signifies that data starts transmitting on the same SCK pulse as the edge of the COFS pulse
....................                                     //(default data starts on the clock after the rising edge of COFS
.................... /* Determines when a sample is taken */
.................... #define SAMPLE_RISING        0x0200 //sample data on the rising edge of the clock
.................... #define SAMPLE_FALLING       0x0000 //sample data on the falling edge of the clock
.................... 
.................... // Constants used in setup_dci() second param are:
.................... #define DCI_4BIT_WORD      0x0003
.................... #define DCI_5BIT_WORD      0x0004
.................... #define DCI_6BIT_WORD      0x0005
.................... #define DCI_7BIT_WORD      0x0006
.................... #define DCI_8BIT_WORD      0x0007
.................... #define DCI_9BIT_WORD      0x0008
.................... #define DCI_10BIT_WORD     0x0009
.................... #define DCI_11BIT_WORD     0x000A
.................... #define DCI_12BIT_WORD     0x000B
.................... #define DCI_13BIT_WORD     0x000C
.................... #define DCI_14BIT_WORD     0x000D
.................... #define DCI_15BIT_WORD     0x000E
.................... #define DCI_16BIT_WORD     0x000F
.................... 
.................... #define DCI_1WORD_FRAME    0x0000
.................... #define DCI_2WORD_FRAME    0x0010 << 1
.................... #define DCI_3WORD_FRAME    0x0020 << 1
.................... #define DCI_4WORD_FRAME    0x0030 << 1
.................... #define DCI_5WORD_FRAME    0x0040 << 1
.................... #define DCI_6WORD_FRAME    0x0050 << 1
.................... #define DCI_7WORD_FRAME    0x0060 << 1
.................... #define DCI_8WORD_FRAME    0x0070 << 1
.................... #define DCI_9WORD_FRAME    0x0080 << 1
.................... #define DCI_10WORD_FRAME   0x0090 << 1
.................... #define DCI_11WORD_FRAME   0x00A0 << 1
.................... #define DCI_12WORD_FRAME   0x00B0 << 1
.................... #define DCI_13WORD_FRAME   0x00C0 << 1
.................... #define DCI_14WORD_FRAME   0x00D0 << 1
.................... #define DCI_15WORD_FRAME   0x00E0 << 1
.................... #define DCI_16WORD_FRAME   0x00F0 << 1
.................... 
.................... #define DCI_1WORD_INTERRUPT 0x0000
.................... #define DCI_2WORD_INTERRUPT 0x0400
.................... #define DCI_3WORD_INTERRUPT 0x0800
.................... #define DCI_4WORD_INTERRUPT 0x0C00
.................... 
.................... // Constants used in setup_dci() third param are:
.................... #define RECEIVE_NONE    0x0000
.................... #define RECEIVE_ALL     0xFFFF
.................... #define RECEIVE_SLOT0   0x0001
.................... #define RECEIVE_SLOT1   0x0002
.................... #define RECEIVE_SLOT2   0x0004
.................... #define RECEIVE_SLOT3   0x0008
.................... #define RECEIVE_SLOT4   0x0010
.................... #define RECEIVE_SLOT5   0x0020
.................... #define RECEIVE_SLOT6   0x0040
.................... #define RECEIVE_SLOT7   0x0080
.................... #define RECEIVE_SLOT8   0x0100
.................... #define RECEIVE_SLOT9   0x0200
.................... #define RECEIVE_SLOT10  0x0400
.................... #define RECEIVE_SLOT11  0x0800
.................... #define RECEIVE_SLOT12  0x1000
.................... #define RECEIVE_SLOT13  0x2000
.................... #define RECEIVE_SLOT14  0x4000
.................... #define RECEIVE_SLOT15  0x8000
.................... 
.................... // Constants used in setup_dci() forth param are:
.................... #define TRANSMIT_NONE   0x0000
.................... #define TRANSMIT_ALL    0xFFFF
.................... #define TRANSMIT_SLOT0  0x0001
.................... #define TRANSMIT_SLOT1  0x0002
.................... #define TRANSMIT_SLOT2  0x0004
.................... #define TRANSMIT_SLOT3  0x0008
.................... #define TRANSMIT_SLOT4  0x0010
.................... #define TRANSMIT_SLOT5  0x0020
.................... #define TRANSMIT_SLOT6  0x0040
.................... #define TRANSMIT_SLOT7  0x0080
.................... #define TRANSMIT_SLOT8  0x0100
.................... #define TRANSMIT_SLOT9  0x0200
.................... #define TRANSMIT_SLOT10 0x0400
.................... #define TRANSMIT_SLOT11 0x0800
.................... #define TRANSMIT_SLOT12 0x1000
.................... #define TRANSMIT_SLOT13 0x2000
.................... #define TRANSMIT_SLOT14 0x4000
.................... #define TRANSMIT_SLOT15 0x8000
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////// DMA
.................... // DMA Functions: setup_dma(), dma_start(), dma_status()
.................... // DMA Prototypes:
.................... _bif void setup_dma(unsigned int8 channel, unsigned int32 pheripheral, unsigned int8 mode);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 count);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 addressb);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 addressb, unsigned int16 count);
.................... _bif unsigned int8 dma_status(unsigned int8 channel);
.................... // Constants used in setup_dma() second param are:
.................... #define DMA_IN_SPI1      (0x0A0000|getenv("sfr:SPI1BUF"))
.................... #define DMA_OUT_SPI1     (0x8A0000|getenv("sfr:SPI1BUF"))
.................... #define DMA_IN_SPI2      (0x210000|getenv("sfr:SPI2BUF"))
.................... #define DMA_OUT_SPI2     (0xA10000|getenv("sfr:SPI2BUF"))
.................... #define DMA_IN_UART1     (0x0B0000|getenv("sfr:U1RXREG"))
.................... #define DMA_OUT_UART1    (0x8C0000|getenv("sfr:U1TXREG"))
.................... #define DMA_IN_UART2     (0x1E0000|getenv("sfr:U2RXREG"))
.................... #define DMA_OUT_UART2    (0x9F0000|getenv("sfr:U2TXREG"))
.................... #define DMA_IN_ADC1      (0x0D0000|getenv("sfr:ADC1BUF0"))
.................... ////////////////////////////////////////////////////////////////// DAC
.................... // Digital to Analog Functions: SETUP_DAC(), DAC_WRITE()
.................... // DAC Prototypes:
.................... _bif void setup_dac(unsigned int32 mode);
.................... _bif void setup_dac(unsigned int32 mode, unsigned int8 divisor);
.................... _bif void dac_write(unsigned int8 channel, unsigned value);
.................... // Constants used in SETUP_DAC() are:
.................... #define DAC_OFF  0
.................... #define DAC_RIGHT_ON   0x00808000
.................... #define DAC_LEFT_ON    0x80008000
.................... #define DAC_RIGHT_MIDPOINT 0x00A08000
.................... #define DAC_LEFT_MIDPOINT  0xA0008000
.................... #define DAC_SIGNED   0x100
.................... #define DAC_SLEEP_ON 0x1000
.................... #define DAC_IDLE_OFF 0x2000
.................... // Constants used as the first param in DAC_WRITE() are:
.................... #define DAC_DEFAULT  0
.................... #define DAC_RIGHT    1
.................... #define DAC_LEFT     2
.................... 
.................... #define DMA_IN_ECAN1     (0x220000|getenv("sfr:C1RXD"))
.................... #define DMA_OUT_ECAN1    (0xC60000|getenv("sfr:C1TXD"))
.................... #define DMA_INT0         0x000000 // or in direction and perif address
.................... #define DMA_IC1          0x010000 // or in direction and perif address
.................... #define DMA_IN_IC1       (0x010000|getenv("sfr:IC1BUF"))
.................... #define DMA_IC2          0x050000 // or in direction and perif address
.................... #define DMA_IN_IC2       (0x050000|getenv("sfr:IC2BUF"))
.................... #define DMA_OC1          0x020000 // or in direction and perif address
.................... #define DMA_OC2          0x060000 // or in direction and perif address
.................... #define DMA_TIMER2       0x070000 // or in direction and perif address
.................... #define DMA_TIMER3       0x080000 // or in direction and perif address
.................... #define DMA_OUT_DCI      (0xBC0000|getenv("sfr:TXBUF0"))
.................... #define DMA_IN_DCI       (0x3C0000|getenv("sfr:RXBUF0"))
.................... #define DMA_OUT_DACR     (0xCE0000|getenv("sfr:DAC1RDAT"))
.................... #define DMA_OUT_DACL     (0xCF0000|getenv("sfr:DAC1LDAT"))
.................... #define DMA_IN          0x00
.................... #define DMA_OUT         0x800000
.................... // Constants used in setup_dma() third param are:
.................... #define DMA_BYTE        0x40
.................... #define DMA_WORD        0x00  // default
.................... #define DMA_HALF_INT    0x10  // interrupt when half full
.................... #define DMA_WRITE_NULL  0x08
.................... // Constants used in dma_start() second param are:
.................... #define DMA_CONTINOUS   0x00
.................... #define DMA_ONE_SHOT    0x01
.................... #define DMA_PING_PONG   0x02
.................... #define DMA_NO_INC      0x10
.................... #define DMA_PERIF_ADDR  0x20 // Device supplies address
.................... #define DMA_FORCE_NOW  0x100
.................... // Constants returned from dma_status() are:
.................... #define DMA_IN_ERROR    0x01
.................... #define DMA_OUT_ERROR   0x02
.................... #define DMA_B_SELECT    0x04
.................... 
.................... ////////////////////////////////////////////////////////////////// BIF
.................... // Built In Functions Prototypes
.................... //
.................... // Math Prototypes:
.................... _bif signed int8 abs(signed int8 x);
.................... _bif signed int16 abs(signed int16 x);
.................... _bif signed int32 abs(signed int32 x);
.................... _bif float32 abs(float32 x);
.................... _bif unsigned int16 _mul(unsigned int8, unsigned int8);
.................... _bif signed int16 _mul(signed int8, signed int8);
.................... _bif unsigned int32 _mul(unsigned int16, unsigned int16);
.................... _bif signed int32 _mul(signed int16, signed int16);
.................... _bif signed int48 abs(signed int48 x);
.................... _bif signed int64 abs(signed int64 x);
.................... _bif float48 abs(float48 x);
.................... _bif float64 abs(float64 x);
.................... _bif unsigned int64 _mul(unsigned int32, unsigned int32);
.................... _bif signed int64 _mul(signed int32, signed int32);
.................... _bif unsigned int64 _mul(unsigned int48, unsigned int48);
.................... _bif signed int64 _mul(signed int48, signed int48);
.................... 
.................... // Memory Manipulation Prototypes:
.................... _bif void strcpy(char* dest, char* src);
.................... _bif void memset(unsigned int8* destination, unsigned int8 value, unsigned int16 num);
.................... _bif void memcpy(unsigned int8* destination, unsigned int8* source, unsigned int16 num);
.................... 
.................... // Data Manipulators Prototypes:
.................... _bif int1 shift_left(unsigned int8* address, unsigned int8 bytes, int1 value);
.................... _bif int1 shift_right(unsigned int8* address, unsigned int8 bytes, int1 value);
.................... _bif void rotate_left(unsigned int8* address, unsigned int8 bytes);
.................... _bif void rotate_right(unsigned int8* address, unsigned int8 bytes);
.................... _bif void swap(unsigned int8 value);
.................... _bif unsigned int8 make8(unsigned int16 var, unsigned int8 offset);
.................... _bif unsigned int8 make8(unsigned int32 var, unsigned int8 offset);
.................... _bif unsigned int16 make16(unsigned int8 varhigh, unsigned int8 varlow);
.................... _bif unsigned int32 make32(unsigned int16 var1);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int16 var2);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int8 var2);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int8 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int8 var3, unsigned int8 var4);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int16 var2);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int16 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int16 var3);
.................... _bif void bit_set(unsigned int8 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int16 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int32 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int8 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int16 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int32 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int8 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int16 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int32 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int48 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int64 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int48 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int64 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int48 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int64 var, unsigned int8 bit);
.................... _bif unsigned int8 bit_first(int1 value, unsigned int16 var);
.................... _bif unsigned int8 bit_last(int16 var);
.................... _bif unsigned int8 bit_last(int1 value, int16 var);
.................... 
.................... // #use delay() Prototypes:
.................... _bif void delay_cycles(unsigned int16 count);
.................... _bif void delay_ms(unsigned int16 time);
.................... _bif void delay_us(unsigned int16 time);
.................... 
.................... // #use rs232() Prototypes:
.................... _bif void putchar(char cdata);
.................... _bif void putchar(char cdata, unsigned int8 stream);
.................... _bif void puts(char* string);
.................... _bif void puts(char* string, unsigned int8 stream);
.................... _bif char getch(void);
.................... _bif char getch(unsigned int8 stream);
.................... _bif void gets(char* string);
.................... _bif void gets(char* string, unsigned int8 stream);
.................... _bif int1 kbhit(void);
.................... _bif int1 kbhit(unsigned int8 stream);
.................... _bif void printf(char* string, ...);
.................... _bif void fprintf(unsigned int8 stream, char* string, ...);
.................... _bif void putc_send(void);
.................... _bif void fputc_send(unsigned int8 stream);
.................... _bif int1 rcv_buffer_full(void);
.................... _bif int1 rcv_buffer_full(unsigned int8 stream);
.................... _bif unsigned int16 rcv_buffer_bytes(void);
.................... _bif unsigned int16 rcv_buffer_bytes(unsigned int8 stream);
.................... _bif int1 tx_buffer_full(void);
.................... _bif int1 tx_buffer_full(unsigned int8 stream);
.................... _bif unsigned int16 tx_buffer_bytes(void);
.................... _bif unsigned int16 tx_buffer_bytes(unsigned int8 stream);
.................... 
.................... // #use i2c() Prototypes:
.................... _bif unsigned int8 i2c_read(void);
.................... _bif unsigned int8 i2c_read(unsigned int8 stream);
.................... _bif unsigned int8 i2c_read(unsigned int8 stream, int1 ack);
.................... _bif int1 i2c_write(unsigned int8 data);
.................... _bif int1 i2c_write(unsigned int8 stream, unsigned int8 data);
.................... _bif void i2c_start(void);
.................... _bif void i2c_start(unsigned int8 stream);
.................... _bif void i2c_start(unsigned int8 stream, unsigned int8 restart);
.................... _bif void i2c_stop(void);
.................... _bif void i2c_stop(unsigned int8 stream);
.................... _bif int8 i2c_isr_state(void);
.................... _bif void i2c_slaveaddr(unsigned int8 addr);
.................... _bif void i2c_slaveaddr(unsigned int8 stream, unsigned int8 addr);
.................... _bif int1 i2c_poll(void);
.................... _bif int1 i2c_poll(unsigned int8 stream);
.................... _bif void i2c_init(unsigned int32 baud);
.................... _bif void i2c_init(unsigned int8 stream, unsigned int32 baud);
.................... 
.................... // #use spi() Prototypes:
.................... _bif unsigned int8 spi_xfer(void);
.................... _bif unsigned int16 spi_xfer(void);
.................... _bif unsigned int32 spi_xfer(void);
.................... _bif unsigned int8 spi_xfer(unsigned int8 data);
.................... _bif unsigned int16 spi_xfer(unsigned int16 data);
.................... _bif unsigned int32 spi_xfer(unsigned int32 data);
.................... _bif unsigned int8 spi_xfer(unsigned int8 stream, unsigned int8 data);
.................... _bif unsigned int16 spi_xfer(unsigned int8 stream, unsigned int16 data);
.................... _bif unsigned int32 spi_xfer(unsigned int8 stream, unsigned int32 data);
.................... _bif unsigned int8 spi_xfer(unsigned int8 stream, unsigned int8 data, unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer(unsigned int8 stream, unsigned int16 data, unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer(unsigned int8 stream, unsigned int32 data, unsigned int8 bits);
.................... _bif void spi_init(unsigned int32 baud);
.................... _bif void spi_init(unsigned int8 stream, unsigned int32 baud);
.................... _bif void spi_speed(unsigned int32 baud);
.................... _bif void spi_speed(unsigned int8 stream, unsigned int32 baud);
.................... _bif void spi_speed(unsigned int8 stream, unsigned int32 baud, unsigned int32 clock);
.................... _bif void spi_prewrite(unsigned int8 data);
.................... _bif void spi_prewrite(unsigned int16 data);
.................... _bif void spi_prewrite(unsigned int32 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int8 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int16 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int32 data);
.................... _bif unsigned int8 spi_xfer_in(void);
.................... _bif unsigned int16 spi_xfer_in(void);
.................... _bif unsigned int32 spi_xfer_in(void);
.................... _bif unsigned int8 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int8 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... 
.................... // #use rtos() Prototypes:
.................... _bif void rtos_run(void);
.................... _bif void rtos_yield(void);
.................... _bif void rtos_enable(unsigned int8 task);
.................... _bif void rtos_disable(unsigned int8 task);
.................... _bif void rtos_terminate(void);
.................... _bif void rtos_await(int1 flag);
.................... _bif void rtos_wait(unsigned int8 sem);
.................... _bif void rtos_signal(unsigned int8 sem);
.................... _bif void rtos_msg_send(unsigned int8 task, unsigned int8 msg);
.................... _bif unsigned int8 rtos_msg_read(void);
.................... _bif unsigned int8 rtos_msg_poll(void);
.................... _bif int1 rtos_overrun(unsigned int8 task);
.................... _bif void rtos_stats(unsigned int8 task, unsigned int8* stat);
.................... 
.................... // #use timer() Prototypes:
.................... _bif unsigned int8 get_ticks(void);
.................... _bif unsigned int16 get_ticks(void);
.................... _bif unsigned int32 get_ticks(void);
.................... _bif unsigned int64 get_ticks(void);
.................... _bif unsigned int8 get_ticks(unsigned int8 stream);
.................... _bif unsigned int16 get_ticks(unsigned int8 stream);
.................... _bif unsigned int32 get_ticks(unsigned int8 stream);
.................... _bif unsigned int64 get_ticks(unsigned int8 stream);
.................... _bif void set_ticks(unsigned int8 value);
.................... _bif void set_ticks(unsigned int16 value);
.................... _bif void set_ticks(unsigned int32 value);
.................... _bif void set_ticks(unsigned int64 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int8 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int16 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int32 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int64 value);
.................... 
.................... // #use pwm() Prototypes:
.................... _bif void pwm_on(void);
.................... _bif void pwm_on(unsigned int8 stream);
.................... _bif void pwm_off(void);
.................... _bif void pwm_off(unsigned int8 stream);
.................... _bif void pwm_set_duty(unsigned int16 duty);
.................... _bif void pwm_set_duty(unsigned int8 stream, unsigned int16 duty);
.................... _bif void pwm_set_duty_percent(unsigned int16 percent);
.................... _bif void pwm_set_duty_percent(unsigned int8 stream, unsigned int16 percent);
.................... _bif void pwm_set_frequency(unsigned int32 frequency);
.................... _bif void pwm_set_frequency(unsigned int8 stream, unsigned int32 frequency);
.................... 
.................... // #use capture() Prototypes:
.................... _bif unsigned int16 get_capture_time(void);
.................... _bif unsigned int16 get_capture_time(unsigned int8 stream);
.................... _bif int1 get_capture_event(void);
.................... _bif int1 get_capture_event(unsigned int8 stream);
.................... 
.................... // Environment Prototypes:
.................... //_bif unsigned int8 getenv(char* cstring);
.................... 
.................... // Address Prototypes:
.................... #ifndef __ADDRESS__
.................... #define __ADDRESS__ unsigned int32
.................... #endif
.................... _bif void goto_address(__ADDRESS__ address);
.................... _bif __ADDRESS__ label_address(__ADDRESS__ label);
.................... 
.................... // Program Memory Prototypes:
.................... _bif void read_program_memory(__ADDRESS__ address, unsigned int8* dataptr, unsigned int16 count);
.................... _bif void erase_program_memory(__ADDRESS__ address);
.................... _bif void write_program_memory(__ADDRESS__ address, unsigned int8* dataptr, unsigned int16 count);
.................... _bif void read_configuration_memory(unsigned int8* dataptr, unsigned int8 count);
.................... _bif void write_configuration_memory(unsigned int8* dataptr, unsigned int8 count);
.................... 
.................... ////////////////////////////////////////////////////////////////// INT
.................... // Interrupt Functions: ENABLE_INTERRUPTS(), DISABLE_INTERRUPTS(),
.................... //                      CLEAR_INTERRUPT(), INTERRUPT_ACTIVE(),
.................... //                      EXT_INT_EDGE()
.................... // INT Prototypes:
.................... _bif void enable_interrupts(unsigned int16 interrupt);
.................... _bif void disable_interrupts(unsigned int16 interrupt);
.................... _bif void clear_interrupt(unsigned int16 interrupt);
.................... _bif int1 interrupt_active(unsigned int16 interrupt);
.................... _bif int1 interrupt_enabled(unsigned int16 interrupt);
.................... _bif void ext_int_edge(unsigned int8 source, unsigned int8 edge);
.................... _bif void jump_to_isr(unsigned int16 address);
.................... // Constants used in EXT_INT_EDGE() are:
.................... #define L_TO_H              0x40
.................... #define H_TO_L                 0
.................... //
.................... // Constants used in other interrupt functions are:
.................... #define INTR_GLOBAL               0x400
.................... #define GLOBAL                    0x400  // For compatibility with PIC16/18
.................... #define INTR_NORMAL               0x100
.................... #define INTR_ALTERNATE            0x200
.................... #define INTR_LEVEL0               0x500
.................... #define INTR_LEVEL1               0x501
.................... #define INTR_LEVEL2               0x502
.................... #define INTR_LEVEL3               0x503
.................... #define INTR_LEVEL4               0x504
.................... #define INTR_LEVEL5               0x505
.................... #define INTR_LEVEL6               0x506
.................... #define INTR_LEVEL7               0x507
.................... 
.................... #define INTR_CN_PIN              0x8000  // or in a PIN_xx constant
.................... 
.................... #define INT_OSCFAIL               1
.................... #define INT_ADDRERR               2
.................... #define INT_STACKERR              3
.................... #define INT_MATHERR               4
.................... #define INT_DMAERR                5
.................... #define INT_EXT0                  6
.................... #define INT_IC1                   7
.................... #define INT_OC1                   8
.................... #define INT_TIMER1                9
.................... #define INT_DMA0                  69
.................... #define INT_IC2                   70
.................... #define INT_OC2                   71
.................... #define INT_TIMER2                72
.................... #define INT_TIMER3                73
.................... #define INT_SPI1E                 74
.................... #define INT_SPI1                  75
.................... #define INT_RDA                   76
.................... #define INT_TBE                   77
.................... #define INT_ADC1                  78
.................... #define INT_DMA1                  79
.................... #define INT_SI2C                  81
.................... #define INT_MI2C                  82
.................... #define INT_CNI                   84
.................... #define INT_EXT1                  85
.................... #define INT_IC7                   87
.................... #define INT_IC8                   88
.................... #define INT_DMA2                  89
.................... #define INT_OC3                   90
.................... #define INT_OC4                   91
.................... #define INT_TIMER4                92
.................... #define INT_TIMER5                93
.................... #define INT_EXT2                  94
.................... #define INT_RDA2                  95
.................... #define INT_TBE2                  96
.................... #define INT_SPI2E                 97
.................... #define INT_SPI2                  98
.................... #define INT_C1RX                  99
.................... #define INT_CAN1                  100
.................... #define INT_DMA3                  101
.................... #define INT_PWM1                  110
.................... #define INT_DMA4                  111
.................... #define INT_QEI                   123
.................... #define INT_DMA5                  126
.................... #define INT_PWM2                  127
.................... #define INT_FAULTA                128
.................... #define INT_UART1E                130
.................... #define INT_UART2E                131
.................... #define INT_QEI2                  132
.................... #define INT_DMA6                  133
.................... #define INT_DMA7                  134
.................... #define INT_C1TX                  135
.................... #define INT_FAULTA2               139
.................... #define INT_COMP                  152
.................... #define INT_PMP                   164
.................... #define INT_RTC                   173
.................... #define INT_CRC                   174
.................... #define INT_DAC1R                 177
.................... #define INT_DAC1L                 178
.................... 
.................... #list
.................... 
.................... #endif
.................... 
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
*
00732:  CP0     W0
00734:  BTSC.B  42.1
00736:  BRA     740
00738:  REPEAT  #E60
0073A:  NOP     
0073C:  DEC     W0,W0
0073E:  BRA     NZ,738
00740:  RETURN  
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... #include "algoritmo.h"
.................... /**
....................  @file    ALGORITMO.h
....................  @author  Ricardo Gomez, Klaudija Ziliute
....................  @brief   PanTompkins header file
.................... */
.................... 
.................... 
.................... #ifndef __ALGORITMO_H
.................... #define __ALGORITMO_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... 
.................... #WORD ADC1BUF0 = 0x0300;
.................... #WORD ADC1CON1 = 0x0320;
.................... #WORD ADC1CON2 = 0x0322;
.................... #WORD ADC1CON3 = 0x0324;
.................... #WORD AD1CHS0 = 0x0328;
.................... #WORD AD1PCFGL = 0x032C;
.................... #WORD IFS0 = 0x0084;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "BEEP.h"
.................... /**
....................  @file    BEEP.h
....................  @author  Julio Gomis-Tena
....................  @brief   Generate n "beeps" of variable frequency
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __BEEP_H
.................... #define __BEEP_H
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #pin_select OC2 = BUZZER
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void); //Inicializa las frecuencias de los beeps y la separaciÃ³n entre ellos
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP(unsigned int8); //Realiza n beeps
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __BEEP_H
.................... 
.................... 
.................... 
.................... int algoritmo(void);
.................... void init_algoritmo(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ALGORITMO_H
.................... 
.................... #include "SD_Card.h"
.................... /**
....................  @file    SD_CARD.h
....................  @author  Ricardo Gomez, Klaudija Ziliute
....................  @brief   PanTompkins header file
.................... */
.................... 
.................... 
.................... #ifndef __SD_CARD_H
.................... #define __SD_CARD_H
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... #include "miFAT.h"
.................... 
.................... #ifndef __MIFAT_H
.................... #define __MIFAT_H
.................... // Definidos en sdcard.h - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... extern unsigned int8 dt[512];
.................... extern unsigned int32 LBA0;
.................... extern unsigned int8 sd_init();
.................... extern unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr);
.................... extern unsigned int8 sd_read_block( unsigned int32 address, unsigned char* ptr);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define MAX_ENTRIES_SECTOR_FAT16        256
.................... #define ENDFILE16                    0xFFFF
.................... #define MAX_ENTRIES_SECTOR_FAT32        128
.................... #define ENDFILE32                0x0FFFFFFF
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... typedef struct{
.................... 	union{
.................... 		unsigned int8 raw[32];
.................... 		struct fields{
.................... 			char name[8];
.................... 			char extension[3];
.................... 			unsigned int8 attrib;			///sï¿½lo lectura, oculto, de sistema, directorio...
.................... 			//unsigned int8 reserved[10];
.................... 			  unsigned int8  reserved;
.................... 	 		  unsigned int8  createTimeMs;
.................... 			  unsigned int16 create_hour;
.................... 			  unsigned int16 create_date;
.................... 			  unsigned int16 last_access;
.................... 			  unsigned int16 eaIndex;
.................... 			  unsigned int16 modif_hour;
.................... 			  unsigned int16 modif_date;
.................... 			  unsigned int16 first_cluster;	///primer cluster (direcciona tabla FAT y sector para escribir contenido)
.................... 			  unsigned int32 size;			///tamaï¿½o en bytes
.................... 		};
.................... 	};
.................... } fileEntry;
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... typedef struct{
.................... 	unsigned int32 currentCluster;
.................... 	unsigned int32 currentSector;
.................... 	unsigned int16 posInSector;      //posiciï¿½n actual al escribir en el sector
.................... 	unsigned int32 sectorAtFAT;      //sector de la 1ï¿½ FAT en el que tenemos el actual puntero de cierre de fichero
.................... 
.................... 	unsigned int32 sectorEntryFile; //direcciï¿½n del sector de entradas de fichero
.................... 	unsigned int8  EntryFile[512];  //sector donde estï¿½ la entrada (root) del fichero (para actualizar tamaï¿½o)
.................... 	unsigned int16 offsetEntry;     //offset en el sector de entradas del fichero
.................... 	unsigned int32 size;            //tamaï¿½o del fichero
.................... }_file;
.................... 
.................... _file file;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... typedef struct _diskinforec{
....................    unsigned int8  jmpBoot[3];   // bytes  0.. 2: Salto a la rutina de arranque
....................    unsigned int8  OEMName[8];   // bytes  3..10: Es una cadena "MSDOS5.0"
....................    unsigned int16 BytsPerSec;   // bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes)
....................    unsigned int8  SectPerClus;  // byte  13:    Numero de sectores contenidos en 1 cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes
....................    unsigned int16 RsrvdCnt;     // bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente
....................    unsigned int8  NumFATs;      // byte  16:    Numero de tablas FAT en el volumen. Habitualmente es 2
....................    unsigned int16 RootEntCnt;   // bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
....................    unsigned int16 TotSect16;    // bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0)
....................    unsigned int8  Media;        // byte  21:    Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0
....................    unsigned int16 FATsz16;      // bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0)
....................    unsigned int16 SectPerTrack; // bytes 24..25: Sectores por track
....................    unsigned int16 NumHeads;     // bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.)
....................    unsigned int32 HiddSec;      // bytes 28..31: Sectores ocultos que preceden a la particion (irrelevante en uSD)
....................    unsigned int32 TotSect32;    // bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta
....................    unsigned int32 FATsz32;      // bytes 36..39: Numero de sectores ocupados por una FAT
....................    unsigned int16 ExtFlags;     // bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0)
....................    unsigned int16 FSVer;        // bytes 42..43: Version del sistema de archivos (empleamos la 0.0)
....................    unsigned int32 RootClus;     // bytes 44..47: Indica el numero del 1er cluster del directorio raiz.
....................    unsigned int16 FSInfo;       // bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1)
....................    unsigned int16 BkBootSec;    // bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque
....................    unsigned int8  RsrvdSys[12]; // bytes 52..63: Bytes reservados para futuros usos del sistema
....................    unsigned int8  DrvNum;       // byte  64:     Numero de la unidad (para MSDOS pero irrelevante en uSD).
....................    unsigned int8  Reserved1;    // byte  65:     Windows NT para formatear un volumen pone este byte a 0
....................    unsigned int8  BootSig;      // byte  66:     Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows)
....................    unsigned int32 VolId;        // bytes 67..70: Numero de volumen (generado por el reloj del sistema).
....................    unsigned int8  VolLab[11];   // bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME     ". Nosotros podemos poner "NUUBO_SD    "
....................    unsigned int8  FilSysType[8];// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   "
....................    unsigned int8  spam[420];    // bytes 90..509:Zona de codigo (no lo empleamos y esta a 0)
....................    unsigned int16 firma;        // byte 510..511:Debe de vale 55 AA
.................... } diskinforec;
.................... 
.................... diskinforec DiskInfo;
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned  int8 FATType; // FAT16 o FAT32
.................... //variables clave: inicio de la FAT1 y la FAT2 y de las entradas de ficheros
.................... unsigned  int8 sect_x_cluster;
.................... unsigned int16 sect_fat_1;
.................... unsigned int16 sect_fat_2;
.................... unsigned int32 sect_ini_datos;
.................... unsigned int32 sect_x_fat;
.................... unsigned int32 sect_entry;
.................... unsigned int16 sect_reserv;
.................... 
.................... //unsigned int8 dFil[32];
.................... unsigned int32 sector_fat32[MAX_ENTRIES_SECTOR_FAT32]; // 128 x 4 = 512
.................... unsigned int16 sector_fat16[MAX_ENTRIES_SECTOR_FAT16]; // 256 x 2 = 512
.................... 
.................... //atributos
.................... #define __FILE		0x20
.................... #define _DIRECTORY	0x10
.................... #define _VOLUMEN	0x08
.................... #define _SYSTEM		0x04
.................... #define _HIDDEN		0x02
.................... #define READONLY	0x01
.................... 
.................... ///variables globales
.................... unsigned int16 year = 2020;
.................... unsigned int8 yearLo=   20;
.................... unsigned int8 month =   10;
.................... unsigned int8 day   =	15;
.................... unsigned int8 hour	=   12;
.................... unsigned int8 minute=   34;
.................... unsigned int8 second=   56;
.................... 
.................... ///funciones
.................... #define getHour() (int16)((int16)hour << 11) + (int16)((int16)minute << 5) + (int16) (second >> 1)		//5 bits: horas, 6 bits: minutos, 5 bits: segundos/2
.................... #define getDate() (((int16)year - 1980) << 9 ) + ((int16)month << 5) + (int16)day	//7 bits: aï¿½o (desde 1980), 4 bits: mes, 5 bits: dia
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... void initFAT(){
....................    unsigned int32 startClusterOfRootDirectory = 2;
....................    unsigned int32 sctrs;
....................    unsigned  int8 *ptrSct;
....................    diskinforec *ptrDiskInfo;
.................... 
.................... 	sd_read_block(LBA0, dt);
....................     						ptrDiskInfo=&DiskInfo;
....................     						ptrSct= &dt[0];
....................    	memcpy((*ptrDiskInfo).jmpBoot, (ptrSct +  0), 3); 			//DiskInfo.jmpBoot[3]	// bytes  0.. 2: Salto a la rutina de arranque
....................    	memcpy((*ptrDiskInfo).OEMName, (ptrSct +  3), 8); 			//DiskInfo.OEMName[8]	// bytes  3..10: Es una cadena, habitualmente "MSDOS5.0"
....................    	DiskInfo.BytsPerSec = make16(dt[12],dt[11]);   				// bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes)
.................... 	DiskInfo.SectPerClus = dt[13];								// byte  13:	 Numero de sectores contenidos en un cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes
.................... 	DiskInfo.RsrvdCnt = make16(dt[15],dt[14]);					// bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente
....................    	DiskInfo.NumFATs = dt[16];									// byte  16:	 Numero de tablas FAT en el volumen. Habitualmente es 2
.................... 	DiskInfo.RootEntCnt = make16(dt[18],dt[17]);				// bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
....................    	DiskInfo.TotSect16 = make16(dt[20],dt[19]);					// bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0)
.................... 	DiskInfo.Media = dt[21];									// byte  21:	 Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0
.................... 	DiskInfo.FATsz16 = make16(dt[23],dt[22]);					// bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0)
.................... 	DiskInfo.SectPerTrack = make16(dt[25],dt[24]); 				// bytes 24..25: Sectores por track
....................    	DiskInfo.NumHeads = make16(dt[27],dt[26]);					// bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.)
.................... 	DiskInfo.HiddSec = make32(dt[31],dt[30],dt[29],dt[28]);		// bytes 28..31: Sectores ocultos que preceden a la particion
.................... 	DiskInfo.TotSect32=make32(dt[35],dt[34],dt[33],dt[32]);		// bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta
.................... 	DiskInfo.FATsz32 = make32(dt[39],dt[38],dt[37],dt[36]);		// bytes 36..39: Numero de sectores ocupados por una FAT
.................... 	DiskInfo.ExtFlags = make16(dt[41],dt[40]); 					// bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0)
.................... 	DiskInfo.FSVer = make16(dt[43],dt[42]); 					// bytes 42..43: Version del sistema de archivos (empleamos la 0.0)
.................... 	DiskInfo.RootClus= make32(dt[47],dt[46],dt[45],dt[44]);		// bytes 44..47: Indica el numero del 1er cluster del directorio raiz.
.................... 	DiskInfo.FSInfo = make16(dt[49],dt[48]); 					// bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1)
.................... 	DiskInfo.BkBootSec = make16(dt[51],dt[50]); 				// bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque
.................... 	//  Estructura en el caso de FAT32 ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½
.................... 	memcpy((*ptrDiskInfo).RsrvdSys, (ptrSct +  52), 12);		//DiskInfo.RsrvdSys[12] 	// bytes 52..63: Bytes reservados para futuros usos del sistema
.................... 	DiskInfo.DrvNum = dt[64];								 	// byte  64: 	 Numero de la unidad
.................... 	DiskInfo.Reserved1 = dt[65];								// byte  65: 	 Windows NT para formatear un volumen pone este byte a 0
.................... 	DiskInfo.BootSig = dt[66]; 									// byte  66: 	 Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows)
.................... 	DiskInfo.VolId = make32(dt[70],dt[69],dt[68],dt[67]); 		// bytes 67..70: Numero de volumen (generado por el reloj del sistema).
.................... 	memcpy((*ptrDiskInfo).VolLab, (ptrSct +  71), 11);			//DiskInfo.VolLab[11]	// bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME    "
.................... 	memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  82), 8);		//DiskInfo.FilSysType[8] 	// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   "
.................... 	memcpy((*ptrDiskInfo).spam, (ptrSct +  90),420);			//DiskInfo.spam[420]		// bytes 90..509:Zona de codigo (en uSD no se emplea y suele estar a 0)
.................... 	DiskInfo.firma = make16(dt[510],dt[511]);								// byte 510..511:Debe de vale 55 AA
.................... 
....................    		FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'3''2'
.................... 
....................    if(FATType == 32){
.................... 						sect_x_fat  = DiskInfo.FATsz32;		// Sectores reservados para la FAT
.................... 						startClusterOfRootDirectory = DiskInfo.RootClus;
....................  	}else{
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);	//DiskInfo.FilSysType[8] 	// bytes 54..61: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT16   "
.................... 						FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'1''6'
.................... 	}
.................... 
.................... 	if(FATType == 16){
.................... 						DiskInfo.VolId = make32(dt[42],dt[41],dt[40],dt[39]);
.................... 						memcpy((*ptrDiskInfo).VolLab, (ptrSct +  43), 11);
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);
.................... 
.................... 						sect_x_fat  = DiskInfo.FATsz16;		// Sectores reservados para la FAT
.................... 						startClusterOfRootDirectory = DiskInfo.RootEntCnt;
....................  					}
.................... 
....................   	sect_x_cluster = DiskInfo.SectPerClus;					// Cada cluster tiene este numero de sectores
.................... 
....................     			      sctrs  = LBA0;
.................... 				  	  sctrs += DiskInfo.RsrvdCnt;
.................... 	sect_reserv 	= sctrs;								// sectores reservados por el sistema
.................... 
....................     sect_fat_1  	= sctrs;               					// A partir de ahï¿½: FAT 1
.................... 				  	  sctrs += sect_x_fat;
.................... 	sect_fat_2  	= sctrs;;								// A partir de ahï¿½: FAT 2 (copia de seguridad)
.................... 				  	  sctrs += sect_x_fat;
.................... 	sect_entry  	= sctrs ;      							// A partir de ahï¿½ empieza el raï¿½z (la lista de ficheros)
.................... 					  sctrs += sect_x_cluster;
.................... 	sect_ini_datos 	= sctrs ;								// A partir de ahi los datos del fichero
.................... 
....................     if(FATType == 16)										// RootEntCnt: Numero de entradas de 32 bytes al
....................     sect_ini_datos = sect_entry+(DiskInfo.RootEntCnt>>4);	// directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
.................... 
.................... }//fin initFAT()
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void cargaConfig(unsigned int32 j);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... // unsigned int8 encontrar_fichero(){
.................... //    unsigned int8 FicheroEncontrado = 0;
.................... //    unsigned int32 i;
.................... //    unsigned int16 j;
.................... //    unsigned int32 SctStart = sect_entry;			//inicio Root
.................... //    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root
.................... //    unsigned int32 ClstIni  = ((FATType==16)?1:2);
.................... //
.................... //    unsigned int32 ClstNxt;
.................... //    unsigned int32 sctrClstr;
.................... //    unsigned int32 posSctr;
.................... //    unsigned int32 clstrSig;
.................... //
.................... //    for(i = SctStart; i < SctEnd; i++){
.................... // 	      sd_read_block(i, dt);
.................... // 		 for(j = 0; j < 512; j += 32){
.................... // 										if(	(dt[j + 0] == 'C')&&
.................... // 											(dt[j + 1] == 'O')&&
.................... // 											(dt[j + 2] == 'N')&&
.................... // 											(dt[j + 3] == 'F')&&
.................... // 											(dt[j + 4] == 'I')&&
.................... // 											(dt[j + 5] == 'G')&&
.................... // 											(dt[j + 6] == ' ')&&
.................... // 											(dt[j + 7] == ' ')&&
.................... // 											(dt[j + 8] == 'T')&&
.................... // 											(dt[j + 9] == 'X')&&
.................... // 											(dt[j + 10]== 'T')){
.................... // 																 cargaConfig(j);
.................... // 																 FicheroEncontrado = 1;
.................... // 																 return FicheroEncontrado;
.................... // 																}//fin if(CNF)
.................... //
.................... // 		}//j
.................... //    }//i
.................... //    return FicheroEncontrado;
.................... // } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void cargaConfig(unsigned int32 j){
....................    unsigned int32 direccion;
....................    unsigned int32 _sector;
.................... 
.................... 	if(FATType==16){
.................... 	   	direccion = make32(0,0,dt[j+27],dt[j+26]);
.................... 		_sector = ((unsigned int32)direccion - 2) * sect_x_cluster + sect_ini_datos;
.................... 	}
.................... 	if(FATType==32){
.................... 	   direccion = make32(dt[j+21],dt[j+20],dt[j+27],dt[j+26]); //en FAT32 se usa EAIndex + first cluster
.................... 	   _sector = ((unsigned int32)direccion - 3) * sect_x_cluster + sect_ini_datos;
....................    }
....................    sd_read_block(_sector, dt); //leer el primer sector de los datos del fichero
.................... 
....................    // Ahora en el vector dt tengo los datos del fichero y puedo emplearlo
....................    // Por ejemplo: el texto que indica la hora y minutos del ensayo lo obtendria como:
....................    // hora   = (dt[140]-'0')*10 + dt[141]-'0' ;
....................    // minutos= (dt[143]-'0')*10 + dt[144]-'0' ;
....................    // ... Y con esos datos haria algo util
.................... 
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 inicializa_fichero(){
....................    unsigned int8 FicheroIncializado = 0;
....................    unsigned int32 i;
....................    unsigned int16 j;
....................    unsigned int32 SctStart = sect_entry;			//inicio Root
....................    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root
....................    unsigned int32 ClstIni  = ((FATType==16)?0:1);
.................... 
....................    unsigned int32 ClstNxt;
....................    unsigned int32 sctrClstr;
....................    unsigned int32 posSctr;
....................    unsigned int32 clstrSig;
.................... 
....................    unsigned int32 startCluster;      //cluster donde empezarï¿½an los datos del fichero
....................    fileEntry newFile;
.................... 
....................    for(i = SctStart; i < SctEnd; i++){
.................... 	      sd_read_block(i, dt);
.................... 		  for(j = 0; j < 512; j += 32){
.................... 			if((dt[j] == 0x00) || dt[j] == 0xFF){
.................... 					   newFile.fields.name[0] = 		'L';
.................... 					   newFile.fields.name[1] = 		'A';
.................... 					   newFile.fields.name[2] = 		'T';
.................... 					   newFile.fields.name[3] = 		'I';
.................... 					   newFile.fields.name[4] = 		'D';
.................... 					   newFile.fields.name[5] = 		'O';
.................... 					   newFile.fields.name[6] = 		'S';
.................... 					   newFile.fields.name[7] = 		'_';
.................... 					   newFile.fields.extension[0] = 	'T';
.................... 					   newFile.fields.extension[1] = 	'X';
.................... 					   newFile.fields.extension[2] = 	'T';
.................... 					   newFile.fields.reserved = 0;
.................... 					   newFile.fields.createTimeMs = 0;
.................... 					   newFile.fields.create_hour = getHour();
.................... 					   newFile.fields.create_date = getDate();
.................... 					   newFile.fields.last_access = newFile.fields.create_date;
.................... 					   newFile.fields.eaIndex = 0;
.................... 					   newFile.fields.attrib = __FILE | READONLY;   //archivo normal + sï¿½lo lectura
.................... 					   newFile.fields.modif_hour = newFile.fields.create_hour;
.................... 					   newFile.fields.modif_date = newFile.fields.create_date;
.................... 					   newFile.fields.first_cluster = 0;
.................... 					   newFile.fields.size = 0;
.................... 
.................... 					   file.offsetEntry = j;
.................... 					   file.sectorEntryFile = i;
.................... 					   sd_read_block(file.sectorEntryFile, file.EntryFile);
.................... 
.................... 					   for(i = 0; i < 32; j++, i++)  dt[j] = newFile.raw[i];
.................... 					   for(i = 0; i < 512; i++)      file.EntryFile[i] = dt[i];
.................... 					   file.posInSector    = 0;   															//empezamos en un sector y cluster nuevos
.................... 					   if(FATType==16){
.................... 					   startCluster = encontrarCluster(2);         											//busco cluster donde empezarï¿½a a almacenarse los datos
.................... 					   file.currentCluster = startCluster;   												//que serï¿½ el cluster en el que escribiremos
.................... 					   file.currentSector  = (file.currentCluster -  2) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster)
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 8) + sect_reserv;						//sector en la FAT donde marcar el cluster usado
.................... 					   }
.................... 					   if(FATType==32){
.................... 					   startCluster = encontrarCluster(3);         											//busco cluster donde empezarï¿½a a almacenarse los datos
.................... 					   file.currentCluster = startCluster;   												//que serï¿½ el cluster en el que escribiremos
.................... 					   file.currentSector  = (file.currentCluster -  3) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster)
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 7) + sect_reserv;						//sector en la FAT donde marcar el cluster usado
.................... 					   }
.................... 					   file.EntryFile[file.offsetEntry + 27] = make8(file.currentCluster, 1); 					//1er cluster del archivo
.................... 					   file.EntryFile[file.offsetEntry + 26] = make8(file.currentCluster, 0);
.................... 					   file.EntryFile[file.offsetEntry + 21] = make8(file.currentCluster, 3);
.................... 					   file.EntryFile[file.offsetEntry + 20] = make8(file.currentCluster, 2);
.................... 					   file.size = 0;																			//Inicialmente el tamaï¿½o es cero
.................... 
.................... 					   if(FATType==16){
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile);
.................... 						sd_read_block (file.sectorAtFAT, sector_fat16);
.................... 						sector_fat16[file.currentCluster % MAX_ENTRIES_SECTOR_FAT16] = ENDFILE16;				//marco el cluster como usado
.................... 						sd_write_block( file.sectorAtFAT, sector_fat16);
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat16);   //FAT2					//ï¿½Ojo! la cosa puede ser mas complicada...
.................... 						}
.................... 					   if(FATType==32){
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile);
.................... 						sd_read_block (file.sectorAtFAT,sector_fat32);
.................... 						sector_fat32[file.currentCluster % MAX_ENTRIES_SECTOR_FAT32] = ENDFILE32;				//marco el cluster como usado
.................... 						sd_write_block( file.sectorAtFAT, sector_fat32);
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat32);   //FAT2					//ï¿½Ojo! la cosa puede ser mas complicada...
.................... 						}
.................... 					   FicheroIncializado = 1;
.................... 					   return FicheroIncializado;
.................... 					   }
.................... 
.................... 		}//j
....................    }//i
....................    return FicheroIncializado;
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart){
....................    unsigned int32 cluster;
....................    unsigned int32 _sector;   //recorrer sectores
....................    unsigned int32 bytes;     //recorrer bytes en cada sector
.................... 
....................    cluster =  clusterStart;
....................    if(FATType==16)
....................    _sector = (clusterStart >> 2) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante
....................    if(FATType==32)
....................    _sector = (clusterStart >> 3) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante
....................    bytes = (clusterStart % ((FATType==16) ? MAX_ENTRIES_SECTOR_FAT16 : MAX_ENTRIES_SECTOR_FAT32));
.................... 
....................    if(FATType==32){
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT
.................... 		  sd_read_block(_sector,sector_fat32); 							//leemos el sector
....................     					      for(; bytes < MAX_ENTRIES_SECTOR_FAT32; bytes++){ //recorremos el sector para buscar un puntero a cluster libre
.................... 					         if(sector_fat32[bytes]== 0){
.................... 					            if(cluster < 3)               continue;  	//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando
.................... 					            return cluster;
.................... 					         }//fin if
.................... 					         cluster++;
.................... 					      }//fin for de recorrer bytes dentro de un sector
.................... 	      bytes = 0;
.................... 	   }//fin for de recorrer sectores
....................    }else
....................     if(FATType==16){
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT
.................... 		  sd_read_block(_sector,sector_fat16); 							//leemos el sector
.................... 
.................... 					      for(; bytes < MAX_ENTRIES_SECTOR_FAT16; bytes++){ 	//recorremos el sector para buscar un puntero a cluster libre
.................... 					         if(sector_fat16[bytes]== 0){
.................... 					            if(cluster < 2)               continue;		//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando
.................... 					            return cluster;
.................... 					         }//fin if
.................... 					         cluster++;
.................... 					      }//fin for de recorrer bytes dentro de un sector
.................... 	      bytes = 0;
.................... 	   }//fin for de recorrer sectores
.................... 	}
....................    return ((FATType==16)?ENDFILE16:ENDFILE32);
.................... }//fin encontrarCluster
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... void escribe_datos_en_fichero(){
....................    unsigned int32 relSector;
....................    unsigned int32 nextCluster;
....................    unsigned int32  oldCluster;
....................    unsigned int16 _hour, date;
.................... 
.................... 	sd_write_block(file.currentSector, dt);
.................... 
.................... 
.................... 
.................... 
.................... 		file.currentSector++;																					//actualizar las FATs
.................... 		if(FATType==16)
.................... 	    relSector= file.currentSector - ((file.currentCluster -  2) * sect_x_cluster + sect_ini_datos);
.................... 		if(FATType==32)
.................... 	    relSector= file.currentSector - ((file.currentCluster -  3) * sect_x_cluster + sect_ini_datos);
.................... 
.................... 	    if((relSector % sect_x_cluster) == 0){   											//ï¿½el siguiente sector estï¿½ en cluster nuevo?
.................... 	      oldCluster = 	file.currentCluster;
.................... 	      nextCluster = encontrarCluster(oldCluster);   									//siguiente cluster
.................... 	      //escribirCluster(oldCluster, nextCluster);  										//marcar actual cluster para que apunte al siguiente
.................... 	      file.currentCluster = nextCluster;
.................... 		  if(FATType==16)
.................... 	      file.currentSector = (nextCluster - 2) * sect_x_cluster + sect_ini_datos;
.................... 		  if(FATType==32)
.................... 	      file.currentSector = (nextCluster - 3) * sect_x_cluster + sect_ini_datos;
.................... 	   }
.................... 
.................... 	   //actualizar el tamaï¿½o del fichero y fechas
.................... 	   file.size += 512;
.................... 	   file.EntryFile[file.offsetEntry + 28] = make8(file.size, 0);   //tamaï¿½o
.................... 	   file.EntryFile[file.offsetEntry + 29] = make8(file.size, 1);
.................... 	   file.EntryFile[file.offsetEntry + 30] = make8(file.size, 2);
.................... 	   file.EntryFile[file.offsetEntry + 31] = make8(file.size, 3);
.................... 	   //ActualizaReloj();
.................... 	   _hour = getHour();
.................... 	   date = getDate();
.................... 	   file.EntryFile[file.offsetEntry + 24] = make8(date, 0);       //fecha modif
.................... 	   file.EntryFile[file.offsetEntry + 25] = make8(date, 1);
.................... 	   file.EntryFile[file.offsetEntry + 22] = make8(_hour, 0);      //hora modif
.................... 	   file.EntryFile[file.offsetEntry + 23] = make8(_hour, 1);
.................... 	   file.EntryFile[file.offsetEntry + 18] = file.EntryFile[file.offsetEntry + 24];   //fecha ï¿½ltimo acceso
.................... 	   file.EntryFile[file.offsetEntry + 19] = file.EntryFile[file.offsetEntry + 25];
.................... 
.................... 	   sd_write_block(file.sectorEntryFile, file.EntryFile);  	// Actualiza root
.................... 
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __MIFAT_H
.................... 
.................... #include "sdcard.h"
.................... 
.................... #ifndef __SDCARD_H
.................... #define __SDCARD_H
.................... 
.................... #bit  SPIRBF    = getenv("SFR:SPI1STAT").0
.................... #bit  SPITBF    = getenv("SFR:SPI1STAT").1
.................... #bit  SPIROV    = getenv("SFR:SPI1STAT").6
.................... #byte SPI1BUF   = getenv("SFR:SPI1BUF")
.................... #byte SPI1STAT  = getenv("SFR:SPI1STAT")
.................... #byte SPI1CON1  = getenv("SFR:SPI1CON1")
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define   CMD0              		0x40      //go to idle				//Commands
.................... #define   CMD1               		0x41      //initialization process
.................... #define   CMD8               		0x48      //verify interface
.................... #define   CMD17              		0x51      //read single block
.................... #define   CMD24              		0x58      //write single block
.................... #define   CMD55              		0x77      //escape for app specific command
.................... #define   CMD58              		0x7a      //read OCR
.................... #define   ACMD41             		0x69      //poll operation range
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define   R1_READY_STATE          	0x00      //sd ready				//Responses
.................... #define   R1_IDLE_STATE           	0x01      //card in idle state
.................... #define   R1_ILLEGAL_COMMAND      	0x04      //illegal command
.................... #define   DATA_START_BLOCK       	0xFE      //start token for read or write
.................... #define   DATA_RES_MASK          	0x1F      //mask for data response
.................... #define   DATA_RES_ACCEPTED      	0x05      //write accepted
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sdhc;
.................... unsigned int8 dt[512];            /// Buffer de escritura  en uSD
.................... unsigned int32 LBA0 = 0;
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... inline unsigned int8 xfer_spi(char envio){
....................    SPIROV = 0;
....................    SPI1BUF= envio;
....................    while( SPITBF);
....................    while(!SPIRBF);
....................    return SPI1BUF;
.................... }//fin xfer_spi
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 Commnd(char befF, int32 SD_Adress, char befH){
....................    unsigned int8 iC1;
....................    xfer_spi(0xFF);
....................    xfer_spi(befF);
....................    xfer_spi(make8(SD_Adress, 3));
....................    xfer_spi(make8(SD_Adress, 2));
....................    xfer_spi(make8(SD_Adress, 1));
....................    xfer_spi(make8(SD_Adress, 0));
....................    xfer_spi(befH);
....................     do{iC1 = xfer_spi(0xFF);
....................    }while(iC1 == 0xFF);
....................    return iC1;
.................... }//fin Commnd
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_init(){
....................  unsigned  int8 R[17]={0}, versionSD= 1, crc;
....................  unsigned int16 iI;
....................  unsigned int32 arg=0;
.................... 
....................  setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_16);
.................... 
....................  memset(dt,0,512);
....................  // CMD0 - GO_IDLE_STATE  (R1)ï¿½ ï¿½ Card Reset  ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 	do{	output_high(CS);   	// tarjeta deshabilitada
.................... 		for (iI = 0; iI < 10; iI++)  	xfer_spi(0xFF);
.................... 		output_low(CS); 	// tarjeta habilitada
.................... 		R[0] = Commnd( CMD0 , 0x00000000 , 0x95); //go to idle
.................... 	}while( R[0] != R1_IDLE_STATE);
....................   // CMD8 - SEND_IF_COND (R7)  ï¿½ Send Interface Condition Commandï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // Argument 00 - 00 - 01 (Voltage supplied = 2.7-3.6V) - AA (Check pattern)
....................   // Response: illegal command -> Version 1
....................   // Response: echo-back 	   -> Version 2
.................... 	R[0] = Commnd(CMD8, 0x000001AA, 0x87);
....................     if(R[0]& R1_ILLEGAL_COMMAND){	  			versionSD = 1;
....................    			}else{	R[1] = xfer_spi(0xFF);
.................... 					R[2] = xfer_spi(0xFF);
.................... 					R[3] = xfer_spi(0xFF);
.................... 					R[4] = xfer_spi(0xFF);
.................... 				    if(R[4]!=0xAA){	output_high(CS); return 1; }		//error
....................       											versionSD = 2;
....................    			}
.................... 
....................   // ACMD41 - SD_SEND_OP_ COND (R1) ï¿½ ï¿½ Initialization Command   ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // If host supports SDHC or SDXC: HCS (Host Capacity Support) is set to 1 (arg= 0x40000000)
....................   // If host only support SDSC:     HCS (Host Capacity Support) is set to 0 (arg= 0)
....................    arg = (versionSD == 2) ? 0x40000000 : 0;
....................    crc = (versionSD == 2) ? 0x77 : 0xFF;
.................... 
.................... 
....................    do{            Commnd(CMD55,    0, 0x65);	// El proceso puede llegar a durar hasta 1 segundo
....................            R[0] = Commnd(ACMD41, arg, crc);		// Application-Specific Command ï¿½ APP_CMD (CMD55)
.................... 		   delay_ms(4);
....................    }while(R[0] != R1_READY_STATE);
.................... 
....................   if(versionSD == 2){
.................... 
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // CMD58 - READ_OCR (R3) ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // Bit 30 - Card Capacity Status bit: 	0 indicates that the card is SDSC.
....................   //										1 indicates that the card is SDHC or SDXC
.................... 	R[0] = Commnd(CMD58, 0x00000000, 0xFF);
....................     if(R[0] == R1_READY_STATE){	R[1] = xfer_spi(0xFF);
.................... 								R[2] = xfer_spi(0xFF);
.................... 								R[3] = xfer_spi(0xFF);
.................... 								R[4] = xfer_spi(0xFF);
.................... 								sdhc = ((R[1]& 0xC0) == 0xC0) ? 1 : 0;
....................    			}else{				output_high(CS); return 1; }		//error
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 
....................   }// versionSD == 2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
....................   setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_1);
.................... 
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 	sd_read_block(0, dt);	//Lee el sector fisico 0 para obtener el LBA0
.................... 	if(dt[510]==0x55)
.................... 	if(dt[511]==0xAA){ 		// Efectivamente parece que estoy en sct 0
.................... 							// Tabla de particiones
.................... 								LBA0 = make32(dt[457],dt[456],dt[455],dt[454]);
.................... 								if(dt[0]==0xEB) // MBR
....................  								LBA0 = 0;
.................... 						  }//55AA
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 
....................   output_high(CS);   									// tarjeta deshabilitada
....................   return 0;
.................... }//char sd_init()- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr){
....................    unsigned int16 iW;
.................... 
....................    if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores
....................    output_low(CS);
.................... 
.................... 		iW = Commnd(CMD24, address, 0xFF);
....................     if( iW == R1_READY_STATE){
....................              								              		xfer_spi(0xFF);
....................                               									xfer_spi(DATA_START_BLOCK);   // Data start token
....................                            			for(iW = 0; iW < 512; iW++)  xfer_spi(ptr[iW]);
....................                            							xfer_spi(0xFF);   // Dummy bytes
....................                           							xfer_spi(0xFF);   // en lugar del CRC16
.................... 
....................                         do{       iW = xfer_spi(0xFF);
....................                         }while( (iW & DATA_RES_MASK) != DATA_RES_ACCEPTED);
.................... 
....................                         do{       iW = xfer_spi(0xFF); delay_us(100);
....................                         }while(   iW == 0 );
.................... 
.................... 						xfer_spi(0xFF);
.................... 						xfer_spi(0xFF);
.................... 
....................    						output_high(CS);   return 0; //correcto
.................... 						}
....................    						output_high(CS);   return 1; //error
.................... }//fin sd_write_block
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr){
....................    unsigned int16 jR;
....................    unsigned int8  iR;
.................... 
....................     if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores
....................     output_low(CS);
.................... 
....................        iR  = Commnd(CMD17, address, 0xFF);
....................     if(iR == R1_READY_STATE){
.................... 								do{     iR  = xfer_spi(0xFF);
.................... 								}while( iR != DATA_START_BLOCK);
.................... 
.................... 								if(iR == DATA_START_BLOCK){
.................... 								for(jR = 0; jR < 512; jR++)
.................... 								         ptr[jR] = xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
....................   								}
.................... 
....................    							output_high(CS);      return 0;
.................... 							}
.................... 							output_high(CS);      return 1;
.................... }//fin sd_read_block
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __SDCARD_H
.................... 
.................... 
.................... void sd_init_global();
.................... void escritura_sd();
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __SD_CARD_H
.................... 
.................... #include "BLUETOOTH.h"
.................... #ifndef Bluetooth_h
.................... #define Bluetooth_h
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use rs232(UART1,baud=115200,STREAM=BT)
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void init_BT(void); //inits and enables uart isr
.................... void enviar_datos(unsigned int16 ppm);
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... #WORD ADC1BUF0 = 0x0300;
.................... #WORD ADC1CON1 = 0x0320;
.................... #WORD ADC1CON2 = 0x0322;
.................... #WORD ADC1CON3 = 0x0324;
.................... #WORD AD1CHS0 = 0x0328;
.................... #WORD AD1PCFGL = 0x032C;
.................... #WORD IFS0 = 0x0084;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... void adcinit(void) //por comprobar en la placa
.................... {
....................     output_high(BTCM);
*
00978:  BCLR.B  2C1.0
0097A:  BSET.B  2C5.0
....................     setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_31);
0097C:  MOV     #9F00,W4
0097E:  MOV     W4,324
00980:  MOV     #86E0,W4
00982:  MOV     W4,320
....................     setup_adc_ports(sAN4, VSS_VDD);
00984:  MOV     #FFEF,W4
00986:  MOV     W4,32C
00988:  CLR     322
....................     set_adc_channel(4);
0098A:  MOV     #4,W4
0098C:  MOV     W4,328
0098E:  RETURN  
.................... //   setup_timer3(TMR_INTERNAL, 18425); //  200 Hz. Ty/2/18425
.................... //   ADC1CON2 = 0b0000000000000000; // voltage reference en ADC1CON2
.................... //   ADC1CON3 = 0b1000000000000000; // select the analog conversion clock <7:0> y <15> para enable Tad
.................... //   AD1PCFGL = 0b1111111111111110; // AN1 entrada analogica - RB1 - PGC en placa
.................... //   AD1CHS0  = 0b0000000100000001; // AN1 entrada seleccionada para el CH0
.................... //   AD1PCFGL = 0b0000000011110111; // AN4 entrada analogica - RB1 - PGC en placa
.................... //   AD1CHS0  = 0b0000010000000100; // AN4 entrada seleccionada para el CH0
.................... //
.................... //   ADC1CON1 = 0b1011010101000110; // 12 bits - Signed Integer - <7:5> 010 Timer3 for ADC1 - <15> Sampling inmediatly after EOC <9:0> unsigned int
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "algoritmo.h"
.................... /**
....................  @file    ALGORITMO.h
....................  @author  Ricardo Gomez, Klaudija Ziliute
....................  @brief   PanTompkins header file
.................... */
.................... 
.................... 
.................... #ifndef __ALGORITMO_H
.................... #define __ALGORITMO_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #ifndef LIB_h
.................... #define LIB_h
.................... 
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device DSPIC33FJ128MC804
*
002C0:  MOV     W5,[W15++]
002C2:  MOV     W6,[W15++]
002C4:  MOV     #8E,W1
002C6:  CP0     W0
002C8:  BRA     Z,2EE
002CA:  BTSC    W0.F
002CC:  BRA     2D6
002CE:  BCLR.B  42.0
002D0:  RLC     W0,W0
002D2:  DEC     W1,W1
002D4:  BRA     2CA
002D6:  SWAP    W1
002D8:  BCLR.B  42.0
002DA:  RRC     W1,W1
002DC:  BCLR    W0.F
002DE:  SWAP    W0
002E0:  XOR.B   W0L,W1L,W1L
002E2:  AND.B   #0,W0L
002E4:  BRA     2F4
002E6:  MOV.B   W1L,W0L
002E8:  BSET    W1.7
002EA:  AND.B   #0,W1L
002EC:  BRA     2F4
002EE:  CLR     W0
002F0:  CLR     W1
002F2:  BRA     2F4
002F4:  MOV     [--W15],W6
002F6:  MOV     [--W15],W5
002F8:  RETURN  
002FA:  MOV     W5,[W15++]
002FC:  MOV     W6,[W15++]
002FE:  MOV     W7,[W15++]
00300:  XOR     W1,W3,W4
00302:  BTSS    W4.F
00304:  BRA     312
00306:  BCLR.B  42.0
00308:  BCLR.B  42.1
0030A:  BTSS    W1.F
0030C:  BRA     35A
0030E:  BSET.B  42.0
00310:  BRA     35A
00312:  MOV     W1,W4
00314:  MOV     W0,W5
00316:  MOV     W3,W6
00318:  MOV     W2,W7
0031A:  RLC     W1,W1
0031C:  SWAP    W1
0031E:  RLC     W3,W3
00320:  SWAP    W3
00322:  SUB.B   W3L,W1L,W1L
00324:  BRA     Z,330
00326:  BTSS    W4.F
00328:  BRA     35A
0032A:  MOV     #1,W0
0032C:  XOR.B   42
0032E:  BRA     35A
00330:  MOV.B   W4L,W1L
00332:  MOV.B   W6L,W3L
00334:  BCLR    W1.7
00336:  BCLR    W3.7
00338:  SUB.B   W3L,W1L,W1L
0033A:  BRA     Z,346
0033C:  BTSS    W4.F
0033E:  BRA     35A
00340:  MOV     #1,W0
00342:  XOR.B   42
00344:  BRA     35A
00346:  SUB     W7,W5,W1
00348:  BRA     Z,354
0034A:  BTSS    W4.F
0034C:  BRA     35A
0034E:  MOV     #1,W0
00350:  XOR.B   42
00352:  BRA     35A
00354:  BCLR.B  42.0
00356:  BRA     35A
00358:  BRA     35A
0035A:  MOV     [--W15],W7
0035C:  MOV     [--W15],W6
0035E:  MOV     [--W15],W5
00360:  RETURN  
*
00384:  MOV     W5,[W15++]
00386:  MOV     #C,W5
00388:  REPEAT  #4
0038A:  MOV     [W5++],[W15++]
0038C:  CLR     W9
0038E:  XOR     W1,W3,W9
00390:  MOV     W1,W6
00392:  MOV     W0,W5
00394:  MOV     W3,W8
00396:  MOV     W2,W7
00398:  RLC     W1,W1
0039A:  SWAP    W1
0039C:  ZE      W1,W1
0039E:  CP0     W1
003A0:  BRA     Z,43E
003A2:  RLC     W3,W3
003A4:  SWAP    W3
003A6:  ZE      W3,W3
003A8:  CP0     W3
003AA:  BRA     Z,43E
003AC:  CLR     W0
003AE:  SUB.B   W1L,W3L,W0L
003B0:  BRA     NC,3B8
003B2:  ADD.B   #7F,W0L
003B4:  BRA     C,43E
003B6:  BRA     3BE
003B8:  SUB.B   #81,W0L
003BA:  BRA     NC,43E
003BC:  BRA     Z,43E
003BE:  MOV     W5,W1
003C0:  MOV     W6,W2
003C2:  BSET    W2.7
003C4:  AND     #FF,W2
003C6:  AND     #FF,W8
003C8:  BSET    W8.7
003CA:  MOV     #19,W10
003CC:  CLR     W3
003CE:  CLR     W4
003D0:  SUB     W1,W7,W1
003D2:  SUBB    W2,W8,W2
003D4:  BRA     N,3DA
003D6:  BRA     C,3E0
003D8:  BRA     NZ,3E2
003DA:  ADD     W1,W7,W1
003DC:  ADDC    W2,W8,W2
003DE:  BRA     3E2
003E0:  BSET    W4.0
003E2:  DEC     W10,W10
003E4:  BRA     Z,3F4
003E6:  BCLR.B  42.0
003E8:  RLC     W1,W1
003EA:  RLC     W2,W2
003EC:  BCLR.B  42.0
003EE:  RLC     W4,W4
003F0:  RLC     W3,W3
003F2:  BRA     3D0
003F4:  CLR     W10
003F6:  BTSC    W3.8
003F8:  BRA     3FC
003FA:  BRA     408
003FC:  BCLR.B  42.0
003FE:  RRC     W3,W3
00400:  BCLR    W3.7
00402:  RRC     W4,W4
00404:  RLC     W10,W10
00406:  BRA     40C
00408:  DEC     W0,W0
0040A:  BRA     Z,43E
0040C:  BTSC    W10.F
0040E:  BRA     NC,41A
00410:  RLC     W1,W1
00412:  RLC     W2,W2
00414:  SUB     W1,W7,W1
00416:  SUBB    W2,W8,W2
00418:  BRA     NC,42C
0041A:  INC     W4,W4
0041C:  BRA     NZ,42C
0041E:  INC     W3,W3
00420:  BRA     NZ,42C
00422:  INC     W0,W0
00424:  BRA     Z,43E
00426:  BRA     42C
00428:  DEC     W0,W0
0042A:  BRA     Z,43E
0042C:  SWAP    W0
0042E:  RRC     W0,W1
00430:  BSET    W1.F
00432:  BTSS    W9.F
00434:  BCLR    W1.F
00436:  BCLR    W3.7
00438:  XOR.B   W3L,W1L,W1L
0043A:  MOV     W4,W0
0043C:  BRA     444
0043E:  MOV     #0,W0
00440:  MOV     #0,W1
00442:  BRA     444
00444:  MOV     #14,W5
00446:  REPEAT  #4
00448:  MOV     [--W15],[W5--]
0044A:  MOV     [--W15],W5
0044C:  RETURN  
0044E:  MOV     W5,[W15++]
00450:  MOV     #C,W5
00452:  REPEAT  #3
00454:  MOV     [W5++],[W15++]
00456:  CLR     W9
00458:  MOV     #8000,W8
0045A:  BTSC.B  43.0
0045C:  XOR     W8,W3,W3
0045E:  CP0     W0
00460:  BRA     NZ,468
00462:  MOV     #7FFF,W10
00464:  AND     W1,W10,W10
00466:  BTSS.B  42.1
00468:  MOV     W1,W10
0046A:  XOR     W3,W10,W11
0046C:  MOV     W1,W6
0046E:  MOV     W3,W7
00470:  MOV     W3,W12
00472:  BCLR.B  42.1
00474:  BCLR.B  42.0
00476:  RLC     W6,W6
00478:  SWAP    W6
0047A:  AND     #FF,W6
0047C:  CP0     W6
0047E:  BRA     Z,5C2
00480:  BCLR.B  42.1
00482:  BCLR.B  42.0
00484:  RLC     W7,W7
00486:  SWAP    W7
00488:  AND     #FF,W7
0048A:  CP0     W7
0048C:  BRA     Z,5CC
0048E:  BCLR.B  42.1
00490:  BCLR.B  42.0
00492:  CP      W7,W6
00494:  BRA     Z,5CE
00496:  BRA     N,5DE
00498:  BCLR    W9.0
0049A:  BSET    W9.1
0049C:  SUB     W7,W6,W8
0049E:  MOV     W7,W6
004A0:  AND     #FF,W1
004A2:  BSET    W1.7
004A4:  AND     #FF,W3
004A6:  BSET    W3.7
004A8:  MOV     #28,W7
004AA:  CP      W7,W8
004AC:  BRA     N,4D0
004AE:  BCLR.B  42.1
004B0:  BCLR.B  42.0
004B2:  RRC     W1,W1
004B4:  RRC     W0,W0
004B6:  DEC     W8,W8
004B8:  BRA     NZ,4AE
004BA:  BRA     4D6
004BC:  MOV     #28,W7
004BE:  CP      W7,W8
004C0:  BRA     N,4D4
004C2:  BCLR.B  42.1
004C4:  BCLR.B  42.0
004C6:  RRC     W3,W3
004C8:  RRC     W2,W2
004CA:  DEC     W8,W8
004CC:  BRA     NZ,4C2
004CE:  BRA     4EE
004D0:  MOV     W2,W0
004D2:  MOV     W3,W1
004D4:  BRA     55C
004D6:  BTSS    W11.F
004D8:  BRA     4FC
004DA:  BTSC    W9.4
004DC:  MOV     W12,W11
004DE:  NEG     W0,W0
004E0:  BRA     Z,4E6
004E2:  COM.B   W1L,W1L
004E4:  BRA     4E8
004E6:  NEG     W1,W1
004E8:  BTSC    W9.4
004EA:  BRA     542
004EC:  BRA     4FC
004EE:  BTSS    W11.F
004F0:  BRA     4FC
004F2:  NEG     W2,W2
004F4:  BRA     Z,4FA
004F6:  COM.B   W3L,W3L
004F8:  BRA     4FC
004FA:  NEG     W3,W3
004FC:  AND     #FF,W5
004FE:  BCLR.B  42.1
00500:  BCLR.B  42.0
00502:  ADD     W0,W2,W0
00504:  ADDC.B  W1L,W3L,W1L
00506:  BTSC.B  42.0
00508:  BSET    W9.3
0050A:  BTSC    W9.0
0050C:  BRA     520
0050E:  BTSC    W9.1
00510:  BRA     514
00512:  BRA     52A
00514:  BTSC    W11.F
00516:  BRA     542
00518:  BTSC    W9.3
0051A:  BRA     56E
0051C:  BSET    W9.6
0051E:  BRA     55C
00520:  BTSC    W11.F
00522:  BRA     542
00524:  BTSC    W9.3
00526:  BRA     56E
00528:  BRA     55C
0052A:  BCLR    W9.2
0052C:  BTSC    W11.F
0052E:  BRA     538
00530:  MOV     W10,W11
00532:  BTSC    W9.3
00534:  BRA     56E
00536:  BRA     5A4
00538:  BSET    W9.4
0053A:  XOR.B   #80,W1L
0053C:  BTSC    W1.7
0053E:  BRA     4DA
00540:  MOV     W10,W11
00542:  AND     #FF,W1
00544:  IOR      W0,  W1,W7
00546:  BRA     Z,55C
00548:  BTSC    W1.7
0054A:  BRA     55C
0054C:  BCLR.B  42.1
0054E:  BCLR.B  42.0
00550:  RLC     W0,W0
00552:  RLC     W1,W1
00554:  DEC     W6,W6
00556:  BTSC.B  42.1
00558:  BRA     5BC
0055A:  BRA     548
0055C:  BTSC    W9.0
0055E:  MOV     W10,W11
00560:  BTSC    W9.1
00562:  MOV     W12,W11
00564:  BTSS    W9.5
00566:  BRA     59C
00568:  BTSC    W10.F
0056A:  BSET    W0.8
0056C:  BRA     5A4
0056E:  BSET.B  42.0
00570:  RRC.B   W1L,W1L
00572:  RRC     W0,W0
00574:  BTSC.B  42.0
00576:  BSET    W9.5
00578:  INC     W6,W6
0057A:  BRA     Z,5BC
0057C:  BTSS    W9.5
0057E:  BRA     590
00580:  INC     W0,W0
00582:  BRA     NZ,590
00584:  INC.B   W1L,W1L
00586:  BRA     NZ,590
00588:  RRC.B   W1L,W1L
0058A:  RRC     W0,W0
0058C:  INC     W6,W6
0058E:  BRA     Z,5BC
00590:  BTSC    W9.0
00592:  MOV     W10,W11
00594:  BTSC    W9.1
00596:  MOV     W12,W11
00598:  BTSC.B  42.1
0059A:  BRA     5BC
0059C:  BTSC    W9.6
0059E:  MOV     W10,W11
005A0:  BTSC    W9.7
005A2:  MOV     W12,W11
005A4:  IOR      W0,  W1,W2
005A6:  BRA     Z,5EE
005A8:  BCLR    W1.7
005AA:  SWAP    W6
005AC:  BCLR.B  42.1
005AE:  BCLR.B  42.0
005B0:  RRC     W6,W6
005B2:  XOR     W6,W1,W1
005B4:  BSET    W1.F
005B6:  BTSS    W11.F
005B8:  BCLR    W1.F
005BA:  BRA     5EE
005BC:  MOV     #0,W0
005BE:  MOV     #0,W1
005C0:  BRA     5EE
005C2:  BTSC    W10.F
005C4:  XOR     W8,W3,W3
005C6:  MOV     W2,W0
005C8:  MOV     W3,W1
005CA:  BRA     5EE
005CC:  BRA     5EE
005CE:  AND     #FF,W3
005D0:  BSET    W3.7
005D2:  AND     #FF,W1
005D4:  BSET    W1.7
005D6:  BTSC    W11.F
005D8:  BCLR    W3.7
005DA:  BSET    W9.2
005DC:  BRA     4EE
005DE:  SUB     W6,W7,W8
005E0:  AND     #FF,W1
005E2:  BSET    W1.7
005E4:  AND     #FF,W3
005E6:  BSET    W3.7
005E8:  BCLR    W9.1
005EA:  BSET    W9.0
005EC:  BRA     4BC
005EE:  MOV     #12,W5
005F0:  REPEAT  #3
005F2:  MOV     [--W15],[W5--]
005F4:  MOV     [--W15],W5
005F6:  RETURN  
.................... 
.................... #list
.................... 
.................... #endif
.................... 
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... #WORD ADC1BUF0 = 0x0300;
.................... #WORD ADC1CON1 = 0x0320;
.................... #WORD ADC1CON2 = 0x0322;
.................... #WORD ADC1CON3 = 0x0324;
.................... #WORD AD1CHS0 = 0x0328;
.................... #WORD AD1PCFGL = 0x032C;
.................... #WORD IFS0 = 0x0084;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "lcd.h"
.................... /**
....................  @file    lcd.h
....................  @author  Ricardo Gï¿½mez
....................  @brief   LCD management
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __LCD_H
.................... #define __LCD_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... /* SECTION 1: Included header files to compile this file           */
.................... 
.................... /* SECTION 2: Public macros                                        */
.................... 
.................... #define _CLEAR_DISPLAY 				0x01
.................... #define _8BIT_4LINES_NORMAL_RE1_IS0		0x3A
.................... #define _8BIT_4LINES_REVERSE_RE1_IS0		0x3B
.................... #define _8BIT_4LINES_RE0_IS1			0x39
.................... #define _8BIT_4LINES_RE0_IS0			0x38
.................... 
.................... #define _BS1_1					0x1E
.................... #define _POWER_DOWN_DISABLE			0x02
.................... #define _SEGMENT_NORMAL_WAY			0x05
.................... #define _NW					0x09
.................... 
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_ON		0x0F
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_OFF		0x0E
.................... #define _DISPLAY_ON_CURSOR_OFF_BLINK_OFF	0x0C
.................... #define _BS0_1					0x1C
.................... #define _INTERNAL_DIVIDER			0x13
.................... #define _CONTRAST				0x77
.................... #define _POWER_ICON_CONTRAST			0x5C
.................... #define _FOLLOWER_CONTROL			0x6E
.................... 
.................... #define ADDRESS_DDRAM				0x80
.................... 
.................... 
.................... /* SECTION 3: Public types                                         */
.................... 
.................... 
.................... /* SECTION 4: Public variables :: declarations, extern mandatory   */
.................... 
.................... 
.................... /* SECTION 5: Public functions :: declarations, extern optional
....................    Rule exception (callbacks)  :: declarations, extern recommended */
.................... void display_valueADC_title(void);
.................... void LCD_command(unsigned int8);
.................... void lcdi2cinit(void);
.................... void LCD_write(char*);
.................... void initmenu(void);                                      //Inicializa el menu principal
.................... void display_frecuencia(void);       // Muestra frecuencia
.................... void LCD_cursor_at(unsigned int8 line, unsigned int8 column);
.................... void display_alarma_alto(void); // Limpia pantalla y escribe mensaje de alarma
.................... void display_alarma_bajo(void);
.................... void display_final(void);
.................... 
.................... 
.................... #endif // __LCD_H
.................... // Do not write below this line!
.................... 
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #ifndef LIB_h
.................... #define LIB_h
.................... 
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device DSPIC33FJ128MC804
.................... 
.................... #nolist
.................... //////// Program memory: 44032x24  Data RAM: 16384  Stack: 31
.................... //////// I/O: 35   Analog Pins: 9
.................... //////// Fuses: WRTB,NOWRTB,BSSHL,BSSHM,BSSHS,BSSSL,BSSSM,BSSSS,NOBSS
.................... //////// Fuses: RBS1024,RBS256,RBS128,NORBS,WRTSS,NOWRTSS,SSSHL,SSSHM,SSSHS
.................... //////// Fuses: SSSSL,SSSSM,SSSSS,NOSSS,RSS4096,RSS2048,RSS256,NORSS,WRT
.................... //////// Fuses: NOWRT,PROTECT_HIGH,PROTECT,NOPROTECT,FRC,FRC_PLL,PR,PR_PLL
.................... //////// Fuses: SOSC,LPRC,FRC_DIV_BY_16,FRC_PS,NOIESO,IESO,EC,XT,HS,NOPR
.................... //////// Fuses: OSCIO,NOOSCIO,NOIOL1WAY,IOL1WAY,CKSFSM,CKSNOFSM,NOCKSFSM
.................... //////// Fuses: WPOSTS1,WPOSTS2,WPOSTS3,WPOSTS4,WPOSTS5,WPOSTS6,WPOSTS7
.................... //////// Fuses: WPOSTS8,WPOSTS9,WPOSTS10,WPOSTS11,WPOSTS12,WPOSTS13,WPOSTS14
.................... //////// Fuses: WPOSTS15,WPOSTS16,WPRES32,WPRES128,NOWINDIS,WINDIS,NOWDT,WDT
.................... //////// Fuses: NOPUT,PUT2,PUT4,PUT8,PUT16,PUT32,PUT64,PUT128,ALTI2C1
.................... //////// Fuses: NOALTI2C1,LPOL_LOW,LPOL_HIGH,HPOL_LOW,HPOL_HIGH,PWMPIN
.................... //////// Fuses: NOPWMPIN,ICSP3,ICSP2,ICSP1,NOJTAG,JTAG,DEBUG,NODEBUG
.................... ////////
.................... #if (!defined(__PCD__)||defined(__ISNT_CCS__))
.................... #define _bif
.................... #define int8 char
.................... #define int16 int
.................... #define int32 long
.................... #define int48 long
.................... #define int64 long long
.................... #define float32 float
.................... #define float48 float
.................... #define float64 double
.................... #define int1 char
.................... 
.................... #endif
.................... ////////////////////////////////////////////////////////////////// PIN_SELECT
.................... // #pin_select function=pin
.................... // Valid Pins:
.................... //    PIN_B0,PIN_B1,PIN_B2,PIN_B3,PIN_B4,PIN_B5,PIN_B6,PIN_B7,PIN_B8,PIN_B9,
.................... //    PIN_B10,PIN_B11,PIN_B12,PIN_B13,PIN_B14,PIN_B15,PIN_C0,PIN_C1,PIN_C2,
.................... //    PIN_C3,PIN_C4,PIN_C5,PIN_C6,PIN_C7,PIN_C8,PIN_C9
.................... // Input Functions:
.................... //    INT1,INT2,T2CK,T3CK,T4CK,T5CK,IC1,IC2,IC3,IC4,IC5,OCFA,OCFB,U1RX,U1CTS,
.................... //    U2RX,U2CTS,SDI1,SCK1IN,SS1IN,SDI2,SCK2IN,SS2IN,C1RX,IC7,IC8,CSDI,CSCK,COFS,
.................... //    FLTA1,FLTA2,QEA1,QEB1,INDX1,QEA2,QEB2,INDX2,T1CK,FLT1,FLT2,FLT3,FLT4,FLT5,
.................... //    FLT6,FLT7,FLT8,SYNCI1,SYNCI2
.................... // Output Functions:
.................... //    NULL,C1OUT,C2OUT,U1TX,U1RTS,U2TX,U2RTS,SDO1,SCK1OUT,SS1OUT,SDO2,SCK2OUT,
.................... //    SS2OUT,OC1,OC2,OC3,OC4,OC5,C1TX,CSDO,CSCKOUT,COFSOUT,UPDN1,UPDN2,CTPLS,
.................... //    C3OUT,SYNCO1,REFCLKO,CMP1,CMP2,CMP3,CMP4,PWM4H,PWM4L
.................... //
.................... 
.................... ////////////////////////////////////////////////////////////////// I/O
.................... // Discrete I/O Functions: SET_TRIS_x(), OUTPUT_x(), INPUT_x(),
.................... //                         SET_PULLUP(), INPUT(),
.................... //                         OUTPUT_LOW(), OUTPUT_HIGH(),
.................... //                         OUTPUT_FLOAT(), OUTPUT_BIT()
.................... // Discrete I/O Prototypes:
.................... _bif void set_tris_a(unsigned int16 value);
.................... _bif void set_tris_b(unsigned int16 value);
.................... _bif void set_tris_c(unsigned int16 value);
.................... _bif unsigned int16 get_tris_a(void);
.................... _bif unsigned int16 get_tris_b(void);
.................... _bif unsigned int16 get_tris_c(void);
.................... _bif void output_a(unsigned int16 value);
.................... _bif void output_b(unsigned int16 value);
.................... _bif void output_c(unsigned int16 value);
.................... _bif unsigned int16 input_a(void);
.................... _bif unsigned int16 input_b(void);
.................... _bif unsigned int16 input_c(void);
.................... _bif int16 input_change_a(void);
.................... _bif int16 input_change_b(void);
.................... _bif int16 input_change_c(void);
.................... _bif void set_pullup(int1 state);
.................... _bif void set_pullup(int1 state, unsigned int16 pin);
.................... _bif void set_pulldown(int1 state);
.................... _bif void set_pulldown(int1 state, unsigned int16 pin);
.................... _bif int1 input(unsigned int16 pin);
.................... _bif int1 input_state(unsigned int16 pin);
.................... _bif void output_low(unsigned int16 pin);
.................... _bif void output_high(unsigned int16 pin);
.................... _bif void output_toggle(unsigned int16 pin);
.................... _bif void output_bit(unsigned int16 pin, int1 level);
.................... _bif void output_float(unsigned int16 pin);
.................... _bif void output_drive(unsigned int16 pin);
.................... // Constants used to identify pins in the above are:
.................... 
.................... #define PIN_A0  5648
.................... #define PIN_A1  5649
.................... #define PIN_A2  5650
.................... #define PIN_A3  5651
.................... #define PIN_A4  5652
.................... #define PIN_A7  5655
.................... #define PIN_A8  5656
.................... #define PIN_A9  5657
.................... #define PIN_A10  5658
.................... 
.................... #define PIN_B0  5712
.................... #define PIN_B1  5713
.................... #define PIN_B2  5714
.................... #define PIN_B3  5715
.................... #define PIN_B4  5716
.................... #define PIN_B5  5717
.................... #define PIN_B6  5718
.................... #define PIN_B7  5719
.................... #define PIN_B8  5720
.................... #define PIN_B9  5721
.................... #define PIN_B10  5722
.................... #define PIN_B11  5723
.................... #define PIN_B12  5724
.................... #define PIN_B13  5725
.................... #define PIN_B14  5726
.................... #define PIN_B15  5727
.................... 
.................... #define PIN_C0  5776
.................... #define PIN_C1  5777
.................... #define PIN_C2  5778
.................... #define PIN_C3  5779
.................... #define PIN_C4  5780
.................... #define PIN_C5  5781
.................... #define PIN_C6  5782
.................... #define PIN_C7  5783
.................... #define PIN_C8  5784
.................... #define PIN_C9  5785
.................... 
.................... ////////////////////////////////////////////////////////////////// Useful defines
.................... #define FALSE 0
.................... #define TRUE 1
.................... 
.................... #define BYTE unsigned int8
.................... #define BOOLEAN int1
.................... 
.................... #define getc getch
.................... #define fgetc getch
.................... #define getchar getch
.................... #define putc putchar
.................... #define fputc putchar
.................... #define fgets gets
.................... #define fputs puts
.................... 
.................... ////////////////////////////////////////////////////////////////// UART
.................... // UART Prototypes:
.................... _bif void setup_uart(unsigned int32 baud);
.................... _bif void setup_uart(unsigned int32 baud, unsigned int8 stream);
.................... _bif void setup_uart(unsigned int32 baud, unsigned int8 stream, unsigned int32 clock);
.................... _bif void set_uart_speed(unsigned int32 baud);
.................... _bif void set_uart_speed(unsigned int32 baud, unsigned int8 stream);
.................... _bif void set_uart_speed(unsigned int32 baud, unsigned int8 stream, unsigned int32 clock);
.................... // Constants used in setup_uart() are:
.................... // FALSE - Turn UART off
.................... // TRUE  - Turn UART on
.................... #define UART_ADDRESS           2
.................... #define UART_DATA              4
.................... #define UART_AUTODETECT        8
.................... #define UART_AUTODETECT_NOWAIT 9
.................... #define UART_WAKEUP_ON_RDA     10
.................... #define UART_SEND_BREAK        13
.................... 
.................... ////////////////////////////////////////////////////////////////// WDT
.................... // Watch Dog Timer Functions: SETUP_WDT() and RESTART_WDT()
.................... // WDT Prototypes:
.................... _bif void setup_wdt(unsigned int8 mode);
.................... _bif void restart_wdt(void);
.................... // Constants used for SETUP_WDT() are:
.................... #define WDT_ON      1
.................... #define WDT_OFF     0
.................... 
.................... #define  WDT_1MS    0x002
.................... #define  WDT_2MS    0x003
.................... #define  WDT_4MS    0x004
.................... #define  WDT_8MS    0x005
.................... #define  WDT_16MS   0x006
.................... #define  WDT_32MS   0x007
.................... #define  WDT_64MS   0x008
.................... #define  WDT_128MS  0x009
.................... #define  WDT_256MS  0x00A
.................... #define  WDT_512MS  0x00B
.................... #define  WDT_1S     0x00C
.................... #define  WDT_2S     0x00D
.................... #define  WDT_4S     0x00E
.................... #define  WDT_8S     0x00F
.................... #define  WDT_16S    0x010
.................... #define  WDT_33S    0x011
.................... #define  WDT_65S    0x030
.................... #define  WDT_131S   0x031
.................... 
.................... ////////////////////////////////////////////////////////////////// Control
.................... // Control Functions:  RESET_CPU(), SLEEP(), RESTART_CAUSE()
.................... // Prototypes:
.................... _bif unsigned int8 restart_cause(void);
.................... _bif void reset_cpu(void);
.................... _bif void sleep(void);
.................... _bif void sleep(unsigned int8 mode);
.................... // Constants passed into RESTART_CAUSE() are:
.................... #define RESTART_POWER_UP      0
.................... #define RESTART_BROWNOUT      1
.................... #define RESTART_WATCHDOG      4
.................... #define RESTART_SOFTWARE      6
.................... #define RESTART_MCLR          7
.................... #define RESTART_ILLEGAL_OP    14
.................... #define RESTART_TRAP_CONFLICT 15
.................... //
.................... // Constants passed into SLEEP() are:
.................... #define SLEEP_FULL      0  // Default
.................... #define SLEEP_IDLE      1  // Clock and peripherals don't stop
.................... 
.................... ////////////////////////////////////////////////////////////////// INTERNAL RC
.................... // Oscillator Prototypes:
.................... _bif void setup_oscillator(unsigned int8 type, unsigned int32 target);
.................... _bif void setup_oscillator(unsigned int8 type, unsigned int32 target, unsigned int32 source);
.................... // Constants used in setup_oscillator() are:
.................... #define OSC_INTERNAL     32
.................... #define OSC_CRYSTAL       1
.................... #define OSC_CLOCK         2
.................... #define OSC_RC            3
.................... #define OSC_SECONDARY    16
.................... 
.................... ////////////////////////////////////////////////////////////////// Timer
.................... // Timer Functions: SETUP_TIMERx, GET_TIMERx, GET_TIMERxy,
.................... // SET_TIMERx, SET_TIMERxy
.................... // Timer x Prototypes:
.................... _bif void setup_timer1(unsigned int16 mode);
.................... _bif void setup_timer1(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer1(void);
.................... _bif void set_timer1(unsigned int16 value);
.................... _bif void setup_timer2(unsigned int16 mode);
.................... _bif void setup_timer2(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer2(void);
.................... _bif void set_timer2(unsigned int16 value);
.................... _bif void setup_timer3(unsigned int16 mode);
.................... _bif void setup_timer3(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer3(void);
.................... _bif void set_timer3(unsigned int16 value);
.................... _bif unsigned int32 get_timer23(void);
.................... _bif void set_timer23(unsigned int32 value);
.................... _bif void setup_timer4(unsigned int16 mode);
.................... _bif void setup_timer4(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer4(void);
.................... _bif void set_timer4(unsigned int16 value);
.................... _bif void setup_timer5(unsigned int16 mode);
.................... _bif void setup_timer5(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer5(void);
.................... _bif void set_timer5(unsigned int16 value);
.................... _bif unsigned int32 get_timer45(void);
.................... _bif void set_timer45(unsigned int32 value);
.................... // Constants used for SETUP_TIMERx() are:
.................... //      (or (via |) together constants from each group)
.................... #define TMR_DISABLED 0x0000
.................... #define TMR_INTERNAL 0x8000
.................... #define TMR_EXTERNAL 0x8002
.................... #define TMR_GATE     0x0040
.................... 
.................... #define TMR_DIV_BY_1   0x0000
.................... #define TMR_DIV_BY_8   0x0010
.................... #define TMR_DIV_BY_64  0x0020
.................... #define TMR_DIV_BY_256 0x0030
.................... #define TMR_32_BIT     0x0008 // Only for even numbered timers
.................... 
.................... #define TMR_HALT_IDLE      0x2000
.................... #define TMR_CONTINUE_IDLE  0x0000
.................... 
.................... #define T1_EXTERNAL_SYNC  0x8006 //This only applies to Timer1
.................... #define T1_EXTERNAL_RTC   0xC002 //This only applies to Timer1
.................... /////////////////////////////////////////////////////////// INPUT CAPTURE
.................... // Functions: SETUP_CAPTURE, GET_CAPTURE,
.................... // IC Prototypes:
.................... _bif void setup_capture(unsigned int8 module, unsigned int16 mode);
.................... _bif unsigned int16 get_capture(unsigned int8 module);
.................... _bif unsigned int16 get_capture(unsigned int8 module, int1 wait);
.................... // Constants used for SETUP_CAPTURE() are:
.................... #define CAPTURE_OFF               0x0000  // Capture OFF
.................... #define CAPTURE_EE                0x0001  // Capture Every Edge
.................... #define CAPTURE_FE                0x0002  // Capture Falling Edge
.................... #define CAPTURE_RE                0x0003  // Capture Rising Edge
.................... #define CAPTURE_DIV_4             0x0004  // Capture Every 4th Rising Edge
.................... #define CAPTURE_DIV_16            0x0005  // Capture Every 16th Rising Edge
.................... #define CAPTURE_INTERRUPT_ONLY    0x0007  // Interrupt on Rising Edge when in Sleep or Idle
.................... 
.................... // The following defines can be ORed | with above to configure interrupts
.................... #define INTERRUPT_EVERY_CAPTURE   0x0000  // Interrupt on every capture event
.................... #define INTERRUPT_SECOND_CAPTURE  0x0020  // Interrupt on every second capture event
.................... #define INTERRUPT_THIRD_CAPTURE   0x0040  // Interrupt on every third capture event
.................... #define INTERRUPT_FOURTH_CAPTURE  0x0060  // Interrupt on every fourth capture event
.................... 
.................... // The following defines can be ORed | with above to select timer
.................... #define CAPTURE_TIMER2            0x0080  // On capture event Timer 2 is captured
.................... #define CAPTURE_TIMER3            0x0000  // On capture event Timer 3 is captured
.................... 
.................... // The following defines can be ORed | with above to select idle operation mode
.................... #define CAPTURE_HALT_IDLE         0x2000  // Capture module halts during idle mode
.................... #define CAPTURE_CONTINUE_IDLE     0x0000  // Capture module continues during idle mode
.................... 
.................... /////////////////////////////////////////////////////////// OUTPUT COMPARE
.................... // Functions: SETUP_COMPARE, SET_PWM_DUTY, SET_COMPARE_TIME
.................... // OC Prototypes:
.................... _bif void setup_compare(unsigned int8 module, unsigned int16 mode);
.................... _bif void set_pwm_duty(unsigned int8 module, unsigned int16 duty);
.................... _bif void set_compare_time(unsigned int8 module, unsigned int16 ocr);
.................... _bif void set_compare_time(unsigned int8 module, unsigned int16 ocr, unsigned int16 ocrs);
.................... // Constants used for SETUP_COMPARE() are:
.................... #define COMPARE_OFF               0x0000  // Compare OFF
.................... #define COMPARE_SET_ON_MATCH      0x0001  // Pin from low to high on match
.................... #define COMPARE_CLR_ON_MATCH      0x0002  // Pin from high to low on match
.................... #define COMPARE_TOGGLE            0x0003  // Pin will toggle on every match occurrence
.................... #define COMPARE_SINGLE_PULSE      0x0004  // Pin will generate single pulse on first match
.................... #define COMPARE_CONT_PULSE        0x0005  // Pin will pulse for every match
.................... #define COMPARE_PWM               0x0006  // Compare operates as PWM with fault pin disabled
.................... #define COMPARE_PWM_FAULT         0x0007  // Compare operates as PWM with fault pin enabled
.................... 
.................... // The following defines can be ORed | with above to select timer
.................... #define COMPARE_TIMER2            0x0000  // Timer 2 is the base timer
.................... #define COMPARE_TIMER3            0x0008  // Timer 3 is the base timer
.................... 
.................... // The following defines can be ORed | with above to select idle operation mode
.................... #define COMPARE_HALT_IDLE         0x2000  // Compare module halts during idle mode
.................... #define COMPARE_CONTINUE_IDLE     0x0000  // Compare module continues during idle mode
.................... 
.................... ////////////////////////////////////////////////////////////////// SPI
.................... // SPI Functions: SETUP_SPI, SPI_WRITE, SPI_READ, SPI_DATA_IN
.................... // SPI Prototypes:
.................... _bif void setup_spi(unsigned int16 mode);
.................... _bif void spi_write(unsigned int8 data);
.................... _bif void spi_write(int1 wait, unsigned int8 data);
.................... _bif void spi_write_16(unsigned int16 data);
.................... _bif void spi_write_16(int1 wait, unsigned int16 data);
.................... _bif unsigned int8 spi_read(void);
.................... _bif unsigned int8 spi_read(unsigned int8 data);
.................... _bif unsigned int16 spi_read_16(void);
.................... _bif unsigned int16 spi_read_16(unsigned int16 data);
.................... _bif int1 spi_data_in(void);
.................... _bif void setup_spi2(unsigned int16 mode);
.................... _bif void spi_write2(unsigned int8 data);
.................... _bif void spi_write2(int1 wait, unsigned int8 data);
.................... _bif void spi_write2_16(unsigned int16 data);
.................... _bif void spi_write2_16(int1 wait, unsigned int16 data);
.................... _bif unsigned int8 spi_read2(void);
.................... _bif unsigned int8 spi_read2(unsigned int8 data);
.................... _bif unsigned int16 spi_read2_16(void);
.................... _bif unsigned int16 spi_read2_16(unsigned int16 data);
.................... _bif int1 spi_data_in2(void);
.................... // Constants used in SETUP_SPI() are:
.................... //      (or (via |) together constants from each group)
.................... #define SPI_MASTER                 0x0020
.................... #define SPI_SLAVE                  0x0000
.................... 
.................... #define SPI_SCK_IDLE_HIGH          0x0040
.................... #define SPI_SCK_IDLE_LOW           0x0000
.................... 
.................... #define SPI_XMIT_L_TO_H            0x0100
.................... #define SPI_XMIT_H_TO_L            0x0000
.................... 
.................... #define SPI_MODE_16B               0x0400
.................... #define SPI_MODE_8B                0x0000
.................... 
.................... #define SPI_SAMPLE_AT_END          0x0200
.................... #define SPI_SAMPLE_AT_MIDDLE       0x0000
.................... 
.................... #define SPI_SS_ENABLED             0x0000
.................... #define SPI_SS_DISABLED            0x0080
.................... 
.................... //or (via |) one of the following when operating as MASTER
.................... #define SPI_CLK_DIV_1              0x001F
.................... #define SPI_CLK_DIV_2              0x001B
.................... #define SPI_CLK_DIV_3              0x0017
.................... #define SPI_CLK_DIV_4              0x001E
.................... #define SPI_CLK_DIV_5              0x000F
.................... #define SPI_CLK_DIV_6              0x000B
.................... #define SPI_CLK_DIV_7              0x0007
.................... #define SPI_CLK_DIV_8              0x0003
.................... #define SPI_CLK_DIV_12             0x0016
.................... #define SPI_CLK_DIV_16             0x001D
.................... #define SPI_CLK_DIV_20             0x000E
.................... #define SPI_CLK_DIV_24             0x000A
.................... #define SPI_CLK_DIV_28             0x0006
.................... #define SPI_CLK_DIV_32             0x0002
.................... #define SPI_CLK_DIV_48             0x0015
.................... #define SPI_CLK_DIV_64             0x001C
.................... #define SPI_CLK_DIV_80             0x000D
.................... #define SPI_CLK_DIV_96             0x0009
.................... #define SPI_CLK_DIV_112            0x0005
.................... #define SPI_CLK_DIV_128            0x0001
.................... #define SPI_CLK_DIV_192            0x0014
.................... #define SPI_CLK_DIV_256            0x0010
.................... #define SPI_CLK_DIV_320            0x000C
.................... #define SPI_CLK_DIV_384            0x0008
.................... #define SPI_CLK_DIV_448            0x0004
.................... #define SPI_CLK_DIV_512            0x0000
.................... 
.................... //The following defines are provided for compatibility
.................... #define SPI_L_TO_H         SPI_SCK_IDLE_LOW
.................... #define SPI_H_TO_L         SPI_SCK_IDLE_HIGH
.................... 
.................... ////////////////////////////////////////////////////////////////// ADC
.................... // ADC Functions: SETUP_ADC(), SETUP_ADC_PORTS()
.................... //                SET_ADC_CHANNEL(), READ_ADC()
.................... // ADC Prototypes:
.................... _bif void setup_adc(unsigned int32 mode);
.................... _bif void setup_adc_ports(unsigned int32 pins);
.................... _bif void setup_adc_ports(unsigned int32 pins, unsigned int16 reference);
.................... _bif void set_adc_channel(unsigned int8 channel);
.................... _bif void set_adc_channel(unsigned int8 channel, unsigned int8 neg_channel);
.................... _bif unsigned int16 read_adc(void);
.................... _bif unsigned int16 read_adc(unsigned int8 mode);
.................... _bif int1 adc_done(void);
.................... // Constants used for SETUP_ADC() are:
.................... // Clock is at ADCS<5:0> of ADCON3 Reg. (0x02A4)
.................... // Tad = (Tcy/2)*(ADCS<5:0>+1)
.................... #define ADC_OFF                 0x10000
.................... #define ADC_CLOCK                0x0000
.................... #define ADC_CLOCK_DIV_2          0x0001
.................... #define ADC_CLOCK_DIV_4          0x0003
.................... #define ADC_CLOCK_DIV_8          0x0007
.................... #define ADC_CLOCK_DIV_16         0x000F
.................... #define ADC_CLOCK_DIV_32         0x001F
.................... #define ADC_CLOCK_DIV_64         0x003F
.................... #define ADC_CLOCK_INTERNAL       0x8000     // Internal
.................... 
.................... // One of the following may be OR'ed in with the above using |
.................... // Auto-Sample Time bits
.................... #define ADC_TAD_MUL_0            0x1F00
.................... #define ADC_TAD_MUL_2            0x1D00
.................... #define ADC_TAD_MUL_4            0x1B00
.................... #define ADC_TAD_MUL_8            0x1700
.................... #define ADC_TAD_MUL_16           0x0F00
.................... #define ADC_TAD_MUL_31           0x0000
.................... 
.................... // Constants used in READ_ADC() are:
.................... #define ADC_START_AND_READ       0x07
.................... #define ADC_START_ONLY           0x01
.................... #define ADC_READ_ONLY            0x06
.................... 
.................... // Constants used in SET_ADC_CHANNEL() second parameter are:
.................... #define VSS                      0
.................... 
.................... // Constants used in SETUP_ADC_PORTS() are:
.................... // First argument:
.................... // OR together desired pins
.................... #define NO_ANALOGS      0           // None
.................... #define ALL_ANALOG      0xFFFFFFFF  // All
.................... #define sAN0      0x00000001 //| A0
.................... #define sAN1      0x00000002 //| A1
.................... #define sAN2      0x00000004 //| B0
.................... #define sAN3      0x00000008 //| B1
.................... #define sAN4      0x00000010 //| B2
.................... #define sAN5      0x00000020 //| B3
.................... #define sAN6      0x00000040 //| C0
.................... #define sAN7      0x00000080 //| C1
.................... #define sAN8      0x00000100 //| C2
.................... 
.................... // Optional Second argument:
.................... #define VSS_VDD            0x0000 // Range 0-Vdd
.................... #define VREF_VREF          0x6000 // Range VrefL-VrefH
.................... #define VREF_VDD           0x4000 // Range VrefL-Vdd
.................... #define VSS_VREF           0x2000 // Range 0-VrefH
.................... 
.................... ////////////////////////////////////////////////////////////////// COMP
.................... // Comparator Functions: setup_comparator()
.................... // Comparator Variables: C1OUT, C2OUT
.................... // Comparator Prototypes:
.................... _bif void setup_comparator(unsigned int16 mode);
.................... // Constants used in setup_comparator() are:
.................... #define NC_NC_NC_NC      0
.................... #define B2_B3_NC_NC      0x401
.................... #define B2_VR_NC_NC      0x400
.................... #define B3_VR_NC_NC      0x402
.................... #define NC_NC_B0_B1      0x804
.................... #define NC_NC_B0_VR      0x800
.................... #define NC_NC_B1_VR      0x808
.................... #define B2_B3_B0_B1      B2_B3_NC_NC | NC_NC_B0_B1
.................... #define B2_VR_B0_VR      B2_VR_NC_NC | NC_NC_B0_VR
.................... #define B3_VR_B1_VR      B3_VR_NC_NC | NC_NC_B1_VR
.................... 
.................... #define C1_INVERT     0x10
.................... #define C2_INVERT     0x20
.................... #define C1_OUTPUT     0x100
.................... #define C2_OUTPUT     0x200
.................... 
.................... #bit C1OUT = getenv("SFR:CMCON").6
.................... #bit C2OUT = getenv("SFR:CMCON").7
.................... 
.................... ////////////////////////////////////////////////////////////////// VREF
.................... // VREF Prototypes:
.................... _bif void setup_vref(unsigned int16 mode);
.................... // Constants used in setup_vref() are:
.................... #define VREF_DISABLED  0x0000
.................... #define VREF_VSS_VDD   0x0080
.................... #define VREF_ANALOG    0x0090
.................... // One of the following maybe OR'ed in with the above using |
.................... #define VREF_HIGH      0x0080
.................... #define VREF_LOW       0x00A0
.................... // The following maybe OR'ed in with the above using |
.................... #define VREF_OUTPUT    0x0040
.................... // Or (with |) the above with a number 0-15
.................... 
.................... ////////////////////////////////////////////////////////////////// PMP
.................... // PMP Functions: setup_pmp(), pmp_address(), psp_read(), pmp_read(),
.................... // psp_write(), pmp_write(), psp_output_full(),psp_input_full(),
.................... // psp_overflow(), pmp_output_full(), pmp_input_full(),
.................... // pmp_overflow()
.................... // PMP Prototypes:
.................... _bif void setup_pmp(unsigned int32 mode, unsigned int16 address_mask);
.................... _bif void pmp_address(unsigned int16 address);
.................... _bif unsigned int8 pmp_read(void);
.................... _bif void pmp_write(unsigned int8 data);
.................... _bif int1 pmp_output_full(void);
.................... _bif int1 pmp_input_full(void);
.................... _bif int1 pmp_overflow(void);
.................... _bif void setup_psp(unsigned int32 mode, unsigned int16 address_mask);
.................... _bif unsigned int8 psp_read(void);
.................... _bif unsigned int8 psp_read(unsigned int16 address);
.................... _bif void psp_write(unsigned int8 data);
.................... _bif void psp_write(unsigned int8 data, unsigned int16 address);
.................... _bif int1 psp_output_full(void);
.................... _bif int1 psp_input_full(void);
.................... _bif int1 psp_overflow(void);
.................... // Constants used in SETUP_PMP() and SETUP_PSP() are:
.................... #define PAR_ENABLE                0x8000
.................... #define PAR_DISABLE               0x0000    // Module enable/disable options
.................... #define PAR_STOP_IN_IDLE          0x2000
.................... #define PAR_CONTINUE_IN_IDLE      0x0000
.................... #define PAR_ADDR_NOT_MULTIPLEXED  0x0000    // Address multiplexing options
.................... #define PAR_LOW_ADDR_MULTIPLEXED  0x0800    // Address multiplexing options
.................... #define PAR_FULL_ADDR_MULTIPLEXED 0x1000    // Address multiplexing options
.................... #define PAR_PTBEEN_ENABLE         0x0400  // Byte Enable Port Enable bit
.................... #define PAR_PTWREN_ENABLE         0x0200  // Write Enable Strobe bit
.................... #define PAR_PTRDEN_ENABLE         0x0100  // Read/Write Strobe Port bit
.................... #define PAR_ALP_ACTIVE_HIGH       0x0020 // Address latch polarity high
.................... #define PAR_BEP_ACTIVE_HIGH       0x0004 // Byte Enable Polarity
.................... #define PAR_WRSP_ACTIVE_HIGH      0x0002 // Write strobe Polarity bit
.................... #define PAR_RDSP_ACTIVE_HIGH      0x0001 // Read strobe Polarity bit
.................... #define PAR_CS_XX                 0x0000   // Chip select pins used for address
.................... #define PAR_CS_X1                 0x0008   // Chip select pin 1 used, active high
.................... #define PAR_CS_X0                 0x0000   // Chip select pin 1 used, active low
.................... #define PAR_CS_1X                 0x0050   // Chip select pin 2 used, active high
.................... #define PAR_CS_0X                 0x0040   // Chip select pin 2 used, active low
.................... #define PAR_CS_00                 0x0080   // Chip select pins 1,2 used, active low
.................... #define PAR_CS_11                 0x0098   // Chip select pins 1,2 used, active high
.................... #define PAR_CS_10                 0x0090   // Chip select pins 1,2 used, 1 is active low, 2 is high
.................... #define PAR_CS_01                 0x0088   // Chip select pins 1,2 used, 1 is active high, 2 is low
.................... #define PAR_INTR_ON_RW                0x20000000  // Interrupt on read write
.................... #define PAR_NO_INTR_STALL_ACTIVATED   0x40000000  // No interrupt, processor stall activated
.................... #define PAR_INTR_ON_3_RW_BUF          0x60000000 // Interrupt on write to Buffer 3 or read from Buffer 3
.................... #define PAR_PSP_AUTO_INC              0x18000000 // Read write buffers auto increment
.................... #define PAR_DEC_ADDR                  0x10000000 // Increment the address
.................... #define PAR_INC_ADDR                  0x08000000 // Decrement the address
.................... #define PAR_MASTER_MODE_1             0x03000000  // Master mode 1
.................... #define PAR_MASTER_MODE_2             0x02000000  // Master mode 2
.................... #define PAR_WAITB1                    0x00000000 // 1 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB2                    0x00400000 // 2 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB3                    0x00800000 // 3 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB4                    0x00C00000 // 4 Tcy Wait state for data setup R/W
.................... #define PAR_WAITM0                    0x00000000 // 0 wait state for Read to byte
.................... #define PAR_WAITM1                    0x00040000 // 1 Tcy wait state for Read to byte
.................... #define PAR_WAITM2                    0x00080000 // 2 Tcy wait state for Read to byte
.................... #define PAR_WAITM3                    0x000C0000 // 3 Tcy wait state for Read to byte
.................... #define PAR_WAITM15                   0x003C0000 // 15 wait states
.................... #define PAR_WAITE1                    0x00000000  // 1 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE2                    0x00010000 // 2 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE3                    0x00020000 // 3 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE4                    0x00030000 // 4 Tcy Wait for data hold after strobe
.................... 
.................... ////////////////////////////////////////////////////////////////// CRC
.................... // CRC Functions: setup_crc(), crc_init(), crc_calc(), crc_calc8()
.................... // CRC Prototypes:
.................... _bif void setup_crc(unsigned int8 poly_terms, ...);
.................... _bif void crc_init(unsigned int16 value);
.................... _bif unsigned int16 crc_calc(unsigned int16 data);
.................... _bif unsigned int16 crc_calc(unsigned int16 *ptr, unsigned int16 count);
.................... _bif unsigned int8 crc_calc8(unsigned int8 data);
.................... _bif unsigned int8 crc_calc8(unsigned int8 *ptr, unsigned int16 count);
.................... 
.................... ////////////////////////////////////////////////////////////////// RTC
.................... // RTC Functions: setup_rtc(), setup_rtc_alarm(), rtc_read(),
.................... //                rtc_write(), rtc_alarm_read(), rtc_alarm_write()
.................... // Structure used in read and write functions (pass pointer):
.................... typedef struct {
....................    unsigned int8 tm_year;
....................    unsigned int8 tm_temp;  // Not used by built in functions, place holder only do not use
....................    unsigned int8 tm_mday;
....................    unsigned int8 tm_mon;
....................    unsigned int8 tm_hour;
....................    unsigned int8 tm_wday;
....................    unsigned int8 tm_sec;
....................    unsigned int8 tm_min;
....................    unsigned int8 tm_isdst; // Not used by built in functions
.................... } rtc_time_t;
.................... // RTC Prototypes:
.................... _bif void setup_rtc(unsigned int16 mode, unsigned int8 calibration);
.................... _bif void setup_rtc_alarm(unsigned int16 mode, unsigned int16 mask, unsigned int8 repeat);
.................... _bif void rtc_read(rtc_time_t *time);
.................... _bif void rtc_write(rtc_time_t *time);
.................... _bif void rtc_alarm_read(rtc_time_t *time);
.................... _bif void rtc_alarm_write(rtc_time_t *time);
.................... // Constants used in setup_rtc() are:  // Second param is calibration
.................... #define RTC_ENABLE           0x8000
.................... #define RTC_DISABLE          0
.................... #define RTC_OUTPUT_SECONDS   0x20400
.................... #define RTC_OUTPUT_ALARM     0x00400
.................... //
.................... // Constants used in setup_rtc_alarm() first param are:
.................... #define RTC_ALARM_ENABLE     0x8000
.................... #define RTC_ALARM_DISABLE    0
.................... #define RTC_CHIME_ENABLE     0x4000
.................... #define RTC_CHIME_DISABLE    0
.................... // Constants used in setup_rtc_alarm() second param are:  // Third param is repeat#
.................... #define RTC_ALARM_HALFSECOND 0x0000
.................... #define RTC_ALARM_SECOND     0x0400
.................... #define RTC_ALARM_10_SECONDS 0x0800
.................... #define RTC_ALARM_MINUTE     0x0C00
.................... #define RTC_ALARM_10_MINUTES 0x1000
.................... #define RTC_ALARM_HOUR       0x1400
.................... #define RTC_ALARM_DAY        0x1800
.................... #define RTC_ALARM_WEEK       0x1C00
.................... #define RTC_ALARM_MONTH      0x2000
.................... #define RTC_ALARM_YEAR       0x2400
.................... 
.................... ////////////////////////////////////////////////////////////////// QEI
.................... // QEI Functions: setup_qei(), qei_set_count(), qei_get_count(),
.................... //                qei_status()
.................... // QEI Prototypes:
.................... _bif void setup_qei(unsigned int16 mode, unsigned int16 filter, unsigned int16 maxcount);
.................... _bif void setup_qei(unsigned int8 unit, unsigned int16 mode, unsigned int16 filter, unsigned int16 maxcount);
.................... _bif void qei_set_count(unsigned int16 count);
.................... _bif void qei_set_count(unsigned int8 unit, unsigned int16 count);
.................... _bif unsigned int16 qei_get_count(void);
.................... _bif unsigned int16 qei_get_count(unsigned int8 unit);
.................... _bif unsigned int16 qei_status(void);
.................... _bif unsigned int16 qei_status(unsigned int8 unit);
.................... // Constants used in setup_qei() first param are:
.................... #define QEI_DISABLED        0
.................... #define QEI_MODE_X2         0x0400
.................... #define QEI_MODE_X4         0x0600
.................... #define QEI_MODE_TIMER      0x0100
.................... #define QEI_STOP_WHEN_IDLE  0x2000
.................... #define QEI_SWAP_AB         0x0080
.................... #define QEI_OUTPUT_ENABLE   0x0040
.................... #define QEI_RESET_WHEN_MAXCOUNT  0x0100
.................... #define QEI_RESET_WHEN_IDX_PULSE 0x0004
.................... #define QEI_TIMER_GATED      0x0020
.................... #define QEI_TIMER_INTERNAL   0x0000
.................... #define QEI_TIMER_EXTERNAL   0x0002
.................... #define QEI_TIMER_DIV_BY_1   0x0000
.................... #define QEI_TIMER_DIV_BY_8   0x0008
.................... #define QEI_TIMER_DIV_BY_64  0x0010
.................... #define QEI_TIMER_DIV_BY_256 0x0018
.................... // Constants used in setup_qei() second param are:   // Third param is MAXCOUNT
.................... #define QEI_FILTER_DIV_1     0x0000
.................... #define QEI_FILTER_DIV_2     0x0010
.................... #define QEI_FILTER_DIV_4     0x0020
.................... #define QEI_FILTER_DIV_16    0x0030
.................... #define QEI_FILTER_DIV_32    0x0040
.................... #define QEI_FILTER_DIV_64    0x0050
.................... #define QEI_FILTER_DIV_128   0x0060
.................... #define QEI_FILTER_DIV_256   0x0070
.................... #define QEI_FILTER_OUTPUT    0x0080
.................... #define QEI_NO_ERROR_INTS    0x0100
.................... #define QEI_IDX_WHEN_A0      0x0000  // for 2X mode
.................... #define QEI_IDX_WHEN_A1      0x0200  // for 2X mode
.................... #define QEI_IDX_WHEN_B0      0x0400  // for 2X mode
.................... #define QEI_IDX_WHEN_B1      0x0600  // for 2X mode
.................... #define QEI_IDX_WHEN_A0_B0   0x0000  // for 4X mode
.................... #define QEI_IDX_WHEN_A1_B0   0x0200  // for 4X mode
.................... #define QEI_IDX_WHEN_A0_B1   0x0400  // for 4X mode
.................... #define QEI_IDX_WHEN_A1_B1   0x0600  // for 4X mode
.................... // Constants returned from qei_status() are:
.................... #define QEI_POS_ERROR        0x8000
.................... #define QEI_FORWARD          0x0800
.................... #define QEI_INDEX_PIN        0x1000
.................... 
.................... ////////////////////////////////////////////////////////////////// MOTOR PWM
.................... // MPWM Functions: setup_motor_pwm(), set_motor_unit(),
.................... //                 set_motor_pwm_duty(), set_motor_pwm_event(),
.................... //                 get_motor_pwm_count()
.................... // MPWM Prototypes:
.................... _bif void setup_motor_pwm(unsigned int8 pwm, unsigned int32 mode, unsigned int32 timebase);
.................... _bif void setup_motor_pwm(unsigned int8 pwm, unsigned int32 mode, unsigned int8 prescale, unsigned int8 postscale, unsigned int16 period);
.................... _bif void set_motor_unit(unsigned int8 pwm, unsigned int8 pin_pair, unsigned int16 mode, unsigned int8 active_deadtime, unsigned int8 inactive_deadtime);
.................... _bif void set_motor_pwm_duty(unsigned int8 pwm, unsigned int8 pin_pair, unsigned int16 duty);
.................... _bif void set_motor_pmw_event(unsigned int8, signed int16 time);
.................... _bif unsigned int16 get_motor_pwm_count(unsigned int8 pwm);
.................... // Constants used in setup_motor_pwm() second param are (first param is unit number 1,2...):
.................... #define MPWM_DISABLED          0
.................... #define MPWM_FREE_RUN          0x8000
.................... #define MPWM_SINGLE_PULSE      0x8001
.................... #define MPWM_UP_DOWN           0x8002
.................... #define MPWM_UP_DOWN_WITH_INTS 0x8003
.................... // OR in any of the following:
.................... #define MPWM_HALT_WHEN_IDLE            0x2000
.................... #define MPWM_DUTY_UPDATES_IMMEADIATE  0x40000
.................... #define MPWM_SYNC_OVERRIDES           0x20000
.................... #define MPWM_DISABLE_UPDATES          0x10000
.................... #define MPWM_LATCH_FAULTS            0x100000
.................... 
.................... // Constants used in set_motor_unit() third param are:  (first param is unit number 1,2... and second param is pwm pin pair 1,2,3 or 4)
.................... #define MPWM_INDEPENDENT     0x0001
.................... #define MPWM_ENABLE          0x0006  // both H and L
.................... #define MPWM_ENABLE_H        0x0004
.................... #define MPWM_ENABLE_L        0x0002
.................... 
.................... #define MPWM_FORCE_L_0       0x0010
.................... #define MPWM_FORCE_L_1       0x0050
.................... #define MPWM_FORCE_H_0       0x0020
.................... #define MPWM_FORCE_H_1       0x00A0
.................... 
.................... #define MPWM_FAULTA_LA_HA     0x0700
.................... #define MPWM_FAULTA_LA_HI     0x0500
.................... #define MPWM_FAULTA_LI_HA     0x0600
.................... #define MPWM_FAULTA_LI_HI     0x0400
.................... #define MPWM_FAULTB_LA_HA     0x7000
.................... #define MPWM_FAULTB_LA_HI     0x5000
.................... #define MPWM_FAULTB_LI_HA     0x6000
.................... #define MPWM_FAULTB_LI_HI     0x4000
.................... #define MPWM_FAULT_NO_CHANGE 0x0000
.................... 
.................... ////////////////////////////////////////////////////////////////// DCI
.................... // DCI Functions: setup_dci(), dci_start(), dci_read(), dci_write(),
.................... //                dci_data_received(), dci_transmit_ready()
.................... // DCI Prototypes:
.................... _bif void setup_dci(unsigned int16 mode, unsigned int16 size, unsigned int16 receive_slot, unsigned int16 transmit_slot, unsigned int16 sample_rate);
.................... _bif void dci_start(void);
.................... _bif signed int16 dci_read(void);
.................... _bif void dci_write(signed int16);
.................... _bif int1 dci_data_received(void);
.................... _bif int1 dci_transmit_ready(void);
.................... // Constants used in setup_dci() first param are:
.................... #define MULTICHANNEL_MODE  0x0000
.................... #define I2S_MODE           0x0001
.................... #define AC97_16BIT_MODE    0x0002
.................... #define AC97_20BIT_MODE    0x0003
.................... 
.................... #define JUSTIFY_DATA       0x0020 //Start data transmission on the same clock cycle as COFS pulses (multichannel)
.................... #define MULTI_DEVICE_BUS   0x0040 //Tri-states the CSDO pin during unused time slots, normally drives '0'
.................... 
.................... #define UNDERFLOW_LAST     0x0080 //Transmits the last written value to the dci when data underflow occurs. Default is undeflow silence.
.................... #define UNDERFLOW_SILENCE  0x0000 //Transmit '0's on data undeflow. This will cause a clicking noise if you are underflowing data while outputing to a codec.
.................... 
.................... #define DCI_SLAVE          0x0100 //Default is master
.................... #define DCI_MASTER         0x0000
.................... 
.................... #define SAMPLE_FALLING_EDGE 0x0000 //Default is Sample on the rising edge of the clock
.................... #define SAMPLE_RISING_EDGE 0x0200
.................... 
.................... #define DCI_CLOCK_INPUT    0x0400 //SCLK is an input (supplied by codec or external source)
.................... #define DCI_CLOCK_OUTPUT   0x0000 //Default is clock output
.................... 
.................... #define ENABLE_LOOPBACK    0x0800 //Connect the CSDI/CSDO internally; loops all of the sound back onto the bus
.................... 
.................... #define CODEC_MULTICHANNEL  0x0000  //enables multichannel (generic) codec support
.................... #define CODEC_I2S           0x0001  //enables the I2S protocol
.................... #define CODEC_AC16          0x0002  //enables the AC-16 protocol, setupCodecTransmission has no effect
.................... #define CODEC_AC20          0x0003  //enables the AC-20 protocol, setupCodecTransmission has no effect
.................... 
.................... #define BUS_MASTER          0x0000  //designates this device as the bus master
.................... #define BUS_SLAVE           0x0300  //designates this device as a slave on a bus controlled by another codec
.................... 
.................... #define TRISTATE_BUS        0x0040        //when in master mode, the module will be in high impedance
....................                                     //during disabled frames (default drives 0's onto bus)
.................... #define SYNC_COFS_DATA_PULSE 0x0020 //signifies that data starts transmitting on the same SCK pulse as the edge of the COFS pulse
....................                                     //(default data starts on the clock after the rising edge of COFS
.................... /* Determines when a sample is taken */
.................... #define SAMPLE_RISING        0x0200 //sample data on the rising edge of the clock
.................... #define SAMPLE_FALLING       0x0000 //sample data on the falling edge of the clock
.................... 
.................... // Constants used in setup_dci() second param are:
.................... #define DCI_4BIT_WORD      0x0003
.................... #define DCI_5BIT_WORD      0x0004
.................... #define DCI_6BIT_WORD      0x0005
.................... #define DCI_7BIT_WORD      0x0006
.................... #define DCI_8BIT_WORD      0x0007
.................... #define DCI_9BIT_WORD      0x0008
.................... #define DCI_10BIT_WORD     0x0009
.................... #define DCI_11BIT_WORD     0x000A
.................... #define DCI_12BIT_WORD     0x000B
.................... #define DCI_13BIT_WORD     0x000C
.................... #define DCI_14BIT_WORD     0x000D
.................... #define DCI_15BIT_WORD     0x000E
.................... #define DCI_16BIT_WORD     0x000F
.................... 
.................... #define DCI_1WORD_FRAME    0x0000
.................... #define DCI_2WORD_FRAME    0x0010 << 1
.................... #define DCI_3WORD_FRAME    0x0020 << 1
.................... #define DCI_4WORD_FRAME    0x0030 << 1
.................... #define DCI_5WORD_FRAME    0x0040 << 1
.................... #define DCI_6WORD_FRAME    0x0050 << 1
.................... #define DCI_7WORD_FRAME    0x0060 << 1
.................... #define DCI_8WORD_FRAME    0x0070 << 1
.................... #define DCI_9WORD_FRAME    0x0080 << 1
.................... #define DCI_10WORD_FRAME   0x0090 << 1
.................... #define DCI_11WORD_FRAME   0x00A0 << 1
.................... #define DCI_12WORD_FRAME   0x00B0 << 1
.................... #define DCI_13WORD_FRAME   0x00C0 << 1
.................... #define DCI_14WORD_FRAME   0x00D0 << 1
.................... #define DCI_15WORD_FRAME   0x00E0 << 1
.................... #define DCI_16WORD_FRAME   0x00F0 << 1
.................... 
.................... #define DCI_1WORD_INTERRUPT 0x0000
.................... #define DCI_2WORD_INTERRUPT 0x0400
.................... #define DCI_3WORD_INTERRUPT 0x0800
.................... #define DCI_4WORD_INTERRUPT 0x0C00
.................... 
.................... // Constants used in setup_dci() third param are:
.................... #define RECEIVE_NONE    0x0000
.................... #define RECEIVE_ALL     0xFFFF
.................... #define RECEIVE_SLOT0   0x0001
.................... #define RECEIVE_SLOT1   0x0002
.................... #define RECEIVE_SLOT2   0x0004
.................... #define RECEIVE_SLOT3   0x0008
.................... #define RECEIVE_SLOT4   0x0010
.................... #define RECEIVE_SLOT5   0x0020
.................... #define RECEIVE_SLOT6   0x0040
.................... #define RECEIVE_SLOT7   0x0080
.................... #define RECEIVE_SLOT8   0x0100
.................... #define RECEIVE_SLOT9   0x0200
.................... #define RECEIVE_SLOT10  0x0400
.................... #define RECEIVE_SLOT11  0x0800
.................... #define RECEIVE_SLOT12  0x1000
.................... #define RECEIVE_SLOT13  0x2000
.................... #define RECEIVE_SLOT14  0x4000
.................... #define RECEIVE_SLOT15  0x8000
.................... 
.................... // Constants used in setup_dci() forth param are:
.................... #define TRANSMIT_NONE   0x0000
.................... #define TRANSMIT_ALL    0xFFFF
.................... #define TRANSMIT_SLOT0  0x0001
.................... #define TRANSMIT_SLOT1  0x0002
.................... #define TRANSMIT_SLOT2  0x0004
.................... #define TRANSMIT_SLOT3  0x0008
.................... #define TRANSMIT_SLOT4  0x0010
.................... #define TRANSMIT_SLOT5  0x0020
.................... #define TRANSMIT_SLOT6  0x0040
.................... #define TRANSMIT_SLOT7  0x0080
.................... #define TRANSMIT_SLOT8  0x0100
.................... #define TRANSMIT_SLOT9  0x0200
.................... #define TRANSMIT_SLOT10 0x0400
.................... #define TRANSMIT_SLOT11 0x0800
.................... #define TRANSMIT_SLOT12 0x1000
.................... #define TRANSMIT_SLOT13 0x2000
.................... #define TRANSMIT_SLOT14 0x4000
.................... #define TRANSMIT_SLOT15 0x8000
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////// DMA
.................... // DMA Functions: setup_dma(), dma_start(), dma_status()
.................... // DMA Prototypes:
.................... _bif void setup_dma(unsigned int8 channel, unsigned int32 pheripheral, unsigned int8 mode);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 count);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 addressb);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 addressb, unsigned int16 count);
.................... _bif unsigned int8 dma_status(unsigned int8 channel);
.................... // Constants used in setup_dma() second param are:
.................... #define DMA_IN_SPI1      (0x0A0000|getenv("sfr:SPI1BUF"))
.................... #define DMA_OUT_SPI1     (0x8A0000|getenv("sfr:SPI1BUF"))
.................... #define DMA_IN_SPI2      (0x210000|getenv("sfr:SPI2BUF"))
.................... #define DMA_OUT_SPI2     (0xA10000|getenv("sfr:SPI2BUF"))
.................... #define DMA_IN_UART1     (0x0B0000|getenv("sfr:U1RXREG"))
.................... #define DMA_OUT_UART1    (0x8C0000|getenv("sfr:U1TXREG"))
.................... #define DMA_IN_UART2     (0x1E0000|getenv("sfr:U2RXREG"))
.................... #define DMA_OUT_UART2    (0x9F0000|getenv("sfr:U2TXREG"))
.................... #define DMA_IN_ADC1      (0x0D0000|getenv("sfr:ADC1BUF0"))
.................... ////////////////////////////////////////////////////////////////// DAC
.................... // Digital to Analog Functions: SETUP_DAC(), DAC_WRITE()
.................... // DAC Prototypes:
.................... _bif void setup_dac(unsigned int32 mode);
.................... _bif void setup_dac(unsigned int32 mode, unsigned int8 divisor);
.................... _bif void dac_write(unsigned int8 channel, unsigned value);
.................... // Constants used in SETUP_DAC() are:
.................... #define DAC_OFF  0
.................... #define DAC_RIGHT_ON   0x00808000
.................... #define DAC_LEFT_ON    0x80008000
.................... #define DAC_RIGHT_MIDPOINT 0x00A08000
.................... #define DAC_LEFT_MIDPOINT  0xA0008000
.................... #define DAC_SIGNED   0x100
.................... #define DAC_SLEEP_ON 0x1000
.................... #define DAC_IDLE_OFF 0x2000
.................... // Constants used as the first param in DAC_WRITE() are:
.................... #define DAC_DEFAULT  0
.................... #define DAC_RIGHT    1
.................... #define DAC_LEFT     2
.................... 
.................... #define DMA_IN_ECAN1     (0x220000|getenv("sfr:C1RXD"))
.................... #define DMA_OUT_ECAN1    (0xC60000|getenv("sfr:C1TXD"))
.................... #define DMA_INT0         0x000000 // or in direction and perif address
.................... #define DMA_IC1          0x010000 // or in direction and perif address
.................... #define DMA_IN_IC1       (0x010000|getenv("sfr:IC1BUF"))
.................... #define DMA_IC2          0x050000 // or in direction and perif address
.................... #define DMA_IN_IC2       (0x050000|getenv("sfr:IC2BUF"))
.................... #define DMA_OC1          0x020000 // or in direction and perif address
.................... #define DMA_OC2          0x060000 // or in direction and perif address
.................... #define DMA_TIMER2       0x070000 // or in direction and perif address
.................... #define DMA_TIMER3       0x080000 // or in direction and perif address
.................... #define DMA_OUT_DCI      (0xBC0000|getenv("sfr:TXBUF0"))
.................... #define DMA_IN_DCI       (0x3C0000|getenv("sfr:RXBUF0"))
.................... #define DMA_OUT_DACR     (0xCE0000|getenv("sfr:DAC1RDAT"))
.................... #define DMA_OUT_DACL     (0xCF0000|getenv("sfr:DAC1LDAT"))
.................... #define DMA_IN          0x00
.................... #define DMA_OUT         0x800000
.................... // Constants used in setup_dma() third param are:
.................... #define DMA_BYTE        0x40
.................... #define DMA_WORD        0x00  // default
.................... #define DMA_HALF_INT    0x10  // interrupt when half full
.................... #define DMA_WRITE_NULL  0x08
.................... // Constants used in dma_start() second param are:
.................... #define DMA_CONTINOUS   0x00
.................... #define DMA_ONE_SHOT    0x01
.................... #define DMA_PING_PONG   0x02
.................... #define DMA_NO_INC      0x10
.................... #define DMA_PERIF_ADDR  0x20 // Device supplies address
.................... #define DMA_FORCE_NOW  0x100
.................... // Constants returned from dma_status() are:
.................... #define DMA_IN_ERROR    0x01
.................... #define DMA_OUT_ERROR   0x02
.................... #define DMA_B_SELECT    0x04
.................... 
.................... ////////////////////////////////////////////////////////////////// BIF
.................... // Built In Functions Prototypes
.................... //
.................... // Math Prototypes:
.................... _bif signed int8 abs(signed int8 x);
.................... _bif signed int16 abs(signed int16 x);
.................... _bif signed int32 abs(signed int32 x);
.................... _bif float32 abs(float32 x);
.................... _bif unsigned int16 _mul(unsigned int8, unsigned int8);
.................... _bif signed int16 _mul(signed int8, signed int8);
.................... _bif unsigned int32 _mul(unsigned int16, unsigned int16);
.................... _bif signed int32 _mul(signed int16, signed int16);
.................... _bif signed int48 abs(signed int48 x);
.................... _bif signed int64 abs(signed int64 x);
.................... _bif float48 abs(float48 x);
.................... _bif float64 abs(float64 x);
.................... _bif unsigned int64 _mul(unsigned int32, unsigned int32);
.................... _bif signed int64 _mul(signed int32, signed int32);
.................... _bif unsigned int64 _mul(unsigned int48, unsigned int48);
.................... _bif signed int64 _mul(signed int48, signed int48);
.................... 
.................... // Memory Manipulation Prototypes:
.................... _bif void strcpy(char* dest, char* src);
.................... _bif void memset(unsigned int8* destination, unsigned int8 value, unsigned int16 num);
.................... _bif void memcpy(unsigned int8* destination, unsigned int8* source, unsigned int16 num);
.................... 
.................... // Data Manipulators Prototypes:
.................... _bif int1 shift_left(unsigned int8* address, unsigned int8 bytes, int1 value);
.................... _bif int1 shift_right(unsigned int8* address, unsigned int8 bytes, int1 value);
.................... _bif void rotate_left(unsigned int8* address, unsigned int8 bytes);
.................... _bif void rotate_right(unsigned int8* address, unsigned int8 bytes);
.................... _bif void swap(unsigned int8 value);
.................... _bif unsigned int8 make8(unsigned int16 var, unsigned int8 offset);
.................... _bif unsigned int8 make8(unsigned int32 var, unsigned int8 offset);
.................... _bif unsigned int16 make16(unsigned int8 varhigh, unsigned int8 varlow);
.................... _bif unsigned int32 make32(unsigned int16 var1);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int16 var2);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int8 var2);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int8 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int8 var3, unsigned int8 var4);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int16 var2);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int16 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int16 var3);
.................... _bif void bit_set(unsigned int8 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int16 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int32 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int8 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int16 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int32 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int8 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int16 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int32 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int48 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int64 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int48 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int64 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int48 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int64 var, unsigned int8 bit);
.................... _bif unsigned int8 bit_first(int1 value, unsigned int16 var);
.................... _bif unsigned int8 bit_last(int16 var);
.................... _bif unsigned int8 bit_last(int1 value, int16 var);
.................... 
.................... // #use delay() Prototypes:
.................... _bif void delay_cycles(unsigned int16 count);
.................... _bif void delay_ms(unsigned int16 time);
.................... _bif void delay_us(unsigned int16 time);
.................... 
.................... // #use rs232() Prototypes:
.................... _bif void putchar(char cdata);
.................... _bif void putchar(char cdata, unsigned int8 stream);
.................... _bif void puts(char* string);
.................... _bif void puts(char* string, unsigned int8 stream);
.................... _bif char getch(void);
.................... _bif char getch(unsigned int8 stream);
.................... _bif void gets(char* string);
.................... _bif void gets(char* string, unsigned int8 stream);
.................... _bif int1 kbhit(void);
.................... _bif int1 kbhit(unsigned int8 stream);
.................... _bif void printf(char* string, ...);
.................... _bif void fprintf(unsigned int8 stream, char* string, ...);
.................... _bif void putc_send(void);
.................... _bif void fputc_send(unsigned int8 stream);
.................... _bif int1 rcv_buffer_full(void);
.................... _bif int1 rcv_buffer_full(unsigned int8 stream);
.................... _bif unsigned int16 rcv_buffer_bytes(void);
.................... _bif unsigned int16 rcv_buffer_bytes(unsigned int8 stream);
.................... _bif int1 tx_buffer_full(void);
.................... _bif int1 tx_buffer_full(unsigned int8 stream);
.................... _bif unsigned int16 tx_buffer_bytes(void);
.................... _bif unsigned int16 tx_buffer_bytes(unsigned int8 stream);
.................... 
.................... // #use i2c() Prototypes:
.................... _bif unsigned int8 i2c_read(void);
.................... _bif unsigned int8 i2c_read(unsigned int8 stream);
.................... _bif unsigned int8 i2c_read(unsigned int8 stream, int1 ack);
.................... _bif int1 i2c_write(unsigned int8 data);
.................... _bif int1 i2c_write(unsigned int8 stream, unsigned int8 data);
.................... _bif void i2c_start(void);
.................... _bif void i2c_start(unsigned int8 stream);
.................... _bif void i2c_start(unsigned int8 stream, unsigned int8 restart);
.................... _bif void i2c_stop(void);
.................... _bif void i2c_stop(unsigned int8 stream);
.................... _bif int8 i2c_isr_state(void);
.................... _bif void i2c_slaveaddr(unsigned int8 addr);
.................... _bif void i2c_slaveaddr(unsigned int8 stream, unsigned int8 addr);
.................... _bif int1 i2c_poll(void);
.................... _bif int1 i2c_poll(unsigned int8 stream);
.................... _bif void i2c_init(unsigned int32 baud);
.................... _bif void i2c_init(unsigned int8 stream, unsigned int32 baud);
.................... 
.................... // #use spi() Prototypes:
.................... _bif unsigned int8 spi_xfer(void);
.................... _bif unsigned int16 spi_xfer(void);
.................... _bif unsigned int32 spi_xfer(void);
.................... _bif unsigned int8 spi_xfer(unsigned int8 data);
.................... _bif unsigned int16 spi_xfer(unsigned int16 data);
.................... _bif unsigned int32 spi_xfer(unsigned int32 data);
.................... _bif unsigned int8 spi_xfer(unsigned int8 stream, unsigned int8 data);
.................... _bif unsigned int16 spi_xfer(unsigned int8 stream, unsigned int16 data);
.................... _bif unsigned int32 spi_xfer(unsigned int8 stream, unsigned int32 data);
.................... _bif unsigned int8 spi_xfer(unsigned int8 stream, unsigned int8 data, unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer(unsigned int8 stream, unsigned int16 data, unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer(unsigned int8 stream, unsigned int32 data, unsigned int8 bits);
.................... _bif void spi_init(unsigned int32 baud);
.................... _bif void spi_init(unsigned int8 stream, unsigned int32 baud);
.................... _bif void spi_speed(unsigned int32 baud);
.................... _bif void spi_speed(unsigned int8 stream, unsigned int32 baud);
.................... _bif void spi_speed(unsigned int8 stream, unsigned int32 baud, unsigned int32 clock);
.................... _bif void spi_prewrite(unsigned int8 data);
.................... _bif void spi_prewrite(unsigned int16 data);
.................... _bif void spi_prewrite(unsigned int32 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int8 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int16 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int32 data);
.................... _bif unsigned int8 spi_xfer_in(void);
.................... _bif unsigned int16 spi_xfer_in(void);
.................... _bif unsigned int32 spi_xfer_in(void);
.................... _bif unsigned int8 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int8 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... 
.................... // #use rtos() Prototypes:
.................... _bif void rtos_run(void);
.................... _bif void rtos_yield(void);
.................... _bif void rtos_enable(unsigned int8 task);
.................... _bif void rtos_disable(unsigned int8 task);
.................... _bif void rtos_terminate(void);
.................... _bif void rtos_await(int1 flag);
.................... _bif void rtos_wait(unsigned int8 sem);
.................... _bif void rtos_signal(unsigned int8 sem);
.................... _bif void rtos_msg_send(unsigned int8 task, unsigned int8 msg);
.................... _bif unsigned int8 rtos_msg_read(void);
.................... _bif unsigned int8 rtos_msg_poll(void);
.................... _bif int1 rtos_overrun(unsigned int8 task);
.................... _bif void rtos_stats(unsigned int8 task, unsigned int8* stat);
.................... 
.................... // #use timer() Prototypes:
.................... _bif unsigned int8 get_ticks(void);
.................... _bif unsigned int16 get_ticks(void);
.................... _bif unsigned int32 get_ticks(void);
.................... _bif unsigned int64 get_ticks(void);
.................... _bif unsigned int8 get_ticks(unsigned int8 stream);
.................... _bif unsigned int16 get_ticks(unsigned int8 stream);
.................... _bif unsigned int32 get_ticks(unsigned int8 stream);
.................... _bif unsigned int64 get_ticks(unsigned int8 stream);
.................... _bif void set_ticks(unsigned int8 value);
.................... _bif void set_ticks(unsigned int16 value);
.................... _bif void set_ticks(unsigned int32 value);
.................... _bif void set_ticks(unsigned int64 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int8 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int16 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int32 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int64 value);
.................... 
.................... // #use pwm() Prototypes:
.................... _bif void pwm_on(void);
.................... _bif void pwm_on(unsigned int8 stream);
.................... _bif void pwm_off(void);
.................... _bif void pwm_off(unsigned int8 stream);
.................... _bif void pwm_set_duty(unsigned int16 duty);
.................... _bif void pwm_set_duty(unsigned int8 stream, unsigned int16 duty);
.................... _bif void pwm_set_duty_percent(unsigned int16 percent);
.................... _bif void pwm_set_duty_percent(unsigned int8 stream, unsigned int16 percent);
.................... _bif void pwm_set_frequency(unsigned int32 frequency);
.................... _bif void pwm_set_frequency(unsigned int8 stream, unsigned int32 frequency);
.................... 
.................... // #use capture() Prototypes:
.................... _bif unsigned int16 get_capture_time(void);
.................... _bif unsigned int16 get_capture_time(unsigned int8 stream);
.................... _bif int1 get_capture_event(void);
.................... _bif int1 get_capture_event(unsigned int8 stream);
.................... 
.................... // Environment Prototypes:
.................... //_bif unsigned int8 getenv(char* cstring);
.................... 
.................... // Address Prototypes:
.................... #ifndef __ADDRESS__
.................... #define __ADDRESS__ unsigned int32
.................... #endif
.................... _bif void goto_address(__ADDRESS__ address);
.................... _bif __ADDRESS__ label_address(__ADDRESS__ label);
.................... 
.................... // Program Memory Prototypes:
.................... _bif void read_program_memory(__ADDRESS__ address, unsigned int8* dataptr, unsigned int16 count);
.................... _bif void erase_program_memory(__ADDRESS__ address);
.................... _bif void write_program_memory(__ADDRESS__ address, unsigned int8* dataptr, unsigned int16 count);
.................... _bif void read_configuration_memory(unsigned int8* dataptr, unsigned int8 count);
.................... _bif void write_configuration_memory(unsigned int8* dataptr, unsigned int8 count);
.................... 
.................... ////////////////////////////////////////////////////////////////// INT
.................... // Interrupt Functions: ENABLE_INTERRUPTS(), DISABLE_INTERRUPTS(),
.................... //                      CLEAR_INTERRUPT(), INTERRUPT_ACTIVE(),
.................... //                      EXT_INT_EDGE()
.................... // INT Prototypes:
.................... _bif void enable_interrupts(unsigned int16 interrupt);
.................... _bif void disable_interrupts(unsigned int16 interrupt);
.................... _bif void clear_interrupt(unsigned int16 interrupt);
.................... _bif int1 interrupt_active(unsigned int16 interrupt);
.................... _bif int1 interrupt_enabled(unsigned int16 interrupt);
.................... _bif void ext_int_edge(unsigned int8 source, unsigned int8 edge);
.................... _bif void jump_to_isr(unsigned int16 address);
.................... // Constants used in EXT_INT_EDGE() are:
.................... #define L_TO_H              0x40
.................... #define H_TO_L                 0
.................... //
.................... // Constants used in other interrupt functions are:
.................... #define INTR_GLOBAL               0x400
.................... #define GLOBAL                    0x400  // For compatibility with PIC16/18
.................... #define INTR_NORMAL               0x100
.................... #define INTR_ALTERNATE            0x200
.................... #define INTR_LEVEL0               0x500
.................... #define INTR_LEVEL1               0x501
.................... #define INTR_LEVEL2               0x502
.................... #define INTR_LEVEL3               0x503
.................... #define INTR_LEVEL4               0x504
.................... #define INTR_LEVEL5               0x505
.................... #define INTR_LEVEL6               0x506
.................... #define INTR_LEVEL7               0x507
.................... 
.................... #define INTR_CN_PIN              0x8000  // or in a PIN_xx constant
.................... 
.................... #define INT_OSCFAIL               1
.................... #define INT_ADDRERR               2
.................... #define INT_STACKERR              3
.................... #define INT_MATHERR               4
.................... #define INT_DMAERR                5
.................... #define INT_EXT0                  6
.................... #define INT_IC1                   7
.................... #define INT_OC1                   8
.................... #define INT_TIMER1                9
.................... #define INT_DMA0                  69
.................... #define INT_IC2                   70
.................... #define INT_OC2                   71
.................... #define INT_TIMER2                72
.................... #define INT_TIMER3                73
.................... #define INT_SPI1E                 74
.................... #define INT_SPI1                  75
.................... #define INT_RDA                   76
.................... #define INT_TBE                   77
.................... #define INT_ADC1                  78
.................... #define INT_DMA1                  79
.................... #define INT_SI2C                  81
.................... #define INT_MI2C                  82
.................... #define INT_CNI                   84
.................... #define INT_EXT1                  85
.................... #define INT_IC7                   87
.................... #define INT_IC8                   88
.................... #define INT_DMA2                  89
.................... #define INT_OC3                   90
.................... #define INT_OC4                   91
.................... #define INT_TIMER4                92
.................... #define INT_TIMER5                93
.................... #define INT_EXT2                  94
.................... #define INT_RDA2                  95
.................... #define INT_TBE2                  96
.................... #define INT_SPI2E                 97
.................... #define INT_SPI2                  98
.................... #define INT_C1RX                  99
.................... #define INT_CAN1                  100
.................... #define INT_DMA3                  101
.................... #define INT_PWM1                  110
.................... #define INT_DMA4                  111
.................... #define INT_QEI                   123
.................... #define INT_DMA5                  126
.................... #define INT_PWM2                  127
.................... #define INT_FAULTA                128
.................... #define INT_UART1E                130
.................... #define INT_UART2E                131
.................... #define INT_QEI2                  132
.................... #define INT_DMA6                  133
.................... #define INT_DMA7                  134
.................... #define INT_C1TX                  135
.................... #define INT_FAULTA2               139
.................... #define INT_COMP                  152
.................... #define INT_PMP                   164
.................... #define INT_RTC                   173
.................... #define INT_CRC                   174
.................... #define INT_DAC1R                 177
.................... #define INT_DAC1L                 178
.................... 
.................... #list
.................... 
.................... #endif
.................... 
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... #include "algoritmo.h"
.................... /**
....................  @file    ALGORITMO.h
....................  @author  Ricardo Gomez, Klaudija Ziliute
....................  @brief   PanTompkins header file
.................... */
.................... 
.................... 
.................... #ifndef __ALGORITMO_H
.................... #define __ALGORITMO_H
.................... 
.................... #include "common.h"
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "adc.h"
.................... #include "BEEP.h"
.................... 
.................... 
.................... int algoritmo(void);
.................... void init_algoritmo(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ALGORITMO_H
.................... 
.................... #include "SD_Card.h"
.................... /**
....................  @file    SD_CARD.h
....................  @author  Ricardo Gomez, Klaudija Ziliute
....................  @brief   PanTompkins header file
.................... */
.................... 
.................... 
.................... #ifndef __SD_CARD_H
.................... #define __SD_CARD_H
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... #include "miFAT.h"
.................... 
.................... #ifndef __MIFAT_H
.................... #define __MIFAT_H
.................... // Definidos en sdcard.h - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... extern unsigned int8 dt[512];
.................... extern unsigned int32 LBA0;
.................... extern unsigned int8 sd_init();
.................... extern unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr);
.................... extern unsigned int8 sd_read_block( unsigned int32 address, unsigned char* ptr);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define MAX_ENTRIES_SECTOR_FAT16        256
.................... #define ENDFILE16                    0xFFFF
.................... #define MAX_ENTRIES_SECTOR_FAT32        128
.................... #define ENDFILE32                0x0FFFFFFF
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... typedef struct{
.................... 	union{
.................... 		unsigned int8 raw[32];
.................... 		struct fields{
.................... 			char name[8];
.................... 			char extension[3];
.................... 			unsigned int8 attrib;			///sï¿½lo lectura, oculto, de sistema, directorio...
.................... 			//unsigned int8 reserved[10];
.................... 			  unsigned int8  reserved;
.................... 	 		  unsigned int8  createTimeMs;
.................... 			  unsigned int16 create_hour;
.................... 			  unsigned int16 create_date;
.................... 			  unsigned int16 last_access;
.................... 			  unsigned int16 eaIndex;
.................... 			  unsigned int16 modif_hour;
.................... 			  unsigned int16 modif_date;
.................... 			  unsigned int16 first_cluster;	///primer cluster (direcciona tabla FAT y sector para escribir contenido)
.................... 			  unsigned int32 size;			///tamaï¿½o en bytes
.................... 		};
.................... 	};
.................... } fileEntry;
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... typedef struct{
.................... 	unsigned int32 currentCluster;
.................... 	unsigned int32 currentSector;
.................... 	unsigned int16 posInSector;      //posiciï¿½n actual al escribir en el sector
.................... 	unsigned int32 sectorAtFAT;      //sector de la 1ï¿½ FAT en el que tenemos el actual puntero de cierre de fichero
.................... 
.................... 	unsigned int32 sectorEntryFile; //direcciï¿½n del sector de entradas de fichero
.................... 	unsigned int8  EntryFile[512];  //sector donde estï¿½ la entrada (root) del fichero (para actualizar tamaï¿½o)
.................... 	unsigned int16 offsetEntry;     //offset en el sector de entradas del fichero
.................... 	unsigned int32 size;            //tamaï¿½o del fichero
.................... }_file;
.................... 
.................... _file file;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... typedef struct _diskinforec{
....................    unsigned int8  jmpBoot[3];   // bytes  0.. 2: Salto a la rutina de arranque
....................    unsigned int8  OEMName[8];   // bytes  3..10: Es una cadena "MSDOS5.0"
....................    unsigned int16 BytsPerSec;   // bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes)
....................    unsigned int8  SectPerClus;  // byte  13:    Numero de sectores contenidos en 1 cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes
....................    unsigned int16 RsrvdCnt;     // bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente
....................    unsigned int8  NumFATs;      // byte  16:    Numero de tablas FAT en el volumen. Habitualmente es 2
....................    unsigned int16 RootEntCnt;   // bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
....................    unsigned int16 TotSect16;    // bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0)
....................    unsigned int8  Media;        // byte  21:    Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0
....................    unsigned int16 FATsz16;      // bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0)
....................    unsigned int16 SectPerTrack; // bytes 24..25: Sectores por track
....................    unsigned int16 NumHeads;     // bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.)
....................    unsigned int32 HiddSec;      // bytes 28..31: Sectores ocultos que preceden a la particion (irrelevante en uSD)
....................    unsigned int32 TotSect32;    // bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta
....................    unsigned int32 FATsz32;      // bytes 36..39: Numero de sectores ocupados por una FAT
....................    unsigned int16 ExtFlags;     // bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0)
....................    unsigned int16 FSVer;        // bytes 42..43: Version del sistema de archivos (empleamos la 0.0)
....................    unsigned int32 RootClus;     // bytes 44..47: Indica el numero del 1er cluster del directorio raiz.
....................    unsigned int16 FSInfo;       // bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1)
....................    unsigned int16 BkBootSec;    // bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque
....................    unsigned int8  RsrvdSys[12]; // bytes 52..63: Bytes reservados para futuros usos del sistema
....................    unsigned int8  DrvNum;       // byte  64:     Numero de la unidad (para MSDOS pero irrelevante en uSD).
....................    unsigned int8  Reserved1;    // byte  65:     Windows NT para formatear un volumen pone este byte a 0
....................    unsigned int8  BootSig;      // byte  66:     Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows)
....................    unsigned int32 VolId;        // bytes 67..70: Numero de volumen (generado por el reloj del sistema).
....................    unsigned int8  VolLab[11];   // bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME     ". Nosotros podemos poner "NUUBO_SD    "
....................    unsigned int8  FilSysType[8];// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   "
....................    unsigned int8  spam[420];    // bytes 90..509:Zona de codigo (no lo empleamos y esta a 0)
....................    unsigned int16 firma;        // byte 510..511:Debe de vale 55 AA
.................... } diskinforec;
.................... 
.................... diskinforec DiskInfo;
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned  int8 FATType; // FAT16 o FAT32
.................... //variables clave: inicio de la FAT1 y la FAT2 y de las entradas de ficheros
.................... unsigned  int8 sect_x_cluster;
.................... unsigned int16 sect_fat_1;
.................... unsigned int16 sect_fat_2;
.................... unsigned int32 sect_ini_datos;
.................... unsigned int32 sect_x_fat;
.................... unsigned int32 sect_entry;
.................... unsigned int16 sect_reserv;
.................... 
.................... //unsigned int8 dFil[32];
.................... unsigned int32 sector_fat32[MAX_ENTRIES_SECTOR_FAT32]; // 128 x 4 = 512
.................... unsigned int16 sector_fat16[MAX_ENTRIES_SECTOR_FAT16]; // 256 x 2 = 512
.................... 
.................... //atributos
.................... #define __FILE		0x20
.................... #define _DIRECTORY	0x10
.................... #define _VOLUMEN	0x08
.................... #define _SYSTEM		0x04
.................... #define _HIDDEN		0x02
.................... #define READONLY	0x01
.................... 
.................... ///variables globales
.................... unsigned int16 year = 2020;
.................... unsigned int8 yearLo=   20;
.................... unsigned int8 month =   10;
.................... unsigned int8 day   =	15;
.................... unsigned int8 hour	=   12;
.................... unsigned int8 minute=   34;
.................... unsigned int8 second=   56;
.................... 
.................... ///funciones
.................... #define getHour() (int16)((int16)hour << 11) + (int16)((int16)minute << 5) + (int16) (second >> 1)		//5 bits: horas, 6 bits: minutos, 5 bits: segundos/2
.................... #define getDate() (((int16)year - 1980) << 9 ) + ((int16)month << 5) + (int16)day	//7 bits: aï¿½o (desde 1980), 4 bits: mes, 5 bits: dia
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... void initFAT(){
....................    unsigned int32 startClusterOfRootDirectory = 2;
....................    unsigned int32 sctrs;
....................    unsigned  int8 *ptrSct;
....................    diskinforec *ptrDiskInfo;
.................... 
.................... 	sd_read_block(LBA0, dt);
....................     						ptrDiskInfo=&DiskInfo;
....................     						ptrSct= &dt[0];
....................    	memcpy((*ptrDiskInfo).jmpBoot, (ptrSct +  0), 3); 			//DiskInfo.jmpBoot[3]	// bytes  0.. 2: Salto a la rutina de arranque
....................    	memcpy((*ptrDiskInfo).OEMName, (ptrSct +  3), 8); 			//DiskInfo.OEMName[8]	// bytes  3..10: Es una cadena, habitualmente "MSDOS5.0"
....................    	DiskInfo.BytsPerSec = make16(dt[12],dt[11]);   				// bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes)
.................... 	DiskInfo.SectPerClus = dt[13];								// byte  13:	 Numero de sectores contenidos en un cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes
.................... 	DiskInfo.RsrvdCnt = make16(dt[15],dt[14]);					// bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente
....................    	DiskInfo.NumFATs = dt[16];									// byte  16:	 Numero de tablas FAT en el volumen. Habitualmente es 2
.................... 	DiskInfo.RootEntCnt = make16(dt[18],dt[17]);				// bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
....................    	DiskInfo.TotSect16 = make16(dt[20],dt[19]);					// bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0)
.................... 	DiskInfo.Media = dt[21];									// byte  21:	 Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0
.................... 	DiskInfo.FATsz16 = make16(dt[23],dt[22]);					// bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0)
.................... 	DiskInfo.SectPerTrack = make16(dt[25],dt[24]); 				// bytes 24..25: Sectores por track
....................    	DiskInfo.NumHeads = make16(dt[27],dt[26]);					// bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.)
.................... 	DiskInfo.HiddSec = make32(dt[31],dt[30],dt[29],dt[28]);		// bytes 28..31: Sectores ocultos que preceden a la particion
.................... 	DiskInfo.TotSect32=make32(dt[35],dt[34],dt[33],dt[32]);		// bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta
.................... 	DiskInfo.FATsz32 = make32(dt[39],dt[38],dt[37],dt[36]);		// bytes 36..39: Numero de sectores ocupados por una FAT
.................... 	DiskInfo.ExtFlags = make16(dt[41],dt[40]); 					// bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0)
.................... 	DiskInfo.FSVer = make16(dt[43],dt[42]); 					// bytes 42..43: Version del sistema de archivos (empleamos la 0.0)
.................... 	DiskInfo.RootClus= make32(dt[47],dt[46],dt[45],dt[44]);		// bytes 44..47: Indica el numero del 1er cluster del directorio raiz.
.................... 	DiskInfo.FSInfo = make16(dt[49],dt[48]); 					// bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1)
.................... 	DiskInfo.BkBootSec = make16(dt[51],dt[50]); 				// bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque
.................... 	//  Estructura en el caso de FAT32 ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½
.................... 	memcpy((*ptrDiskInfo).RsrvdSys, (ptrSct +  52), 12);		//DiskInfo.RsrvdSys[12] 	// bytes 52..63: Bytes reservados para futuros usos del sistema
.................... 	DiskInfo.DrvNum = dt[64];								 	// byte  64: 	 Numero de la unidad
.................... 	DiskInfo.Reserved1 = dt[65];								// byte  65: 	 Windows NT para formatear un volumen pone este byte a 0
.................... 	DiskInfo.BootSig = dt[66]; 									// byte  66: 	 Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows)
.................... 	DiskInfo.VolId = make32(dt[70],dt[69],dt[68],dt[67]); 		// bytes 67..70: Numero de volumen (generado por el reloj del sistema).
.................... 	memcpy((*ptrDiskInfo).VolLab, (ptrSct +  71), 11);			//DiskInfo.VolLab[11]	// bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME    "
.................... 	memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  82), 8);		//DiskInfo.FilSysType[8] 	// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   "
.................... 	memcpy((*ptrDiskInfo).spam, (ptrSct +  90),420);			//DiskInfo.spam[420]		// bytes 90..509:Zona de codigo (en uSD no se emplea y suele estar a 0)
.................... 	DiskInfo.firma = make16(dt[510],dt[511]);								// byte 510..511:Debe de vale 55 AA
.................... 
....................    		FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'3''2'
.................... 
....................    if(FATType == 32){
.................... 						sect_x_fat  = DiskInfo.FATsz32;		// Sectores reservados para la FAT
.................... 						startClusterOfRootDirectory = DiskInfo.RootClus;
....................  	}else{
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);	//DiskInfo.FilSysType[8] 	// bytes 54..61: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT16   "
.................... 						FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'1''6'
.................... 	}
.................... 
.................... 	if(FATType == 16){
.................... 						DiskInfo.VolId = make32(dt[42],dt[41],dt[40],dt[39]);
.................... 						memcpy((*ptrDiskInfo).VolLab, (ptrSct +  43), 11);
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);
.................... 
.................... 						sect_x_fat  = DiskInfo.FATsz16;		// Sectores reservados para la FAT
.................... 						startClusterOfRootDirectory = DiskInfo.RootEntCnt;
....................  					}
.................... 
....................   	sect_x_cluster = DiskInfo.SectPerClus;					// Cada cluster tiene este numero de sectores
.................... 
....................     			      sctrs  = LBA0;
.................... 				  	  sctrs += DiskInfo.RsrvdCnt;
.................... 	sect_reserv 	= sctrs;								// sectores reservados por el sistema
.................... 
....................     sect_fat_1  	= sctrs;               					// A partir de ahï¿½: FAT 1
.................... 				  	  sctrs += sect_x_fat;
.................... 	sect_fat_2  	= sctrs;;								// A partir de ahï¿½: FAT 2 (copia de seguridad)
.................... 				  	  sctrs += sect_x_fat;
.................... 	sect_entry  	= sctrs ;      							// A partir de ahï¿½ empieza el raï¿½z (la lista de ficheros)
.................... 					  sctrs += sect_x_cluster;
.................... 	sect_ini_datos 	= sctrs ;								// A partir de ahi los datos del fichero
.................... 
....................     if(FATType == 16)										// RootEntCnt: Numero de entradas de 32 bytes al
....................     sect_ini_datos = sect_entry+(DiskInfo.RootEntCnt>>4);	// directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
.................... 
.................... }//fin initFAT()
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void cargaConfig(unsigned int32 j);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... // unsigned int8 encontrar_fichero(){
.................... //    unsigned int8 FicheroEncontrado = 0;
.................... //    unsigned int32 i;
.................... //    unsigned int16 j;
.................... //    unsigned int32 SctStart = sect_entry;			//inicio Root
.................... //    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root
.................... //    unsigned int32 ClstIni  = ((FATType==16)?1:2);
.................... //
.................... //    unsigned int32 ClstNxt;
.................... //    unsigned int32 sctrClstr;
.................... //    unsigned int32 posSctr;
.................... //    unsigned int32 clstrSig;
.................... //
.................... //    for(i = SctStart; i < SctEnd; i++){
.................... // 	      sd_read_block(i, dt);
.................... // 		 for(j = 0; j < 512; j += 32){
.................... // 										if(	(dt[j + 0] == 'C')&&
.................... // 											(dt[j + 1] == 'O')&&
.................... // 											(dt[j + 2] == 'N')&&
.................... // 											(dt[j + 3] == 'F')&&
.................... // 											(dt[j + 4] == 'I')&&
.................... // 											(dt[j + 5] == 'G')&&
.................... // 											(dt[j + 6] == ' ')&&
.................... // 											(dt[j + 7] == ' ')&&
.................... // 											(dt[j + 8] == 'T')&&
.................... // 											(dt[j + 9] == 'X')&&
.................... // 											(dt[j + 10]== 'T')){
.................... // 																 cargaConfig(j);
.................... // 																 FicheroEncontrado = 1;
.................... // 																 return FicheroEncontrado;
.................... // 																}//fin if(CNF)
.................... //
.................... // 		}//j
.................... //    }//i
.................... //    return FicheroEncontrado;
.................... // } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void cargaConfig(unsigned int32 j){
....................    unsigned int32 direccion;
....................    unsigned int32 _sector;
.................... 
.................... 	if(FATType==16){
.................... 	   	direccion = make32(0,0,dt[j+27],dt[j+26]);
.................... 		_sector = ((unsigned int32)direccion - 2) * sect_x_cluster + sect_ini_datos;
.................... 	}
.................... 	if(FATType==32){
.................... 	   direccion = make32(dt[j+21],dt[j+20],dt[j+27],dt[j+26]); //en FAT32 se usa EAIndex + first cluster
.................... 	   _sector = ((unsigned int32)direccion - 3) * sect_x_cluster + sect_ini_datos;
....................    }
....................    sd_read_block(_sector, dt); //leer el primer sector de los datos del fichero
.................... 
....................    // Ahora en el vector dt tengo los datos del fichero y puedo emplearlo
....................    // Por ejemplo: el texto que indica la hora y minutos del ensayo lo obtendria como:
....................    // hora   = (dt[140]-'0')*10 + dt[141]-'0' ;
....................    // minutos= (dt[143]-'0')*10 + dt[144]-'0' ;
....................    // ... Y con esos datos haria algo util
.................... 
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 inicializa_fichero(){
....................    unsigned int8 FicheroIncializado = 0;
....................    unsigned int32 i;
....................    unsigned int16 j;
....................    unsigned int32 SctStart = sect_entry;			//inicio Root
....................    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root
....................    unsigned int32 ClstIni  = ((FATType==16)?0:1);
.................... 
....................    unsigned int32 ClstNxt;
....................    unsigned int32 sctrClstr;
....................    unsigned int32 posSctr;
....................    unsigned int32 clstrSig;
.................... 
....................    unsigned int32 startCluster;      //cluster donde empezarï¿½an los datos del fichero
....................    fileEntry newFile;
.................... 
....................    for(i = SctStart; i < SctEnd; i++){
.................... 	      sd_read_block(i, dt);
.................... 		  for(j = 0; j < 512; j += 32){
.................... 			if((dt[j] == 0x00) || dt[j] == 0xFF){
.................... 					   newFile.fields.name[0] = 		'L';
.................... 					   newFile.fields.name[1] = 		'A';
.................... 					   newFile.fields.name[2] = 		'T';
.................... 					   newFile.fields.name[3] = 		'I';
.................... 					   newFile.fields.name[4] = 		'D';
.................... 					   newFile.fields.name[5] = 		'O';
.................... 					   newFile.fields.name[6] = 		'S';
.................... 					   newFile.fields.name[7] = 		'_';
.................... 					   newFile.fields.extension[0] = 	'T';
.................... 					   newFile.fields.extension[1] = 	'X';
.................... 					   newFile.fields.extension[2] = 	'T';
.................... 					   newFile.fields.reserved = 0;
.................... 					   newFile.fields.createTimeMs = 0;
.................... 					   newFile.fields.create_hour = getHour();
.................... 					   newFile.fields.create_date = getDate();
.................... 					   newFile.fields.last_access = newFile.fields.create_date;
.................... 					   newFile.fields.eaIndex = 0;
.................... 					   newFile.fields.attrib = __FILE | READONLY;   //archivo normal + sï¿½lo lectura
.................... 					   newFile.fields.modif_hour = newFile.fields.create_hour;
.................... 					   newFile.fields.modif_date = newFile.fields.create_date;
.................... 					   newFile.fields.first_cluster = 0;
.................... 					   newFile.fields.size = 0;
.................... 
.................... 					   file.offsetEntry = j;
.................... 					   file.sectorEntryFile = i;
.................... 					   sd_read_block(file.sectorEntryFile, file.EntryFile);
.................... 
.................... 					   for(i = 0; i < 32; j++, i++)  dt[j] = newFile.raw[i];
.................... 					   for(i = 0; i < 512; i++)      file.EntryFile[i] = dt[i];
.................... 					   file.posInSector    = 0;   															//empezamos en un sector y cluster nuevos
.................... 					   if(FATType==16){
.................... 					   startCluster = encontrarCluster(2);         											//busco cluster donde empezarï¿½a a almacenarse los datos
.................... 					   file.currentCluster = startCluster;   												//que serï¿½ el cluster en el que escribiremos
.................... 					   file.currentSector  = (file.currentCluster -  2) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster)
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 8) + sect_reserv;						//sector en la FAT donde marcar el cluster usado
.................... 					   }
.................... 					   if(FATType==32){
.................... 					   startCluster = encontrarCluster(3);         											//busco cluster donde empezarï¿½a a almacenarse los datos
.................... 					   file.currentCluster = startCluster;   												//que serï¿½ el cluster en el que escribiremos
.................... 					   file.currentSector  = (file.currentCluster -  3) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster)
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 7) + sect_reserv;						//sector en la FAT donde marcar el cluster usado
.................... 					   }
.................... 					   file.EntryFile[file.offsetEntry + 27] = make8(file.currentCluster, 1); 					//1er cluster del archivo
.................... 					   file.EntryFile[file.offsetEntry + 26] = make8(file.currentCluster, 0);
.................... 					   file.EntryFile[file.offsetEntry + 21] = make8(file.currentCluster, 3);
.................... 					   file.EntryFile[file.offsetEntry + 20] = make8(file.currentCluster, 2);
.................... 					   file.size = 0;																			//Inicialmente el tamaï¿½o es cero
.................... 
.................... 					   if(FATType==16){
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile);
.................... 						sd_read_block (file.sectorAtFAT, sector_fat16);
.................... 						sector_fat16[file.currentCluster % MAX_ENTRIES_SECTOR_FAT16] = ENDFILE16;				//marco el cluster como usado
.................... 						sd_write_block( file.sectorAtFAT, sector_fat16);
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat16);   //FAT2					//ï¿½Ojo! la cosa puede ser mas complicada...
.................... 						}
.................... 					   if(FATType==32){
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile);
.................... 						sd_read_block (file.sectorAtFAT,sector_fat32);
.................... 						sector_fat32[file.currentCluster % MAX_ENTRIES_SECTOR_FAT32] = ENDFILE32;				//marco el cluster como usado
.................... 						sd_write_block( file.sectorAtFAT, sector_fat32);
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat32);   //FAT2					//ï¿½Ojo! la cosa puede ser mas complicada...
.................... 						}
.................... 					   FicheroIncializado = 1;
.................... 					   return FicheroIncializado;
.................... 					   }
.................... 
.................... 		}//j
....................    }//i
....................    return FicheroIncializado;
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart){
....................    unsigned int32 cluster;
....................    unsigned int32 _sector;   //recorrer sectores
....................    unsigned int32 bytes;     //recorrer bytes en cada sector
.................... 
....................    cluster =  clusterStart;
....................    if(FATType==16)
....................    _sector = (clusterStart >> 2) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante
....................    if(FATType==32)
....................    _sector = (clusterStart >> 3) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante
....................    bytes = (clusterStart % ((FATType==16) ? MAX_ENTRIES_SECTOR_FAT16 : MAX_ENTRIES_SECTOR_FAT32));
.................... 
....................    if(FATType==32){
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT
.................... 		  sd_read_block(_sector,sector_fat32); 							//leemos el sector
....................     					      for(; bytes < MAX_ENTRIES_SECTOR_FAT32; bytes++){ //recorremos el sector para buscar un puntero a cluster libre
.................... 					         if(sector_fat32[bytes]== 0){
.................... 					            if(cluster < 3)               continue;  	//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando
.................... 					            return cluster;
.................... 					         }//fin if
.................... 					         cluster++;
.................... 					      }//fin for de recorrer bytes dentro de un sector
.................... 	      bytes = 0;
.................... 	   }//fin for de recorrer sectores
....................    }else
....................     if(FATType==16){
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT
.................... 		  sd_read_block(_sector,sector_fat16); 							//leemos el sector
.................... 
.................... 					      for(; bytes < MAX_ENTRIES_SECTOR_FAT16; bytes++){ 	//recorremos el sector para buscar un puntero a cluster libre
.................... 					         if(sector_fat16[bytes]== 0){
.................... 					            if(cluster < 2)               continue;		//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando
.................... 					            return cluster;
.................... 					         }//fin if
.................... 					         cluster++;
.................... 					      }//fin for de recorrer bytes dentro de un sector
.................... 	      bytes = 0;
.................... 	   }//fin for de recorrer sectores
.................... 	}
....................    return ((FATType==16)?ENDFILE16:ENDFILE32);
.................... }//fin encontrarCluster
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... void escribe_datos_en_fichero(){
....................    unsigned int32 relSector;
....................    unsigned int32 nextCluster;
....................    unsigned int32  oldCluster;
....................    unsigned int16 _hour, date;
.................... 
.................... 	sd_write_block(file.currentSector, dt);
.................... 
.................... 
.................... 
.................... 
.................... 		file.currentSector++;																					//actualizar las FATs
.................... 		if(FATType==16)
.................... 	    relSector= file.currentSector - ((file.currentCluster -  2) * sect_x_cluster + sect_ini_datos);
.................... 		if(FATType==32)
.................... 	    relSector= file.currentSector - ((file.currentCluster -  3) * sect_x_cluster + sect_ini_datos);
.................... 
.................... 	    if((relSector % sect_x_cluster) == 0){   											//ï¿½el siguiente sector estï¿½ en cluster nuevo?
.................... 	      oldCluster = 	file.currentCluster;
.................... 	      nextCluster = encontrarCluster(oldCluster);   									//siguiente cluster
.................... 	      //escribirCluster(oldCluster, nextCluster);  										//marcar actual cluster para que apunte al siguiente
.................... 	      file.currentCluster = nextCluster;
.................... 		  if(FATType==16)
.................... 	      file.currentSector = (nextCluster - 2) * sect_x_cluster + sect_ini_datos;
.................... 		  if(FATType==32)
.................... 	      file.currentSector = (nextCluster - 3) * sect_x_cluster + sect_ini_datos;
.................... 	   }
.................... 
.................... 	   //actualizar el tamaï¿½o del fichero y fechas
.................... 	   file.size += 512;
.................... 	   file.EntryFile[file.offsetEntry + 28] = make8(file.size, 0);   //tamaï¿½o
.................... 	   file.EntryFile[file.offsetEntry + 29] = make8(file.size, 1);
.................... 	   file.EntryFile[file.offsetEntry + 30] = make8(file.size, 2);
.................... 	   file.EntryFile[file.offsetEntry + 31] = make8(file.size, 3);
.................... 	   //ActualizaReloj();
.................... 	   _hour = getHour();
.................... 	   date = getDate();
.................... 	   file.EntryFile[file.offsetEntry + 24] = make8(date, 0);       //fecha modif
.................... 	   file.EntryFile[file.offsetEntry + 25] = make8(date, 1);
.................... 	   file.EntryFile[file.offsetEntry + 22] = make8(_hour, 0);      //hora modif
.................... 	   file.EntryFile[file.offsetEntry + 23] = make8(_hour, 1);
.................... 	   file.EntryFile[file.offsetEntry + 18] = file.EntryFile[file.offsetEntry + 24];   //fecha ï¿½ltimo acceso
.................... 	   file.EntryFile[file.offsetEntry + 19] = file.EntryFile[file.offsetEntry + 25];
.................... 
.................... 	   sd_write_block(file.sectorEntryFile, file.EntryFile);  	// Actualiza root
.................... 
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __MIFAT_H
.................... 
.................... #include "sdcard.h"
.................... 
.................... #ifndef __SDCARD_H
.................... #define __SDCARD_H
.................... 
.................... #bit  SPIRBF    = getenv("SFR:SPI1STAT").0
.................... #bit  SPITBF    = getenv("SFR:SPI1STAT").1
.................... #bit  SPIROV    = getenv("SFR:SPI1STAT").6
.................... #byte SPI1BUF   = getenv("SFR:SPI1BUF")
.................... #byte SPI1STAT  = getenv("SFR:SPI1STAT")
.................... #byte SPI1CON1  = getenv("SFR:SPI1CON1")
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define   CMD0              		0x40      //go to idle				//Commands
.................... #define   CMD1               		0x41      //initialization process
.................... #define   CMD8               		0x48      //verify interface
.................... #define   CMD17              		0x51      //read single block
.................... #define   CMD24              		0x58      //write single block
.................... #define   CMD55              		0x77      //escape for app specific command
.................... #define   CMD58              		0x7a      //read OCR
.................... #define   ACMD41             		0x69      //poll operation range
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define   R1_READY_STATE          	0x00      //sd ready				//Responses
.................... #define   R1_IDLE_STATE           	0x01      //card in idle state
.................... #define   R1_ILLEGAL_COMMAND      	0x04      //illegal command
.................... #define   DATA_START_BLOCK       	0xFE      //start token for read or write
.................... #define   DATA_RES_MASK          	0x1F      //mask for data response
.................... #define   DATA_RES_ACCEPTED      	0x05      //write accepted
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sdhc;
.................... unsigned int8 dt[512];            /// Buffer de escritura  en uSD
.................... unsigned int32 LBA0 = 0;
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... inline unsigned int8 xfer_spi(char envio){
....................    SPIROV = 0;
....................    SPI1BUF= envio;
....................    while( SPITBF);
....................    while(!SPIRBF);
....................    return SPI1BUF;
.................... }//fin xfer_spi
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 Commnd(char befF, int32 SD_Adress, char befH){
....................    unsigned int8 iC1;
....................    xfer_spi(0xFF);
....................    xfer_spi(befF);
....................    xfer_spi(make8(SD_Adress, 3));
....................    xfer_spi(make8(SD_Adress, 2));
....................    xfer_spi(make8(SD_Adress, 1));
....................    xfer_spi(make8(SD_Adress, 0));
....................    xfer_spi(befH);
....................     do{iC1 = xfer_spi(0xFF);
....................    }while(iC1 == 0xFF);
....................    return iC1;
.................... }//fin Commnd
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_init(){
....................  unsigned  int8 R[17]={0}, versionSD= 1, crc;
....................  unsigned int16 iI;
....................  unsigned int32 arg=0;
.................... 
....................  setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_16);
.................... 
....................  memset(dt,0,512);
....................  // CMD0 - GO_IDLE_STATE  (R1)ï¿½ ï¿½ Card Reset  ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 	do{	output_high(CS);   	// tarjeta deshabilitada
.................... 		for (iI = 0; iI < 10; iI++)  	xfer_spi(0xFF);
.................... 		output_low(CS); 	// tarjeta habilitada
.................... 		R[0] = Commnd( CMD0 , 0x00000000 , 0x95); //go to idle
.................... 	}while( R[0] != R1_IDLE_STATE);
....................   // CMD8 - SEND_IF_COND (R7)  ï¿½ Send Interface Condition Commandï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // Argument 00 - 00 - 01 (Voltage supplied = 2.7-3.6V) - AA (Check pattern)
....................   // Response: illegal command -> Version 1
....................   // Response: echo-back 	   -> Version 2
.................... 	R[0] = Commnd(CMD8, 0x000001AA, 0x87);
....................     if(R[0]& R1_ILLEGAL_COMMAND){	  			versionSD = 1;
....................    			}else{	R[1] = xfer_spi(0xFF);
.................... 					R[2] = xfer_spi(0xFF);
.................... 					R[3] = xfer_spi(0xFF);
.................... 					R[4] = xfer_spi(0xFF);
.................... 				    if(R[4]!=0xAA){	output_high(CS); return 1; }		//error
....................       											versionSD = 2;
....................    			}
.................... 
....................   // ACMD41 - SD_SEND_OP_ COND (R1) ï¿½ ï¿½ Initialization Command   ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // If host supports SDHC or SDXC: HCS (Host Capacity Support) is set to 1 (arg= 0x40000000)
....................   // If host only support SDSC:     HCS (Host Capacity Support) is set to 0 (arg= 0)
....................    arg = (versionSD == 2) ? 0x40000000 : 0;
....................    crc = (versionSD == 2) ? 0x77 : 0xFF;
.................... 
.................... 
....................    do{            Commnd(CMD55,    0, 0x65);	// El proceso puede llegar a durar hasta 1 segundo
....................            R[0] = Commnd(ACMD41, arg, crc);		// Application-Specific Command ï¿½ APP_CMD (CMD55)
.................... 		   delay_ms(4);
....................    }while(R[0] != R1_READY_STATE);
.................... 
....................   if(versionSD == 2){
.................... 
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // CMD58 - READ_OCR (R3) ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // Bit 30 - Card Capacity Status bit: 	0 indicates that the card is SDSC.
....................   //										1 indicates that the card is SDHC or SDXC
.................... 	R[0] = Commnd(CMD58, 0x00000000, 0xFF);
....................     if(R[0] == R1_READY_STATE){	R[1] = xfer_spi(0xFF);
.................... 								R[2] = xfer_spi(0xFF);
.................... 								R[3] = xfer_spi(0xFF);
.................... 								R[4] = xfer_spi(0xFF);
.................... 								sdhc = ((R[1]& 0xC0) == 0xC0) ? 1 : 0;
....................    			}else{				output_high(CS); return 1; }		//error
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 
....................   }// versionSD == 2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
....................   setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_1);
.................... 
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 	sd_read_block(0, dt);	//Lee el sector fisico 0 para obtener el LBA0
.................... 	if(dt[510]==0x55)
.................... 	if(dt[511]==0xAA){ 		// Efectivamente parece que estoy en sct 0
.................... 							// Tabla de particiones
.................... 								LBA0 = make32(dt[457],dt[456],dt[455],dt[454]);
.................... 								if(dt[0]==0xEB) // MBR
....................  								LBA0 = 0;
.................... 						  }//55AA
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 
....................   output_high(CS);   									// tarjeta deshabilitada
....................   return 0;
.................... }//char sd_init()- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr){
....................    unsigned int16 iW;
.................... 
....................    if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores
....................    output_low(CS);
.................... 
.................... 		iW = Commnd(CMD24, address, 0xFF);
....................     if( iW == R1_READY_STATE){
....................              								              		xfer_spi(0xFF);
....................                               									xfer_spi(DATA_START_BLOCK);   // Data start token
....................                            			for(iW = 0; iW < 512; iW++)  xfer_spi(ptr[iW]);
....................                            							xfer_spi(0xFF);   // Dummy bytes
....................                           							xfer_spi(0xFF);   // en lugar del CRC16
.................... 
....................                         do{       iW = xfer_spi(0xFF);
....................                         }while( (iW & DATA_RES_MASK) != DATA_RES_ACCEPTED);
.................... 
....................                         do{       iW = xfer_spi(0xFF); delay_us(100);
....................                         }while(   iW == 0 );
.................... 
.................... 						xfer_spi(0xFF);
.................... 						xfer_spi(0xFF);
.................... 
....................    						output_high(CS);   return 0; //correcto
.................... 						}
....................    						output_high(CS);   return 1; //error
.................... }//fin sd_write_block
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr){
....................    unsigned int16 jR;
....................    unsigned int8  iR;
.................... 
....................     if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores
....................     output_low(CS);
.................... 
....................        iR  = Commnd(CMD17, address, 0xFF);
....................     if(iR == R1_READY_STATE){
.................... 								do{     iR  = xfer_spi(0xFF);
.................... 								}while( iR != DATA_START_BLOCK);
.................... 
.................... 								if(iR == DATA_START_BLOCK){
.................... 								for(jR = 0; jR < 512; jR++)
.................... 								         ptr[jR] = xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
....................   								}
.................... 
....................    							output_high(CS);      return 0;
.................... 							}
.................... 							output_high(CS);      return 1;
.................... }//fin sd_read_block
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __SDCARD_H
.................... 
.................... 
.................... void sd_init_global();
.................... void escritura_sd();
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __SD_CARD_H
.................... 
.................... #include "BLUETOOTH.h"
.................... #ifndef Bluetooth_h
.................... #define Bluetooth_h
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use rs232(UART1,baud=115200,STREAM=BT)
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void init_BT(void); //inits and enables uart isr
.................... void enviar_datos(unsigned int16 ppm);
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... 
.................... #WORD ADC1BUF0 = 0x0300;
.................... #WORD ADC1CON1 = 0x0320;
.................... #WORD ADC1CON2 = 0x0322;
.................... #WORD ADC1CON3 = 0x0324;
.................... #WORD AD1CHS0 = 0x0328;
.................... #WORD AD1PCFGL = 0x032C;
.................... #WORD IFS0 = 0x0084;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "BEEP.h"
.................... /**
....................  @file    BEEP.h
....................  @author  Julio Gomis-Tena
....................  @brief   Generate n "beeps" of variable frequency
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __BEEP_H
.................... #define __BEEP_H
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #pin_select OC2 = BUZZER
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void); //Inicializa las frecuencias de los beeps y la separaciÃ³n entre ellos
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP(unsigned int8); //Realiza n beeps
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __BEEP_H
.................... 
.................... 
.................... 
.................... int algoritmo(void);
.................... void init_algoritmo(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ALGORITMO_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... //signed int yECG[6]; // 5 Ãºltimos valores
.................... unsigned int16 yECG[6];
.................... unsigned int16 der, maximo, maximo_ant;
.................... float umbral;
.................... unsigned int16 k;
.................... int1 flag;
.................... unsigned int16 BCL, BCL2; // contador interno (1 BCL=4ms)
.................... 
.................... 
.................... void init_algoritmo()
*
00990:  MOV     W5,[W15++]
.................... {
.................... 	BCL=0;
00992:  CLR     1CF2
.................... 	k=0;
00994:  CLR     1CEE
.................... 	umbral=0;
00996:  CLR     1CEA
00998:  CLR     1CEC
.................... 	flag=0;
0099A:  BCLR.B  1CF0.0
.................... 	maximo=0;
0099C:  CLR     1CE6
.................... 	maximo_ant=0;
0099E:  CLR     1CE8
.................... 	for(int e=0; e<6; e++)
009A0:  MOV     #0,W4
009A2:  MOV     W4,3BEE
009A4:  MOV     3BEE,W0
009A6:  CP      W0,#6
009A8:  BRA     GE,9CE
.................... 	{
.................... 		yECG[e]=read_adc();
009AA:  MOV     3BEE,W0
009AC:  MOV     W0,W4
009AE:  MUL.UU  W4,#2,W0
009B0:  MOV     #1CD8,W4
009B2:  ADD     W0,W4,W5
009B4:  BCLR.B  320.0
009B6:  BSET.B  320.1
009B8:  BTSS.B  320.0
009BA:  BRA     9B8
009BC:  MOV     300,W4
009BE:  MOV     W4,[W5+#0]
.................... 		delay_ms(4);
009C0:  REPEAT  #3992
009C2:  NOP     
009C4:  MOV     3BEE,W0
009C6:  INC     W0,W0
009C8:  MOV     W0,3BEE
009CA:  GOTO    9A4
.................... 	}
.................... 	enable_interrupts(INT_TIMER2);
*
009CE:  BSET.B  94.7
009D0:  MOV     [--W15],W5
009D2:  RETURN  
.................... }
.................... 
.................... // Bucle principal del programa. Debe ejecutarse cada 4ms (250Hz).
.................... int algoritmo(void)
*
005F8:  MOV     W5,[W15++]
.................... {
.................... 	int pulsaciones;
.................... 	yECG[5] = yECG[4];		// Hace 20 ms
005FA:  PUSH    1CE0
005FC:  POP     1CE2
.................... 	yECG[4] = yECG[3];		// Hace 16 ms
005FE:  PUSH    1CDE
00600:  POP     1CE0
.................... 	yECG[3] = yECG[2]; 		// Hace 12 ms
00602:  PUSH    1CDC
00604:  POP     1CDE
.................... 	yECG[2] = yECG[1]; 		// Hace 8 ms
00606:  PUSH    1CDA
00608:  POP     1CDC
.................... 	yECG[1] = yECG[0]; 		// Hace 4 ms
0060A:  PUSH    1CD8
0060C:  POP     1CDA
.................... 	yECG[0] = read_adc(); // Ahora
0060E:  BCLR.B  320.0
00610:  BSET.B  320.1
00612:  BTSS.B  320.0
00614:  BRA     612
00616:  PUSH    300
00618:  POP     1CD8
.................... 
.................... 	//Valor absoluto de la derivada
.................... 	der = (yECG[5] > yECG[0]) ? (yECG[5] - yECG[0]) : (yECG[0] - yECG[5]);
0061A:  MOV     1CD8,W0
0061C:  MOV     1CE2,W4
0061E:  CP      W4,W0
00620:  BRA     LEU,62C
00622:  MOV     1CE2,W4
00624:  MOV     1CD8,W3
00626:  SUB     W4,W3,W0
00628:  GOTO    632
*
0062C:  MOV     1CD8,W4
0062E:  MOV     1CE2,W3
00630:  SUB     W4,W3,W0
00632:  MOV     W0,1CE4
.................... 
.................... 	if(der > maximo) maximo = der;
00634:  MOV     1CE6,W0
00636:  MOV     1CE4,W4
00638:  CP      W4,W0
0063A:  BRA     LEU,640
0063C:  PUSH    1CE4
0063E:  POP     1CE6
.................... 
.................... 	if(flag == 0)
00640:  BTSC.B  1CF0.0
00642:  BRA     66A
.................... 	{
.................... 		if(der > umbral)
00644:  MOV     1CE4,W0
00646:  CALL    2C0
*
0064A:  MOV     W0,W2
0064C:  MOV     W1,W3
0064E:  MOV     1CEA,W0
00650:  MOV     1CEC,W1
00652:  CALL    2FA
*
00656:  BRA     NC,66A
.................... 		{
.................... 			flag = 1;
00658:  BSET.B  1CF0.0
.................... 			// basal cycle length
.................... 			BCL2 = BCL;
0065A:  PUSH    1CF2
0065C:  POP     1CF4
.................... 			BCL = 0;
0065E:  CLR     1CF2
.................... 			BEEP(1);
00660:  MOV     3C32,W0
00662:  MOV.B   #1,W0L
00664:  MOV     W0,3C32
00666:  CALL    362
.................... 		}
.................... 	}
.................... 
.................... 	if (flag == 1)
*
0066A:  BTSS.B  1CF0.0
0066C:  BRA     670
.................... 	{
.................... 		k++;
0066E:  INC     1CEE
.................... 	}
.................... 
.................... 	//Durante 60 puntos = RR min = 0.24seg = 250 bpm
.................... 	//no se puede detectar otro punto RR
.................... 	//solo pasado ese tiempo se hace el calculo
.................... 
.................... 	if(k >60) // hay que calcular el tiempo que son 0.24s para nuestra freq (60 no)
00670:  MOV     1CEE,W4
00672:  MOV     #3C,W3
00674:  CP      W3,W4
00676:  BRA     C,6B0
.................... 	{
.................... 		k = 0;
00678:  CLR     1CEE
.................... 		flag = 0;
0067A:  BCLR.B  1CF0.0
.................... 
.................... 		//Me quedo con la Media del incremento MAX
.................... 		//De estos 200 puntos y del incremento de los anteriores
.................... 
.................... 		umbral = (maximo + maximo_ant)/2;
0067C:  MOV     1CE6,W0
0067E:  ADD     1CE8,W0
00680:  MOV     W0,W5
00682:  LSR     W5,#1,W0
00684:  CALL    2C0
*
00688:  MOV     W0,1CEA
0068A:  MOV     W1,1CEC
.................... 		maximo_ant = maximo;
0068C:  PUSH    1CE6
0068E:  POP     1CE8
.................... 		maximo = 0;
00690:  CLR     1CE6
.................... 
.................... 		//Reduzco el umbral al 66%
.................... 
.................... 		umbral = umbral -(umbral/3);
00692:  MOV     1CEA,W0
00694:  MOV     1CEC,W1
00696:  MOV     #0,W2
00698:  MOV     #4040,W3
0069A:  CALL    384
*
0069E:  BSET.B  43.0
006A0:  MOV     W0,W2
006A2:  MOV     W1,W3
006A4:  MOV     1CEA,W0
006A6:  MOV     1CEC,W1
006A8:  CALL    44E
*
006AC:  MOV     W0,1CEA
006AE:  MOV     W1,1CEC
.................... 	}
.................... 
.................... 	//Si pasa un rato
.................... 	//equivaldria a un pulso de 15bpm si se detectara punto R
.................... 	//y no se ha superado el umbral se reinicia
.................... 
.................... 	if(BCL > 1000)
006B0:  MOV     1CF2,W4
006B2:  MOV     #3E8,W3
006B4:  CP      W3,W4
006B6:  BRA     C,6C2
.................... 	{
.................... 		maximo = 0;
006B8:  CLR     1CE6
.................... 		umbral = 0;
006BA:  CLR     1CEA
006BC:  CLR     1CEC
.................... 		flag = 1;
006BE:  BSET.B  1CF0.0
.................... 		BCL = 0;
006C0:  CLR     1CF2
.................... 	}
.................... 	//Calculo el ritmo cardiaco (si esta en rango fisiologico)
.................... 	//y si no permanece el valor anteriore
.................... 	//15000 son las muestras de 1 minuto (60000[ms]/4[ms/muestra])
.................... 
.................... 	if((BCL2 > 65) && (BCL2 < 500))
006C2:  MOV     1CF4,W4
006C4:  MOV     #41,W3
006C6:  CP      W3,W4
006C8:  BRA     C,6DC
006CA:  MOV     1CF4,W4
006CC:  MOV     #1F4,W3
006CE:  CP      W3,W4
006D0:  BRA     LEU,6DC
.................... 	{
.................... 		pulsaciones = (int)(15000/BCL2);
006D2:  MOV     #3A98,W4
006D4:  MOV     1CF4,W3
006D6:  REPEAT  #11
006D8:  DIV.U   W4,W3
006DA:  MOV     W0,3C30
.................... 	}
.................... BCL=BCL+1;  // Actualiza la cuenta ente ciclos
006DC:  MOV     1CF2,W4
006DE:  ADD     W4,#1,W0
006E0:  MOV     W0,1CF2
.................... return pulsaciones;
006E2:  PUSH    3C30
006E4:  POP     0
006E6:  MOV     [--W15],W5
006E8:  RETURN  
.................... }
.................... 
.................... #include "BEEP.h"
.................... #include "BEEP.h"
.................... /**
....................  @file    BEEP.h
....................  @author  Julio Gomis-Tena
....................  @brief   Generate n "beeps" of variable frequency
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __BEEP_H
.................... #define __BEEP_H
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #ifndef LIB_h
.................... #define LIB_h
.................... 
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device DSPIC33FJ128MC804
.................... 
.................... #list
.................... 
.................... #endif
.................... 
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #pin_select OC2 = BUZZER
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void); //Inicializa las frecuencias de los beeps y la separaciÃ³n entre ellos
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP(unsigned int8); //Realiza n beeps
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __BEEP_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #ifndef LIB_h
.................... #define LIB_h
.................... 
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device DSPIC33FJ128MC804
.................... 
.................... #nolist
.................... //////// Program memory: 44032x24  Data RAM: 16384  Stack: 31
.................... //////// I/O: 35   Analog Pins: 9
.................... //////// Fuses: WRTB,NOWRTB,BSSHL,BSSHM,BSSHS,BSSSL,BSSSM,BSSSS,NOBSS
.................... //////// Fuses: RBS1024,RBS256,RBS128,NORBS,WRTSS,NOWRTSS,SSSHL,SSSHM,SSSHS
.................... //////// Fuses: SSSSL,SSSSM,SSSSS,NOSSS,RSS4096,RSS2048,RSS256,NORSS,WRT
.................... //////// Fuses: NOWRT,PROTECT_HIGH,PROTECT,NOPROTECT,FRC,FRC_PLL,PR,PR_PLL
.................... //////// Fuses: SOSC,LPRC,FRC_DIV_BY_16,FRC_PS,NOIESO,IESO,EC,XT,HS,NOPR
.................... //////// Fuses: OSCIO,NOOSCIO,NOIOL1WAY,IOL1WAY,CKSFSM,CKSNOFSM,NOCKSFSM
.................... //////// Fuses: WPOSTS1,WPOSTS2,WPOSTS3,WPOSTS4,WPOSTS5,WPOSTS6,WPOSTS7
.................... //////// Fuses: WPOSTS8,WPOSTS9,WPOSTS10,WPOSTS11,WPOSTS12,WPOSTS13,WPOSTS14
.................... //////// Fuses: WPOSTS15,WPOSTS16,WPRES32,WPRES128,NOWINDIS,WINDIS,NOWDT,WDT
.................... //////// Fuses: NOPUT,PUT2,PUT4,PUT8,PUT16,PUT32,PUT64,PUT128,ALTI2C1
.................... //////// Fuses: NOALTI2C1,LPOL_LOW,LPOL_HIGH,HPOL_LOW,HPOL_HIGH,PWMPIN
.................... //////// Fuses: NOPWMPIN,ICSP3,ICSP2,ICSP1,NOJTAG,JTAG,DEBUG,NODEBUG
.................... ////////
.................... #if (!defined(__PCD__)||defined(__ISNT_CCS__))
.................... #define _bif
.................... #define int8 char
.................... #define int16 int
.................... #define int32 long
.................... #define int48 long
.................... #define int64 long long
.................... #define float32 float
.................... #define float48 float
.................... #define float64 double
.................... #define int1 char
.................... 
.................... #endif
.................... ////////////////////////////////////////////////////////////////// PIN_SELECT
.................... // #pin_select function=pin
.................... // Valid Pins:
.................... //    PIN_B0,PIN_B1,PIN_B2,PIN_B3,PIN_B4,PIN_B5,PIN_B6,PIN_B7,PIN_B8,PIN_B9,
.................... //    PIN_B10,PIN_B11,PIN_B12,PIN_B13,PIN_B14,PIN_B15,PIN_C0,PIN_C1,PIN_C2,
.................... //    PIN_C3,PIN_C4,PIN_C5,PIN_C6,PIN_C7,PIN_C8,PIN_C9
.................... // Input Functions:
.................... //    INT1,INT2,T2CK,T3CK,T4CK,T5CK,IC1,IC2,IC3,IC4,IC5,OCFA,OCFB,U1RX,U1CTS,
.................... //    U2RX,U2CTS,SDI1,SCK1IN,SS1IN,SDI2,SCK2IN,SS2IN,C1RX,IC7,IC8,CSDI,CSCK,COFS,
.................... //    FLTA1,FLTA2,QEA1,QEB1,INDX1,QEA2,QEB2,INDX2,T1CK,FLT1,FLT2,FLT3,FLT4,FLT5,
.................... //    FLT6,FLT7,FLT8,SYNCI1,SYNCI2
.................... // Output Functions:
.................... //    NULL,C1OUT,C2OUT,U1TX,U1RTS,U2TX,U2RTS,SDO1,SCK1OUT,SS1OUT,SDO2,SCK2OUT,
.................... //    SS2OUT,OC1,OC2,OC3,OC4,OC5,C1TX,CSDO,CSCKOUT,COFSOUT,UPDN1,UPDN2,CTPLS,
.................... //    C3OUT,SYNCO1,REFCLKO,CMP1,CMP2,CMP3,CMP4,PWM4H,PWM4L
.................... //
.................... 
.................... ////////////////////////////////////////////////////////////////// I/O
.................... // Discrete I/O Functions: SET_TRIS_x(), OUTPUT_x(), INPUT_x(),
.................... //                         SET_PULLUP(), INPUT(),
.................... //                         OUTPUT_LOW(), OUTPUT_HIGH(),
.................... //                         OUTPUT_FLOAT(), OUTPUT_BIT()
.................... // Discrete I/O Prototypes:
.................... _bif void set_tris_a(unsigned int16 value);
.................... _bif void set_tris_b(unsigned int16 value);
.................... _bif void set_tris_c(unsigned int16 value);
.................... _bif unsigned int16 get_tris_a(void);
.................... _bif unsigned int16 get_tris_b(void);
.................... _bif unsigned int16 get_tris_c(void);
.................... _bif void output_a(unsigned int16 value);
.................... _bif void output_b(unsigned int16 value);
.................... _bif void output_c(unsigned int16 value);
.................... _bif unsigned int16 input_a(void);
.................... _bif unsigned int16 input_b(void);
.................... _bif unsigned int16 input_c(void);
.................... _bif int16 input_change_a(void);
.................... _bif int16 input_change_b(void);
.................... _bif int16 input_change_c(void);
.................... _bif void set_pullup(int1 state);
.................... _bif void set_pullup(int1 state, unsigned int16 pin);
.................... _bif void set_pulldown(int1 state);
.................... _bif void set_pulldown(int1 state, unsigned int16 pin);
.................... _bif int1 input(unsigned int16 pin);
.................... _bif int1 input_state(unsigned int16 pin);
.................... _bif void output_low(unsigned int16 pin);
.................... _bif void output_high(unsigned int16 pin);
.................... _bif void output_toggle(unsigned int16 pin);
.................... _bif void output_bit(unsigned int16 pin, int1 level);
.................... _bif void output_float(unsigned int16 pin);
.................... _bif void output_drive(unsigned int16 pin);
.................... // Constants used to identify pins in the above are:
.................... 
.................... #define PIN_A0  5648
.................... #define PIN_A1  5649
.................... #define PIN_A2  5650
.................... #define PIN_A3  5651
.................... #define PIN_A4  5652
.................... #define PIN_A7  5655
.................... #define PIN_A8  5656
.................... #define PIN_A9  5657
.................... #define PIN_A10  5658
.................... 
.................... #define PIN_B0  5712
.................... #define PIN_B1  5713
.................... #define PIN_B2  5714
.................... #define PIN_B3  5715
.................... #define PIN_B4  5716
.................... #define PIN_B5  5717
.................... #define PIN_B6  5718
.................... #define PIN_B7  5719
.................... #define PIN_B8  5720
.................... #define PIN_B9  5721
.................... #define PIN_B10  5722
.................... #define PIN_B11  5723
.................... #define PIN_B12  5724
.................... #define PIN_B13  5725
.................... #define PIN_B14  5726
.................... #define PIN_B15  5727
.................... 
.................... #define PIN_C0  5776
.................... #define PIN_C1  5777
.................... #define PIN_C2  5778
.................... #define PIN_C3  5779
.................... #define PIN_C4  5780
.................... #define PIN_C5  5781
.................... #define PIN_C6  5782
.................... #define PIN_C7  5783
.................... #define PIN_C8  5784
.................... #define PIN_C9  5785
.................... 
.................... ////////////////////////////////////////////////////////////////// Useful defines
.................... #define FALSE 0
.................... #define TRUE 1
.................... 
.................... #define BYTE unsigned int8
.................... #define BOOLEAN int1
.................... 
.................... #define getc getch
.................... #define fgetc getch
.................... #define getchar getch
.................... #define putc putchar
.................... #define fputc putchar
.................... #define fgets gets
.................... #define fputs puts
.................... 
.................... ////////////////////////////////////////////////////////////////// UART
.................... // UART Prototypes:
.................... _bif void setup_uart(unsigned int32 baud);
.................... _bif void setup_uart(unsigned int32 baud, unsigned int8 stream);
.................... _bif void setup_uart(unsigned int32 baud, unsigned int8 stream, unsigned int32 clock);
.................... _bif void set_uart_speed(unsigned int32 baud);
.................... _bif void set_uart_speed(unsigned int32 baud, unsigned int8 stream);
.................... _bif void set_uart_speed(unsigned int32 baud, unsigned int8 stream, unsigned int32 clock);
.................... // Constants used in setup_uart() are:
.................... // FALSE - Turn UART off
.................... // TRUE  - Turn UART on
.................... #define UART_ADDRESS           2
.................... #define UART_DATA              4
.................... #define UART_AUTODETECT        8
.................... #define UART_AUTODETECT_NOWAIT 9
.................... #define UART_WAKEUP_ON_RDA     10
.................... #define UART_SEND_BREAK        13
.................... 
.................... ////////////////////////////////////////////////////////////////// WDT
.................... // Watch Dog Timer Functions: SETUP_WDT() and RESTART_WDT()
.................... // WDT Prototypes:
.................... _bif void setup_wdt(unsigned int8 mode);
.................... _bif void restart_wdt(void);
.................... // Constants used for SETUP_WDT() are:
.................... #define WDT_ON      1
.................... #define WDT_OFF     0
.................... 
.................... #define  WDT_1MS    0x002
.................... #define  WDT_2MS    0x003
.................... #define  WDT_4MS    0x004
.................... #define  WDT_8MS    0x005
.................... #define  WDT_16MS   0x006
.................... #define  WDT_32MS   0x007
.................... #define  WDT_64MS   0x008
.................... #define  WDT_128MS  0x009
.................... #define  WDT_256MS  0x00A
.................... #define  WDT_512MS  0x00B
.................... #define  WDT_1S     0x00C
.................... #define  WDT_2S     0x00D
.................... #define  WDT_4S     0x00E
.................... #define  WDT_8S     0x00F
.................... #define  WDT_16S    0x010
.................... #define  WDT_33S    0x011
.................... #define  WDT_65S    0x030
.................... #define  WDT_131S   0x031
.................... 
.................... ////////////////////////////////////////////////////////////////// Control
.................... // Control Functions:  RESET_CPU(), SLEEP(), RESTART_CAUSE()
.................... // Prototypes:
.................... _bif unsigned int8 restart_cause(void);
.................... _bif void reset_cpu(void);
.................... _bif void sleep(void);
.................... _bif void sleep(unsigned int8 mode);
.................... // Constants passed into RESTART_CAUSE() are:
.................... #define RESTART_POWER_UP      0
.................... #define RESTART_BROWNOUT      1
.................... #define RESTART_WATCHDOG      4
.................... #define RESTART_SOFTWARE      6
.................... #define RESTART_MCLR          7
.................... #define RESTART_ILLEGAL_OP    14
.................... #define RESTART_TRAP_CONFLICT 15
.................... //
.................... // Constants passed into SLEEP() are:
.................... #define SLEEP_FULL      0  // Default
.................... #define SLEEP_IDLE      1  // Clock and peripherals don't stop
.................... 
.................... ////////////////////////////////////////////////////////////////// INTERNAL RC
.................... // Oscillator Prototypes:
.................... _bif void setup_oscillator(unsigned int8 type, unsigned int32 target);
.................... _bif void setup_oscillator(unsigned int8 type, unsigned int32 target, unsigned int32 source);
.................... // Constants used in setup_oscillator() are:
.................... #define OSC_INTERNAL     32
.................... #define OSC_CRYSTAL       1
.................... #define OSC_CLOCK         2
.................... #define OSC_RC            3
.................... #define OSC_SECONDARY    16
.................... 
.................... ////////////////////////////////////////////////////////////////// Timer
.................... // Timer Functions: SETUP_TIMERx, GET_TIMERx, GET_TIMERxy,
.................... // SET_TIMERx, SET_TIMERxy
.................... // Timer x Prototypes:
.................... _bif void setup_timer1(unsigned int16 mode);
.................... _bif void setup_timer1(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer1(void);
.................... _bif void set_timer1(unsigned int16 value);
.................... _bif void setup_timer2(unsigned int16 mode);
.................... _bif void setup_timer2(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer2(void);
.................... _bif void set_timer2(unsigned int16 value);
.................... _bif void setup_timer3(unsigned int16 mode);
.................... _bif void setup_timer3(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer3(void);
.................... _bif void set_timer3(unsigned int16 value);
.................... _bif unsigned int32 get_timer23(void);
.................... _bif void set_timer23(unsigned int32 value);
.................... _bif void setup_timer4(unsigned int16 mode);
.................... _bif void setup_timer4(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer4(void);
.................... _bif void set_timer4(unsigned int16 value);
.................... _bif void setup_timer5(unsigned int16 mode);
.................... _bif void setup_timer5(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer5(void);
.................... _bif void set_timer5(unsigned int16 value);
.................... _bif unsigned int32 get_timer45(void);
.................... _bif void set_timer45(unsigned int32 value);
.................... // Constants used for SETUP_TIMERx() are:
.................... //      (or (via |) together constants from each group)
.................... #define TMR_DISABLED 0x0000
.................... #define TMR_INTERNAL 0x8000
.................... #define TMR_EXTERNAL 0x8002
.................... #define TMR_GATE     0x0040
.................... 
.................... #define TMR_DIV_BY_1   0x0000
.................... #define TMR_DIV_BY_8   0x0010
.................... #define TMR_DIV_BY_64  0x0020
.................... #define TMR_DIV_BY_256 0x0030
.................... #define TMR_32_BIT     0x0008 // Only for even numbered timers
.................... 
.................... #define TMR_HALT_IDLE      0x2000
.................... #define TMR_CONTINUE_IDLE  0x0000
.................... 
.................... #define T1_EXTERNAL_SYNC  0x8006 //This only applies to Timer1
.................... #define T1_EXTERNAL_RTC   0xC002 //This only applies to Timer1
.................... /////////////////////////////////////////////////////////// INPUT CAPTURE
.................... // Functions: SETUP_CAPTURE, GET_CAPTURE,
.................... // IC Prototypes:
.................... _bif void setup_capture(unsigned int8 module, unsigned int16 mode);
.................... _bif unsigned int16 get_capture(unsigned int8 module);
.................... _bif unsigned int16 get_capture(unsigned int8 module, int1 wait);
.................... // Constants used for SETUP_CAPTURE() are:
.................... #define CAPTURE_OFF               0x0000  // Capture OFF
.................... #define CAPTURE_EE                0x0001  // Capture Every Edge
.................... #define CAPTURE_FE                0x0002  // Capture Falling Edge
.................... #define CAPTURE_RE                0x0003  // Capture Rising Edge
.................... #define CAPTURE_DIV_4             0x0004  // Capture Every 4th Rising Edge
.................... #define CAPTURE_DIV_16            0x0005  // Capture Every 16th Rising Edge
.................... #define CAPTURE_INTERRUPT_ONLY    0x0007  // Interrupt on Rising Edge when in Sleep or Idle
.................... 
.................... // The following defines can be ORed | with above to configure interrupts
.................... #define INTERRUPT_EVERY_CAPTURE   0x0000  // Interrupt on every capture event
.................... #define INTERRUPT_SECOND_CAPTURE  0x0020  // Interrupt on every second capture event
.................... #define INTERRUPT_THIRD_CAPTURE   0x0040  // Interrupt on every third capture event
.................... #define INTERRUPT_FOURTH_CAPTURE  0x0060  // Interrupt on every fourth capture event
.................... 
.................... // The following defines can be ORed | with above to select timer
.................... #define CAPTURE_TIMER2            0x0080  // On capture event Timer 2 is captured
.................... #define CAPTURE_TIMER3            0x0000  // On capture event Timer 3 is captured
.................... 
.................... // The following defines can be ORed | with above to select idle operation mode
.................... #define CAPTURE_HALT_IDLE         0x2000  // Capture module halts during idle mode
.................... #define CAPTURE_CONTINUE_IDLE     0x0000  // Capture module continues during idle mode
.................... 
.................... /////////////////////////////////////////////////////////// OUTPUT COMPARE
.................... // Functions: SETUP_COMPARE, SET_PWM_DUTY, SET_COMPARE_TIME
.................... // OC Prototypes:
.................... _bif void setup_compare(unsigned int8 module, unsigned int16 mode);
.................... _bif void set_pwm_duty(unsigned int8 module, unsigned int16 duty);
.................... _bif void set_compare_time(unsigned int8 module, unsigned int16 ocr);
.................... _bif void set_compare_time(unsigned int8 module, unsigned int16 ocr, unsigned int16 ocrs);
.................... // Constants used for SETUP_COMPARE() are:
.................... #define COMPARE_OFF               0x0000  // Compare OFF
.................... #define COMPARE_SET_ON_MATCH      0x0001  // Pin from low to high on match
.................... #define COMPARE_CLR_ON_MATCH      0x0002  // Pin from high to low on match
.................... #define COMPARE_TOGGLE            0x0003  // Pin will toggle on every match occurrence
.................... #define COMPARE_SINGLE_PULSE      0x0004  // Pin will generate single pulse on first match
.................... #define COMPARE_CONT_PULSE        0x0005  // Pin will pulse for every match
.................... #define COMPARE_PWM               0x0006  // Compare operates as PWM with fault pin disabled
.................... #define COMPARE_PWM_FAULT         0x0007  // Compare operates as PWM with fault pin enabled
.................... 
.................... // The following defines can be ORed | with above to select timer
.................... #define COMPARE_TIMER2            0x0000  // Timer 2 is the base timer
.................... #define COMPARE_TIMER3            0x0008  // Timer 3 is the base timer
.................... 
.................... // The following defines can be ORed | with above to select idle operation mode
.................... #define COMPARE_HALT_IDLE         0x2000  // Compare module halts during idle mode
.................... #define COMPARE_CONTINUE_IDLE     0x0000  // Compare module continues during idle mode
.................... 
.................... ////////////////////////////////////////////////////////////////// SPI
.................... // SPI Functions: SETUP_SPI, SPI_WRITE, SPI_READ, SPI_DATA_IN
.................... // SPI Prototypes:
.................... _bif void setup_spi(unsigned int16 mode);
.................... _bif void spi_write(unsigned int8 data);
.................... _bif void spi_write(int1 wait, unsigned int8 data);
.................... _bif void spi_write_16(unsigned int16 data);
.................... _bif void spi_write_16(int1 wait, unsigned int16 data);
.................... _bif unsigned int8 spi_read(void);
.................... _bif unsigned int8 spi_read(unsigned int8 data);
.................... _bif unsigned int16 spi_read_16(void);
.................... _bif unsigned int16 spi_read_16(unsigned int16 data);
.................... _bif int1 spi_data_in(void);
.................... _bif void setup_spi2(unsigned int16 mode);
.................... _bif void spi_write2(unsigned int8 data);
.................... _bif void spi_write2(int1 wait, unsigned int8 data);
.................... _bif void spi_write2_16(unsigned int16 data);
.................... _bif void spi_write2_16(int1 wait, unsigned int16 data);
.................... _bif unsigned int8 spi_read2(void);
.................... _bif unsigned int8 spi_read2(unsigned int8 data);
.................... _bif unsigned int16 spi_read2_16(void);
.................... _bif unsigned int16 spi_read2_16(unsigned int16 data);
.................... _bif int1 spi_data_in2(void);
.................... // Constants used in SETUP_SPI() are:
.................... //      (or (via |) together constants from each group)
.................... #define SPI_MASTER                 0x0020
.................... #define SPI_SLAVE                  0x0000
.................... 
.................... #define SPI_SCK_IDLE_HIGH          0x0040
.................... #define SPI_SCK_IDLE_LOW           0x0000
.................... 
.................... #define SPI_XMIT_L_TO_H            0x0100
.................... #define SPI_XMIT_H_TO_L            0x0000
.................... 
.................... #define SPI_MODE_16B               0x0400
.................... #define SPI_MODE_8B                0x0000
.................... 
.................... #define SPI_SAMPLE_AT_END          0x0200
.................... #define SPI_SAMPLE_AT_MIDDLE       0x0000
.................... 
.................... #define SPI_SS_ENABLED             0x0000
.................... #define SPI_SS_DISABLED            0x0080
.................... 
.................... //or (via |) one of the following when operating as MASTER
.................... #define SPI_CLK_DIV_1              0x001F
.................... #define SPI_CLK_DIV_2              0x001B
.................... #define SPI_CLK_DIV_3              0x0017
.................... #define SPI_CLK_DIV_4              0x001E
.................... #define SPI_CLK_DIV_5              0x000F
.................... #define SPI_CLK_DIV_6              0x000B
.................... #define SPI_CLK_DIV_7              0x0007
.................... #define SPI_CLK_DIV_8              0x0003
.................... #define SPI_CLK_DIV_12             0x0016
.................... #define SPI_CLK_DIV_16             0x001D
.................... #define SPI_CLK_DIV_20             0x000E
.................... #define SPI_CLK_DIV_24             0x000A
.................... #define SPI_CLK_DIV_28             0x0006
.................... #define SPI_CLK_DIV_32             0x0002
.................... #define SPI_CLK_DIV_48             0x0015
.................... #define SPI_CLK_DIV_64             0x001C
.................... #define SPI_CLK_DIV_80             0x000D
.................... #define SPI_CLK_DIV_96             0x0009
.................... #define SPI_CLK_DIV_112            0x0005
.................... #define SPI_CLK_DIV_128            0x0001
.................... #define SPI_CLK_DIV_192            0x0014
.................... #define SPI_CLK_DIV_256            0x0010
.................... #define SPI_CLK_DIV_320            0x000C
.................... #define SPI_CLK_DIV_384            0x0008
.................... #define SPI_CLK_DIV_448            0x0004
.................... #define SPI_CLK_DIV_512            0x0000
.................... 
.................... //The following defines are provided for compatibility
.................... #define SPI_L_TO_H         SPI_SCK_IDLE_LOW
.................... #define SPI_H_TO_L         SPI_SCK_IDLE_HIGH
.................... 
.................... ////////////////////////////////////////////////////////////////// ADC
.................... // ADC Functions: SETUP_ADC(), SETUP_ADC_PORTS()
.................... //                SET_ADC_CHANNEL(), READ_ADC()
.................... // ADC Prototypes:
.................... _bif void setup_adc(unsigned int32 mode);
.................... _bif void setup_adc_ports(unsigned int32 pins);
.................... _bif void setup_adc_ports(unsigned int32 pins, unsigned int16 reference);
.................... _bif void set_adc_channel(unsigned int8 channel);
.................... _bif void set_adc_channel(unsigned int8 channel, unsigned int8 neg_channel);
.................... _bif unsigned int16 read_adc(void);
.................... _bif unsigned int16 read_adc(unsigned int8 mode);
.................... _bif int1 adc_done(void);
.................... // Constants used for SETUP_ADC() are:
.................... // Clock is at ADCS<5:0> of ADCON3 Reg. (0x02A4)
.................... // Tad = (Tcy/2)*(ADCS<5:0>+1)
.................... #define ADC_OFF                 0x10000
.................... #define ADC_CLOCK                0x0000
.................... #define ADC_CLOCK_DIV_2          0x0001
.................... #define ADC_CLOCK_DIV_4          0x0003
.................... #define ADC_CLOCK_DIV_8          0x0007
.................... #define ADC_CLOCK_DIV_16         0x000F
.................... #define ADC_CLOCK_DIV_32         0x001F
.................... #define ADC_CLOCK_DIV_64         0x003F
.................... #define ADC_CLOCK_INTERNAL       0x8000     // Internal
.................... 
.................... // One of the following may be OR'ed in with the above using |
.................... // Auto-Sample Time bits
.................... #define ADC_TAD_MUL_0            0x1F00
.................... #define ADC_TAD_MUL_2            0x1D00
.................... #define ADC_TAD_MUL_4            0x1B00
.................... #define ADC_TAD_MUL_8            0x1700
.................... #define ADC_TAD_MUL_16           0x0F00
.................... #define ADC_TAD_MUL_31           0x0000
.................... 
.................... // Constants used in READ_ADC() are:
.................... #define ADC_START_AND_READ       0x07
.................... #define ADC_START_ONLY           0x01
.................... #define ADC_READ_ONLY            0x06
.................... 
.................... // Constants used in SET_ADC_CHANNEL() second parameter are:
.................... #define VSS                      0
.................... 
.................... // Constants used in SETUP_ADC_PORTS() are:
.................... // First argument:
.................... // OR together desired pins
.................... #define NO_ANALOGS      0           // None
.................... #define ALL_ANALOG      0xFFFFFFFF  // All
.................... #define sAN0      0x00000001 //| A0
.................... #define sAN1      0x00000002 //| A1
.................... #define sAN2      0x00000004 //| B0
.................... #define sAN3      0x00000008 //| B1
.................... #define sAN4      0x00000010 //| B2
.................... #define sAN5      0x00000020 //| B3
.................... #define sAN6      0x00000040 //| C0
.................... #define sAN7      0x00000080 //| C1
.................... #define sAN8      0x00000100 //| C2
.................... 
.................... // Optional Second argument:
.................... #define VSS_VDD            0x0000 // Range 0-Vdd
.................... #define VREF_VREF          0x6000 // Range VrefL-VrefH
.................... #define VREF_VDD           0x4000 // Range VrefL-Vdd
.................... #define VSS_VREF           0x2000 // Range 0-VrefH
.................... 
.................... ////////////////////////////////////////////////////////////////// COMP
.................... // Comparator Functions: setup_comparator()
.................... // Comparator Variables: C1OUT, C2OUT
.................... // Comparator Prototypes:
.................... _bif void setup_comparator(unsigned int16 mode);
.................... // Constants used in setup_comparator() are:
.................... #define NC_NC_NC_NC      0
.................... #define B2_B3_NC_NC      0x401
.................... #define B2_VR_NC_NC      0x400
.................... #define B3_VR_NC_NC      0x402
.................... #define NC_NC_B0_B1      0x804
.................... #define NC_NC_B0_VR      0x800
.................... #define NC_NC_B1_VR      0x808
.................... #define B2_B3_B0_B1      B2_B3_NC_NC | NC_NC_B0_B1
.................... #define B2_VR_B0_VR      B2_VR_NC_NC | NC_NC_B0_VR
.................... #define B3_VR_B1_VR      B3_VR_NC_NC | NC_NC_B1_VR
.................... 
.................... #define C1_INVERT     0x10
.................... #define C2_INVERT     0x20
.................... #define C1_OUTPUT     0x100
.................... #define C2_OUTPUT     0x200
.................... 
.................... #bit C1OUT = getenv("SFR:CMCON").6
.................... #bit C2OUT = getenv("SFR:CMCON").7
.................... 
.................... ////////////////////////////////////////////////////////////////// VREF
.................... // VREF Prototypes:
.................... _bif void setup_vref(unsigned int16 mode);
.................... // Constants used in setup_vref() are:
.................... #define VREF_DISABLED  0x0000
.................... #define VREF_VSS_VDD   0x0080
.................... #define VREF_ANALOG    0x0090
.................... // One of the following maybe OR'ed in with the above using |
.................... #define VREF_HIGH      0x0080
.................... #define VREF_LOW       0x00A0
.................... // The following maybe OR'ed in with the above using |
.................... #define VREF_OUTPUT    0x0040
.................... // Or (with |) the above with a number 0-15
.................... 
.................... ////////////////////////////////////////////////////////////////// PMP
.................... // PMP Functions: setup_pmp(), pmp_address(), psp_read(), pmp_read(),
.................... // psp_write(), pmp_write(), psp_output_full(),psp_input_full(),
.................... // psp_overflow(), pmp_output_full(), pmp_input_full(),
.................... // pmp_overflow()
.................... // PMP Prototypes:
.................... _bif void setup_pmp(unsigned int32 mode, unsigned int16 address_mask);
.................... _bif void pmp_address(unsigned int16 address);
.................... _bif unsigned int8 pmp_read(void);
.................... _bif void pmp_write(unsigned int8 data);
.................... _bif int1 pmp_output_full(void);
.................... _bif int1 pmp_input_full(void);
.................... _bif int1 pmp_overflow(void);
.................... _bif void setup_psp(unsigned int32 mode, unsigned int16 address_mask);
.................... _bif unsigned int8 psp_read(void);
.................... _bif unsigned int8 psp_read(unsigned int16 address);
.................... _bif void psp_write(unsigned int8 data);
.................... _bif void psp_write(unsigned int8 data, unsigned int16 address);
.................... _bif int1 psp_output_full(void);
.................... _bif int1 psp_input_full(void);
.................... _bif int1 psp_overflow(void);
.................... // Constants used in SETUP_PMP() and SETUP_PSP() are:
.................... #define PAR_ENABLE                0x8000
.................... #define PAR_DISABLE               0x0000    // Module enable/disable options
.................... #define PAR_STOP_IN_IDLE          0x2000
.................... #define PAR_CONTINUE_IN_IDLE      0x0000
.................... #define PAR_ADDR_NOT_MULTIPLEXED  0x0000    // Address multiplexing options
.................... #define PAR_LOW_ADDR_MULTIPLEXED  0x0800    // Address multiplexing options
.................... #define PAR_FULL_ADDR_MULTIPLEXED 0x1000    // Address multiplexing options
.................... #define PAR_PTBEEN_ENABLE         0x0400  // Byte Enable Port Enable bit
.................... #define PAR_PTWREN_ENABLE         0x0200  // Write Enable Strobe bit
.................... #define PAR_PTRDEN_ENABLE         0x0100  // Read/Write Strobe Port bit
.................... #define PAR_ALP_ACTIVE_HIGH       0x0020 // Address latch polarity high
.................... #define PAR_BEP_ACTIVE_HIGH       0x0004 // Byte Enable Polarity
.................... #define PAR_WRSP_ACTIVE_HIGH      0x0002 // Write strobe Polarity bit
.................... #define PAR_RDSP_ACTIVE_HIGH      0x0001 // Read strobe Polarity bit
.................... #define PAR_CS_XX                 0x0000   // Chip select pins used for address
.................... #define PAR_CS_X1                 0x0008   // Chip select pin 1 used, active high
.................... #define PAR_CS_X0                 0x0000   // Chip select pin 1 used, active low
.................... #define PAR_CS_1X                 0x0050   // Chip select pin 2 used, active high
.................... #define PAR_CS_0X                 0x0040   // Chip select pin 2 used, active low
.................... #define PAR_CS_00                 0x0080   // Chip select pins 1,2 used, active low
.................... #define PAR_CS_11                 0x0098   // Chip select pins 1,2 used, active high
.................... #define PAR_CS_10                 0x0090   // Chip select pins 1,2 used, 1 is active low, 2 is high
.................... #define PAR_CS_01                 0x0088   // Chip select pins 1,2 used, 1 is active high, 2 is low
.................... #define PAR_INTR_ON_RW                0x20000000  // Interrupt on read write
.................... #define PAR_NO_INTR_STALL_ACTIVATED   0x40000000  // No interrupt, processor stall activated
.................... #define PAR_INTR_ON_3_RW_BUF          0x60000000 // Interrupt on write to Buffer 3 or read from Buffer 3
.................... #define PAR_PSP_AUTO_INC              0x18000000 // Read write buffers auto increment
.................... #define PAR_DEC_ADDR                  0x10000000 // Increment the address
.................... #define PAR_INC_ADDR                  0x08000000 // Decrement the address
.................... #define PAR_MASTER_MODE_1             0x03000000  // Master mode 1
.................... #define PAR_MASTER_MODE_2             0x02000000  // Master mode 2
.................... #define PAR_WAITB1                    0x00000000 // 1 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB2                    0x00400000 // 2 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB3                    0x00800000 // 3 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB4                    0x00C00000 // 4 Tcy Wait state for data setup R/W
.................... #define PAR_WAITM0                    0x00000000 // 0 wait state for Read to byte
.................... #define PAR_WAITM1                    0x00040000 // 1 Tcy wait state for Read to byte
.................... #define PAR_WAITM2                    0x00080000 // 2 Tcy wait state for Read to byte
.................... #define PAR_WAITM3                    0x000C0000 // 3 Tcy wait state for Read to byte
.................... #define PAR_WAITM15                   0x003C0000 // 15 wait states
.................... #define PAR_WAITE1                    0x00000000  // 1 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE2                    0x00010000 // 2 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE3                    0x00020000 // 3 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE4                    0x00030000 // 4 Tcy Wait for data hold after strobe
.................... 
.................... ////////////////////////////////////////////////////////////////// CRC
.................... // CRC Functions: setup_crc(), crc_init(), crc_calc(), crc_calc8()
.................... // CRC Prototypes:
.................... _bif void setup_crc(unsigned int8 poly_terms, ...);
.................... _bif void crc_init(unsigned int16 value);
.................... _bif unsigned int16 crc_calc(unsigned int16 data);
.................... _bif unsigned int16 crc_calc(unsigned int16 *ptr, unsigned int16 count);
.................... _bif unsigned int8 crc_calc8(unsigned int8 data);
.................... _bif unsigned int8 crc_calc8(unsigned int8 *ptr, unsigned int16 count);
.................... 
.................... ////////////////////////////////////////////////////////////////// RTC
.................... // RTC Functions: setup_rtc(), setup_rtc_alarm(), rtc_read(),
.................... //                rtc_write(), rtc_alarm_read(), rtc_alarm_write()
.................... // Structure used in read and write functions (pass pointer):
.................... typedef struct {
....................    unsigned int8 tm_year;
....................    unsigned int8 tm_temp;  // Not used by built in functions, place holder only do not use
....................    unsigned int8 tm_mday;
....................    unsigned int8 tm_mon;
....................    unsigned int8 tm_hour;
....................    unsigned int8 tm_wday;
....................    unsigned int8 tm_sec;
....................    unsigned int8 tm_min;
....................    unsigned int8 tm_isdst; // Not used by built in functions
.................... } rtc_time_t;
.................... // RTC Prototypes:
.................... _bif void setup_rtc(unsigned int16 mode, unsigned int8 calibration);
.................... _bif void setup_rtc_alarm(unsigned int16 mode, unsigned int16 mask, unsigned int8 repeat);
.................... _bif void rtc_read(rtc_time_t *time);
.................... _bif void rtc_write(rtc_time_t *time);
.................... _bif void rtc_alarm_read(rtc_time_t *time);
.................... _bif void rtc_alarm_write(rtc_time_t *time);
.................... // Constants used in setup_rtc() are:  // Second param is calibration
.................... #define RTC_ENABLE           0x8000
.................... #define RTC_DISABLE          0
.................... #define RTC_OUTPUT_SECONDS   0x20400
.................... #define RTC_OUTPUT_ALARM     0x00400
.................... //
.................... // Constants used in setup_rtc_alarm() first param are:
.................... #define RTC_ALARM_ENABLE     0x8000
.................... #define RTC_ALARM_DISABLE    0
.................... #define RTC_CHIME_ENABLE     0x4000
.................... #define RTC_CHIME_DISABLE    0
.................... // Constants used in setup_rtc_alarm() second param are:  // Third param is repeat#
.................... #define RTC_ALARM_HALFSECOND 0x0000
.................... #define RTC_ALARM_SECOND     0x0400
.................... #define RTC_ALARM_10_SECONDS 0x0800
.................... #define RTC_ALARM_MINUTE     0x0C00
.................... #define RTC_ALARM_10_MINUTES 0x1000
.................... #define RTC_ALARM_HOUR       0x1400
.................... #define RTC_ALARM_DAY        0x1800
.................... #define RTC_ALARM_WEEK       0x1C00
.................... #define RTC_ALARM_MONTH      0x2000
.................... #define RTC_ALARM_YEAR       0x2400
.................... 
.................... ////////////////////////////////////////////////////////////////// QEI
.................... // QEI Functions: setup_qei(), qei_set_count(), qei_get_count(),
.................... //                qei_status()
.................... // QEI Prototypes:
.................... _bif void setup_qei(unsigned int16 mode, unsigned int16 filter, unsigned int16 maxcount);
.................... _bif void setup_qei(unsigned int8 unit, unsigned int16 mode, unsigned int16 filter, unsigned int16 maxcount);
.................... _bif void qei_set_count(unsigned int16 count);
.................... _bif void qei_set_count(unsigned int8 unit, unsigned int16 count);
.................... _bif unsigned int16 qei_get_count(void);
.................... _bif unsigned int16 qei_get_count(unsigned int8 unit);
.................... _bif unsigned int16 qei_status(void);
.................... _bif unsigned int16 qei_status(unsigned int8 unit);
.................... // Constants used in setup_qei() first param are:
.................... #define QEI_DISABLED        0
.................... #define QEI_MODE_X2         0x0400
.................... #define QEI_MODE_X4         0x0600
.................... #define QEI_MODE_TIMER      0x0100
.................... #define QEI_STOP_WHEN_IDLE  0x2000
.................... #define QEI_SWAP_AB         0x0080
.................... #define QEI_OUTPUT_ENABLE   0x0040
.................... #define QEI_RESET_WHEN_MAXCOUNT  0x0100
.................... #define QEI_RESET_WHEN_IDX_PULSE 0x0004
.................... #define QEI_TIMER_GATED      0x0020
.................... #define QEI_TIMER_INTERNAL   0x0000
.................... #define QEI_TIMER_EXTERNAL   0x0002
.................... #define QEI_TIMER_DIV_BY_1   0x0000
.................... #define QEI_TIMER_DIV_BY_8   0x0008
.................... #define QEI_TIMER_DIV_BY_64  0x0010
.................... #define QEI_TIMER_DIV_BY_256 0x0018
.................... // Constants used in setup_qei() second param are:   // Third param is MAXCOUNT
.................... #define QEI_FILTER_DIV_1     0x0000
.................... #define QEI_FILTER_DIV_2     0x0010
.................... #define QEI_FILTER_DIV_4     0x0020
.................... #define QEI_FILTER_DIV_16    0x0030
.................... #define QEI_FILTER_DIV_32    0x0040
.................... #define QEI_FILTER_DIV_64    0x0050
.................... #define QEI_FILTER_DIV_128   0x0060
.................... #define QEI_FILTER_DIV_256   0x0070
.................... #define QEI_FILTER_OUTPUT    0x0080
.................... #define QEI_NO_ERROR_INTS    0x0100
.................... #define QEI_IDX_WHEN_A0      0x0000  // for 2X mode
.................... #define QEI_IDX_WHEN_A1      0x0200  // for 2X mode
.................... #define QEI_IDX_WHEN_B0      0x0400  // for 2X mode
.................... #define QEI_IDX_WHEN_B1      0x0600  // for 2X mode
.................... #define QEI_IDX_WHEN_A0_B0   0x0000  // for 4X mode
.................... #define QEI_IDX_WHEN_A1_B0   0x0200  // for 4X mode
.................... #define QEI_IDX_WHEN_A0_B1   0x0400  // for 4X mode
.................... #define QEI_IDX_WHEN_A1_B1   0x0600  // for 4X mode
.................... // Constants returned from qei_status() are:
.................... #define QEI_POS_ERROR        0x8000
.................... #define QEI_FORWARD          0x0800
.................... #define QEI_INDEX_PIN        0x1000
.................... 
.................... ////////////////////////////////////////////////////////////////// MOTOR PWM
.................... // MPWM Functions: setup_motor_pwm(), set_motor_unit(),
.................... //                 set_motor_pwm_duty(), set_motor_pwm_event(),
.................... //                 get_motor_pwm_count()
.................... // MPWM Prototypes:
.................... _bif void setup_motor_pwm(unsigned int8 pwm, unsigned int32 mode, unsigned int32 timebase);
.................... _bif void setup_motor_pwm(unsigned int8 pwm, unsigned int32 mode, unsigned int8 prescale, unsigned int8 postscale, unsigned int16 period);
.................... _bif void set_motor_unit(unsigned int8 pwm, unsigned int8 pin_pair, unsigned int16 mode, unsigned int8 active_deadtime, unsigned int8 inactive_deadtime);
.................... _bif void set_motor_pwm_duty(unsigned int8 pwm, unsigned int8 pin_pair, unsigned int16 duty);
.................... _bif void set_motor_pmw_event(unsigned int8, signed int16 time);
.................... _bif unsigned int16 get_motor_pwm_count(unsigned int8 pwm);
.................... // Constants used in setup_motor_pwm() second param are (first param is unit number 1,2...):
.................... #define MPWM_DISABLED          0
.................... #define MPWM_FREE_RUN          0x8000
.................... #define MPWM_SINGLE_PULSE      0x8001
.................... #define MPWM_UP_DOWN           0x8002
.................... #define MPWM_UP_DOWN_WITH_INTS 0x8003
.................... // OR in any of the following:
.................... #define MPWM_HALT_WHEN_IDLE            0x2000
.................... #define MPWM_DUTY_UPDATES_IMMEADIATE  0x40000
.................... #define MPWM_SYNC_OVERRIDES           0x20000
.................... #define MPWM_DISABLE_UPDATES          0x10000
.................... #define MPWM_LATCH_FAULTS            0x100000
.................... 
.................... // Constants used in set_motor_unit() third param are:  (first param is unit number 1,2... and second param is pwm pin pair 1,2,3 or 4)
.................... #define MPWM_INDEPENDENT     0x0001
.................... #define MPWM_ENABLE          0x0006  // both H and L
.................... #define MPWM_ENABLE_H        0x0004
.................... #define MPWM_ENABLE_L        0x0002
.................... 
.................... #define MPWM_FORCE_L_0       0x0010
.................... #define MPWM_FORCE_L_1       0x0050
.................... #define MPWM_FORCE_H_0       0x0020
.................... #define MPWM_FORCE_H_1       0x00A0
.................... 
.................... #define MPWM_FAULTA_LA_HA     0x0700
.................... #define MPWM_FAULTA_LA_HI     0x0500
.................... #define MPWM_FAULTA_LI_HA     0x0600
.................... #define MPWM_FAULTA_LI_HI     0x0400
.................... #define MPWM_FAULTB_LA_HA     0x7000
.................... #define MPWM_FAULTB_LA_HI     0x5000
.................... #define MPWM_FAULTB_LI_HA     0x6000
.................... #define MPWM_FAULTB_LI_HI     0x4000
.................... #define MPWM_FAULT_NO_CHANGE 0x0000
.................... 
.................... ////////////////////////////////////////////////////////////////// DCI
.................... // DCI Functions: setup_dci(), dci_start(), dci_read(), dci_write(),
.................... //                dci_data_received(), dci_transmit_ready()
.................... // DCI Prototypes:
.................... _bif void setup_dci(unsigned int16 mode, unsigned int16 size, unsigned int16 receive_slot, unsigned int16 transmit_slot, unsigned int16 sample_rate);
.................... _bif void dci_start(void);
.................... _bif signed int16 dci_read(void);
.................... _bif void dci_write(signed int16);
.................... _bif int1 dci_data_received(void);
.................... _bif int1 dci_transmit_ready(void);
.................... // Constants used in setup_dci() first param are:
.................... #define MULTICHANNEL_MODE  0x0000
.................... #define I2S_MODE           0x0001
.................... #define AC97_16BIT_MODE    0x0002
.................... #define AC97_20BIT_MODE    0x0003
.................... 
.................... #define JUSTIFY_DATA       0x0020 //Start data transmission on the same clock cycle as COFS pulses (multichannel)
.................... #define MULTI_DEVICE_BUS   0x0040 //Tri-states the CSDO pin during unused time slots, normally drives '0'
.................... 
.................... #define UNDERFLOW_LAST     0x0080 //Transmits the last written value to the dci when data underflow occurs. Default is undeflow silence.
.................... #define UNDERFLOW_SILENCE  0x0000 //Transmit '0's on data undeflow. This will cause a clicking noise if you are underflowing data while outputing to a codec.
.................... 
.................... #define DCI_SLAVE          0x0100 //Default is master
.................... #define DCI_MASTER         0x0000
.................... 
.................... #define SAMPLE_FALLING_EDGE 0x0000 //Default is Sample on the rising edge of the clock
.................... #define SAMPLE_RISING_EDGE 0x0200
.................... 
.................... #define DCI_CLOCK_INPUT    0x0400 //SCLK is an input (supplied by codec or external source)
.................... #define DCI_CLOCK_OUTPUT   0x0000 //Default is clock output
.................... 
.................... #define ENABLE_LOOPBACK    0x0800 //Connect the CSDI/CSDO internally; loops all of the sound back onto the bus
.................... 
.................... #define CODEC_MULTICHANNEL  0x0000  //enables multichannel (generic) codec support
.................... #define CODEC_I2S           0x0001  //enables the I2S protocol
.................... #define CODEC_AC16          0x0002  //enables the AC-16 protocol, setupCodecTransmission has no effect
.................... #define CODEC_AC20          0x0003  //enables the AC-20 protocol, setupCodecTransmission has no effect
.................... 
.................... #define BUS_MASTER          0x0000  //designates this device as the bus master
.................... #define BUS_SLAVE           0x0300  //designates this device as a slave on a bus controlled by another codec
.................... 
.................... #define TRISTATE_BUS        0x0040        //when in master mode, the module will be in high impedance
....................                                     //during disabled frames (default drives 0's onto bus)
.................... #define SYNC_COFS_DATA_PULSE 0x0020 //signifies that data starts transmitting on the same SCK pulse as the edge of the COFS pulse
....................                                     //(default data starts on the clock after the rising edge of COFS
.................... /* Determines when a sample is taken */
.................... #define SAMPLE_RISING        0x0200 //sample data on the rising edge of the clock
.................... #define SAMPLE_FALLING       0x0000 //sample data on the falling edge of the clock
.................... 
.................... // Constants used in setup_dci() second param are:
.................... #define DCI_4BIT_WORD      0x0003
.................... #define DCI_5BIT_WORD      0x0004
.................... #define DCI_6BIT_WORD      0x0005
.................... #define DCI_7BIT_WORD      0x0006
.................... #define DCI_8BIT_WORD      0x0007
.................... #define DCI_9BIT_WORD      0x0008
.................... #define DCI_10BIT_WORD     0x0009
.................... #define DCI_11BIT_WORD     0x000A
.................... #define DCI_12BIT_WORD     0x000B
.................... #define DCI_13BIT_WORD     0x000C
.................... #define DCI_14BIT_WORD     0x000D
.................... #define DCI_15BIT_WORD     0x000E
.................... #define DCI_16BIT_WORD     0x000F
.................... 
.................... #define DCI_1WORD_FRAME    0x0000
.................... #define DCI_2WORD_FRAME    0x0010 << 1
.................... #define DCI_3WORD_FRAME    0x0020 << 1
.................... #define DCI_4WORD_FRAME    0x0030 << 1
.................... #define DCI_5WORD_FRAME    0x0040 << 1
.................... #define DCI_6WORD_FRAME    0x0050 << 1
.................... #define DCI_7WORD_FRAME    0x0060 << 1
.................... #define DCI_8WORD_FRAME    0x0070 << 1
.................... #define DCI_9WORD_FRAME    0x0080 << 1
.................... #define DCI_10WORD_FRAME   0x0090 << 1
.................... #define DCI_11WORD_FRAME   0x00A0 << 1
.................... #define DCI_12WORD_FRAME   0x00B0 << 1
.................... #define DCI_13WORD_FRAME   0x00C0 << 1
.................... #define DCI_14WORD_FRAME   0x00D0 << 1
.................... #define DCI_15WORD_FRAME   0x00E0 << 1
.................... #define DCI_16WORD_FRAME   0x00F0 << 1
.................... 
.................... #define DCI_1WORD_INTERRUPT 0x0000
.................... #define DCI_2WORD_INTERRUPT 0x0400
.................... #define DCI_3WORD_INTERRUPT 0x0800
.................... #define DCI_4WORD_INTERRUPT 0x0C00
.................... 
.................... // Constants used in setup_dci() third param are:
.................... #define RECEIVE_NONE    0x0000
.................... #define RECEIVE_ALL     0xFFFF
.................... #define RECEIVE_SLOT0   0x0001
.................... #define RECEIVE_SLOT1   0x0002
.................... #define RECEIVE_SLOT2   0x0004
.................... #define RECEIVE_SLOT3   0x0008
.................... #define RECEIVE_SLOT4   0x0010
.................... #define RECEIVE_SLOT5   0x0020
.................... #define RECEIVE_SLOT6   0x0040
.................... #define RECEIVE_SLOT7   0x0080
.................... #define RECEIVE_SLOT8   0x0100
.................... #define RECEIVE_SLOT9   0x0200
.................... #define RECEIVE_SLOT10  0x0400
.................... #define RECEIVE_SLOT11  0x0800
.................... #define RECEIVE_SLOT12  0x1000
.................... #define RECEIVE_SLOT13  0x2000
.................... #define RECEIVE_SLOT14  0x4000
.................... #define RECEIVE_SLOT15  0x8000
.................... 
.................... // Constants used in setup_dci() forth param are:
.................... #define TRANSMIT_NONE   0x0000
.................... #define TRANSMIT_ALL    0xFFFF
.................... #define TRANSMIT_SLOT0  0x0001
.................... #define TRANSMIT_SLOT1  0x0002
.................... #define TRANSMIT_SLOT2  0x0004
.................... #define TRANSMIT_SLOT3  0x0008
.................... #define TRANSMIT_SLOT4  0x0010
.................... #define TRANSMIT_SLOT5  0x0020
.................... #define TRANSMIT_SLOT6  0x0040
.................... #define TRANSMIT_SLOT7  0x0080
.................... #define TRANSMIT_SLOT8  0x0100
.................... #define TRANSMIT_SLOT9  0x0200
.................... #define TRANSMIT_SLOT10 0x0400
.................... #define TRANSMIT_SLOT11 0x0800
.................... #define TRANSMIT_SLOT12 0x1000
.................... #define TRANSMIT_SLOT13 0x2000
.................... #define TRANSMIT_SLOT14 0x4000
.................... #define TRANSMIT_SLOT15 0x8000
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////// DMA
.................... // DMA Functions: setup_dma(), dma_start(), dma_status()
.................... // DMA Prototypes:
.................... _bif void setup_dma(unsigned int8 channel, unsigned int32 pheripheral, unsigned int8 mode);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 count);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 addressb);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 addressb, unsigned int16 count);
.................... _bif unsigned int8 dma_status(unsigned int8 channel);
.................... // Constants used in setup_dma() second param are:
.................... #define DMA_IN_SPI1      (0x0A0000|getenv("sfr:SPI1BUF"))
.................... #define DMA_OUT_SPI1     (0x8A0000|getenv("sfr:SPI1BUF"))
.................... #define DMA_IN_SPI2      (0x210000|getenv("sfr:SPI2BUF"))
.................... #define DMA_OUT_SPI2     (0xA10000|getenv("sfr:SPI2BUF"))
.................... #define DMA_IN_UART1     (0x0B0000|getenv("sfr:U1RXREG"))
.................... #define DMA_OUT_UART1    (0x8C0000|getenv("sfr:U1TXREG"))
.................... #define DMA_IN_UART2     (0x1E0000|getenv("sfr:U2RXREG"))
.................... #define DMA_OUT_UART2    (0x9F0000|getenv("sfr:U2TXREG"))
.................... #define DMA_IN_ADC1      (0x0D0000|getenv("sfr:ADC1BUF0"))
.................... ////////////////////////////////////////////////////////////////// DAC
.................... // Digital to Analog Functions: SETUP_DAC(), DAC_WRITE()
.................... // DAC Prototypes:
.................... _bif void setup_dac(unsigned int32 mode);
.................... _bif void setup_dac(unsigned int32 mode, unsigned int8 divisor);
.................... _bif void dac_write(unsigned int8 channel, unsigned value);
.................... // Constants used in SETUP_DAC() are:
.................... #define DAC_OFF  0
.................... #define DAC_RIGHT_ON   0x00808000
.................... #define DAC_LEFT_ON    0x80008000
.................... #define DAC_RIGHT_MIDPOINT 0x00A08000
.................... #define DAC_LEFT_MIDPOINT  0xA0008000
.................... #define DAC_SIGNED   0x100
.................... #define DAC_SLEEP_ON 0x1000
.................... #define DAC_IDLE_OFF 0x2000
.................... // Constants used as the first param in DAC_WRITE() are:
.................... #define DAC_DEFAULT  0
.................... #define DAC_RIGHT    1
.................... #define DAC_LEFT     2
.................... 
.................... #define DMA_IN_ECAN1     (0x220000|getenv("sfr:C1RXD"))
.................... #define DMA_OUT_ECAN1    (0xC60000|getenv("sfr:C1TXD"))
.................... #define DMA_INT0         0x000000 // or in direction and perif address
.................... #define DMA_IC1          0x010000 // or in direction and perif address
.................... #define DMA_IN_IC1       (0x010000|getenv("sfr:IC1BUF"))
.................... #define DMA_IC2          0x050000 // or in direction and perif address
.................... #define DMA_IN_IC2       (0x050000|getenv("sfr:IC2BUF"))
.................... #define DMA_OC1          0x020000 // or in direction and perif address
.................... #define DMA_OC2          0x060000 // or in direction and perif address
.................... #define DMA_TIMER2       0x070000 // or in direction and perif address
.................... #define DMA_TIMER3       0x080000 // or in direction and perif address
.................... #define DMA_OUT_DCI      (0xBC0000|getenv("sfr:TXBUF0"))
.................... #define DMA_IN_DCI       (0x3C0000|getenv("sfr:RXBUF0"))
.................... #define DMA_OUT_DACR     (0xCE0000|getenv("sfr:DAC1RDAT"))
.................... #define DMA_OUT_DACL     (0xCF0000|getenv("sfr:DAC1LDAT"))
.................... #define DMA_IN          0x00
.................... #define DMA_OUT         0x800000
.................... // Constants used in setup_dma() third param are:
.................... #define DMA_BYTE        0x40
.................... #define DMA_WORD        0x00  // default
.................... #define DMA_HALF_INT    0x10  // interrupt when half full
.................... #define DMA_WRITE_NULL  0x08
.................... // Constants used in dma_start() second param are:
.................... #define DMA_CONTINOUS   0x00
.................... #define DMA_ONE_SHOT    0x01
.................... #define DMA_PING_PONG   0x02
.................... #define DMA_NO_INC      0x10
.................... #define DMA_PERIF_ADDR  0x20 // Device supplies address
.................... #define DMA_FORCE_NOW  0x100
.................... // Constants returned from dma_status() are:
.................... #define DMA_IN_ERROR    0x01
.................... #define DMA_OUT_ERROR   0x02
.................... #define DMA_B_SELECT    0x04
.................... 
.................... ////////////////////////////////////////////////////////////////// BIF
.................... // Built In Functions Prototypes
.................... //
.................... // Math Prototypes:
.................... _bif signed int8 abs(signed int8 x);
.................... _bif signed int16 abs(signed int16 x);
.................... _bif signed int32 abs(signed int32 x);
.................... _bif float32 abs(float32 x);
.................... _bif unsigned int16 _mul(unsigned int8, unsigned int8);
.................... _bif signed int16 _mul(signed int8, signed int8);
.................... _bif unsigned int32 _mul(unsigned int16, unsigned int16);
.................... _bif signed int32 _mul(signed int16, signed int16);
.................... _bif signed int48 abs(signed int48 x);
.................... _bif signed int64 abs(signed int64 x);
.................... _bif float48 abs(float48 x);
.................... _bif float64 abs(float64 x);
.................... _bif unsigned int64 _mul(unsigned int32, unsigned int32);
.................... _bif signed int64 _mul(signed int32, signed int32);
.................... _bif unsigned int64 _mul(unsigned int48, unsigned int48);
.................... _bif signed int64 _mul(signed int48, signed int48);
.................... 
.................... // Memory Manipulation Prototypes:
.................... _bif void strcpy(char* dest, char* src);
.................... _bif void memset(unsigned int8* destination, unsigned int8 value, unsigned int16 num);
.................... _bif void memcpy(unsigned int8* destination, unsigned int8* source, unsigned int16 num);
.................... 
.................... // Data Manipulators Prototypes:
.................... _bif int1 shift_left(unsigned int8* address, unsigned int8 bytes, int1 value);
.................... _bif int1 shift_right(unsigned int8* address, unsigned int8 bytes, int1 value);
.................... _bif void rotate_left(unsigned int8* address, unsigned int8 bytes);
.................... _bif void rotate_right(unsigned int8* address, unsigned int8 bytes);
.................... _bif void swap(unsigned int8 value);
.................... _bif unsigned int8 make8(unsigned int16 var, unsigned int8 offset);
.................... _bif unsigned int8 make8(unsigned int32 var, unsigned int8 offset);
.................... _bif unsigned int16 make16(unsigned int8 varhigh, unsigned int8 varlow);
.................... _bif unsigned int32 make32(unsigned int16 var1);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int16 var2);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int8 var2);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int8 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int8 var3, unsigned int8 var4);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int16 var2);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int16 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int16 var3);
.................... _bif void bit_set(unsigned int8 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int16 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int32 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int8 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int16 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int32 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int8 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int16 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int32 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int48 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int64 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int48 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int64 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int48 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int64 var, unsigned int8 bit);
.................... _bif unsigned int8 bit_first(int1 value, unsigned int16 var);
.................... _bif unsigned int8 bit_last(int16 var);
.................... _bif unsigned int8 bit_last(int1 value, int16 var);
.................... 
.................... // #use delay() Prototypes:
.................... _bif void delay_cycles(unsigned int16 count);
.................... _bif void delay_ms(unsigned int16 time);
.................... _bif void delay_us(unsigned int16 time);
.................... 
.................... // #use rs232() Prototypes:
.................... _bif void putchar(char cdata);
.................... _bif void putchar(char cdata, unsigned int8 stream);
.................... _bif void puts(char* string);
.................... _bif void puts(char* string, unsigned int8 stream);
.................... _bif char getch(void);
.................... _bif char getch(unsigned int8 stream);
.................... _bif void gets(char* string);
.................... _bif void gets(char* string, unsigned int8 stream);
.................... _bif int1 kbhit(void);
.................... _bif int1 kbhit(unsigned int8 stream);
.................... _bif void printf(char* string, ...);
.................... _bif void fprintf(unsigned int8 stream, char* string, ...);
.................... _bif void putc_send(void);
.................... _bif void fputc_send(unsigned int8 stream);
.................... _bif int1 rcv_buffer_full(void);
.................... _bif int1 rcv_buffer_full(unsigned int8 stream);
.................... _bif unsigned int16 rcv_buffer_bytes(void);
.................... _bif unsigned int16 rcv_buffer_bytes(unsigned int8 stream);
.................... _bif int1 tx_buffer_full(void);
.................... _bif int1 tx_buffer_full(unsigned int8 stream);
.................... _bif unsigned int16 tx_buffer_bytes(void);
.................... _bif unsigned int16 tx_buffer_bytes(unsigned int8 stream);
.................... 
.................... // #use i2c() Prototypes:
.................... _bif unsigned int8 i2c_read(void);
.................... _bif unsigned int8 i2c_read(unsigned int8 stream);
.................... _bif unsigned int8 i2c_read(unsigned int8 stream, int1 ack);
.................... _bif int1 i2c_write(unsigned int8 data);
.................... _bif int1 i2c_write(unsigned int8 stream, unsigned int8 data);
.................... _bif void i2c_start(void);
.................... _bif void i2c_start(unsigned int8 stream);
.................... _bif void i2c_start(unsigned int8 stream, unsigned int8 restart);
.................... _bif void i2c_stop(void);
.................... _bif void i2c_stop(unsigned int8 stream);
.................... _bif int8 i2c_isr_state(void);
.................... _bif void i2c_slaveaddr(unsigned int8 addr);
.................... _bif void i2c_slaveaddr(unsigned int8 stream, unsigned int8 addr);
.................... _bif int1 i2c_poll(void);
.................... _bif int1 i2c_poll(unsigned int8 stream);
.................... _bif void i2c_init(unsigned int32 baud);
.................... _bif void i2c_init(unsigned int8 stream, unsigned int32 baud);
.................... 
.................... // #use spi() Prototypes:
.................... _bif unsigned int8 spi_xfer(void);
.................... _bif unsigned int16 spi_xfer(void);
.................... _bif unsigned int32 spi_xfer(void);
.................... _bif unsigned int8 spi_xfer(unsigned int8 data);
.................... _bif unsigned int16 spi_xfer(unsigned int16 data);
.................... _bif unsigned int32 spi_xfer(unsigned int32 data);
.................... _bif unsigned int8 spi_xfer(unsigned int8 stream, unsigned int8 data);
.................... _bif unsigned int16 spi_xfer(unsigned int8 stream, unsigned int16 data);
.................... _bif unsigned int32 spi_xfer(unsigned int8 stream, unsigned int32 data);
.................... _bif unsigned int8 spi_xfer(unsigned int8 stream, unsigned int8 data, unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer(unsigned int8 stream, unsigned int16 data, unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer(unsigned int8 stream, unsigned int32 data, unsigned int8 bits);
.................... _bif void spi_init(unsigned int32 baud);
.................... _bif void spi_init(unsigned int8 stream, unsigned int32 baud);
.................... _bif void spi_speed(unsigned int32 baud);
.................... _bif void spi_speed(unsigned int8 stream, unsigned int32 baud);
.................... _bif void spi_speed(unsigned int8 stream, unsigned int32 baud, unsigned int32 clock);
.................... _bif void spi_prewrite(unsigned int8 data);
.................... _bif void spi_prewrite(unsigned int16 data);
.................... _bif void spi_prewrite(unsigned int32 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int8 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int16 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int32 data);
.................... _bif unsigned int8 spi_xfer_in(void);
.................... _bif unsigned int16 spi_xfer_in(void);
.................... _bif unsigned int32 spi_xfer_in(void);
.................... _bif unsigned int8 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int8 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... 
.................... // #use rtos() Prototypes:
.................... _bif void rtos_run(void);
.................... _bif void rtos_yield(void);
.................... _bif void rtos_enable(unsigned int8 task);
.................... _bif void rtos_disable(unsigned int8 task);
.................... _bif void rtos_terminate(void);
.................... _bif void rtos_await(int1 flag);
.................... _bif void rtos_wait(unsigned int8 sem);
.................... _bif void rtos_signal(unsigned int8 sem);
.................... _bif void rtos_msg_send(unsigned int8 task, unsigned int8 msg);
.................... _bif unsigned int8 rtos_msg_read(void);
.................... _bif unsigned int8 rtos_msg_poll(void);
.................... _bif int1 rtos_overrun(unsigned int8 task);
.................... _bif void rtos_stats(unsigned int8 task, unsigned int8* stat);
.................... 
.................... // #use timer() Prototypes:
.................... _bif unsigned int8 get_ticks(void);
.................... _bif unsigned int16 get_ticks(void);
.................... _bif unsigned int32 get_ticks(void);
.................... _bif unsigned int64 get_ticks(void);
.................... _bif unsigned int8 get_ticks(unsigned int8 stream);
.................... _bif unsigned int16 get_ticks(unsigned int8 stream);
.................... _bif unsigned int32 get_ticks(unsigned int8 stream);
.................... _bif unsigned int64 get_ticks(unsigned int8 stream);
.................... _bif void set_ticks(unsigned int8 value);
.................... _bif void set_ticks(unsigned int16 value);
.................... _bif void set_ticks(unsigned int32 value);
.................... _bif void set_ticks(unsigned int64 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int8 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int16 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int32 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int64 value);
.................... 
.................... // #use pwm() Prototypes:
.................... _bif void pwm_on(void);
.................... _bif void pwm_on(unsigned int8 stream);
.................... _bif void pwm_off(void);
.................... _bif void pwm_off(unsigned int8 stream);
.................... _bif void pwm_set_duty(unsigned int16 duty);
.................... _bif void pwm_set_duty(unsigned int8 stream, unsigned int16 duty);
.................... _bif void pwm_set_duty_percent(unsigned int16 percent);
.................... _bif void pwm_set_duty_percent(unsigned int8 stream, unsigned int16 percent);
.................... _bif void pwm_set_frequency(unsigned int32 frequency);
.................... _bif void pwm_set_frequency(unsigned int8 stream, unsigned int32 frequency);
.................... 
.................... // #use capture() Prototypes:
.................... _bif unsigned int16 get_capture_time(void);
.................... _bif unsigned int16 get_capture_time(unsigned int8 stream);
.................... _bif int1 get_capture_event(void);
.................... _bif int1 get_capture_event(unsigned int8 stream);
.................... 
.................... // Environment Prototypes:
.................... //_bif unsigned int8 getenv(char* cstring);
.................... 
.................... // Address Prototypes:
.................... #ifndef __ADDRESS__
.................... #define __ADDRESS__ unsigned int32
.................... #endif
.................... _bif void goto_address(__ADDRESS__ address);
.................... _bif __ADDRESS__ label_address(__ADDRESS__ label);
.................... 
.................... // Program Memory Prototypes:
.................... _bif void read_program_memory(__ADDRESS__ address, unsigned int8* dataptr, unsigned int16 count);
.................... _bif void erase_program_memory(__ADDRESS__ address);
.................... _bif void write_program_memory(__ADDRESS__ address, unsigned int8* dataptr, unsigned int16 count);
.................... _bif void read_configuration_memory(unsigned int8* dataptr, unsigned int8 count);
.................... _bif void write_configuration_memory(unsigned int8* dataptr, unsigned int8 count);
.................... 
.................... ////////////////////////////////////////////////////////////////// INT
.................... // Interrupt Functions: ENABLE_INTERRUPTS(), DISABLE_INTERRUPTS(),
.................... //                      CLEAR_INTERRUPT(), INTERRUPT_ACTIVE(),
.................... //                      EXT_INT_EDGE()
.................... // INT Prototypes:
.................... _bif void enable_interrupts(unsigned int16 interrupt);
.................... _bif void disable_interrupts(unsigned int16 interrupt);
.................... _bif void clear_interrupt(unsigned int16 interrupt);
.................... _bif int1 interrupt_active(unsigned int16 interrupt);
.................... _bif int1 interrupt_enabled(unsigned int16 interrupt);
.................... _bif void ext_int_edge(unsigned int8 source, unsigned int8 edge);
.................... _bif void jump_to_isr(unsigned int16 address);
.................... // Constants used in EXT_INT_EDGE() are:
.................... #define L_TO_H              0x40
.................... #define H_TO_L                 0
.................... //
.................... // Constants used in other interrupt functions are:
.................... #define INTR_GLOBAL               0x400
.................... #define GLOBAL                    0x400  // For compatibility with PIC16/18
.................... #define INTR_NORMAL               0x100
.................... #define INTR_ALTERNATE            0x200
.................... #define INTR_LEVEL0               0x500
.................... #define INTR_LEVEL1               0x501
.................... #define INTR_LEVEL2               0x502
.................... #define INTR_LEVEL3               0x503
.................... #define INTR_LEVEL4               0x504
.................... #define INTR_LEVEL5               0x505
.................... #define INTR_LEVEL6               0x506
.................... #define INTR_LEVEL7               0x507
.................... 
.................... #define INTR_CN_PIN              0x8000  // or in a PIN_xx constant
.................... 
.................... #define INT_OSCFAIL               1
.................... #define INT_ADDRERR               2
.................... #define INT_STACKERR              3
.................... #define INT_MATHERR               4
.................... #define INT_DMAERR                5
.................... #define INT_EXT0                  6
.................... #define INT_IC1                   7
.................... #define INT_OC1                   8
.................... #define INT_TIMER1                9
.................... #define INT_DMA0                  69
.................... #define INT_IC2                   70
.................... #define INT_OC2                   71
.................... #define INT_TIMER2                72
.................... #define INT_TIMER3                73
.................... #define INT_SPI1E                 74
.................... #define INT_SPI1                  75
.................... #define INT_RDA                   76
.................... #define INT_TBE                   77
.................... #define INT_ADC1                  78
.................... #define INT_DMA1                  79
.................... #define INT_SI2C                  81
.................... #define INT_MI2C                  82
.................... #define INT_CNI                   84
.................... #define INT_EXT1                  85
.................... #define INT_IC7                   87
.................... #define INT_IC8                   88
.................... #define INT_DMA2                  89
.................... #define INT_OC3                   90
.................... #define INT_OC4                   91
.................... #define INT_TIMER4                92
.................... #define INT_TIMER5                93
.................... #define INT_EXT2                  94
.................... #define INT_RDA2                  95
.................... #define INT_TBE2                  96
.................... #define INT_SPI2E                 97
.................... #define INT_SPI2                  98
.................... #define INT_C1RX                  99
.................... #define INT_CAN1                  100
.................... #define INT_DMA3                  101
.................... #define INT_PWM1                  110
.................... #define INT_DMA4                  111
.................... #define INT_QEI                   123
.................... #define INT_DMA5                  126
.................... #define INT_PWM2                  127
.................... #define INT_FAULTA                128
.................... #define INT_UART1E                130
.................... #define INT_UART2E                131
.................... #define INT_QEI2                  132
.................... #define INT_DMA6                  133
.................... #define INT_DMA7                  134
.................... #define INT_C1TX                  135
.................... #define INT_FAULTA2               139
.................... #define INT_COMP                  152
.................... #define INT_PMP                   164
.................... #define INT_RTC                   173
.................... #define INT_CRC                   174
.................... #define INT_DAC1R                 177
.................... #define INT_DAC1L                 178
.................... 
.................... #list
.................... 
.................... #endif
.................... 
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... #WORD ADC1BUF0 = 0x0300;
.................... #WORD ADC1CON1 = 0x0320;
.................... #WORD ADC1CON2 = 0x0322;
.................... #WORD ADC1CON3 = 0x0324;
.................... #WORD AD1CHS0 = 0x0328;
.................... #WORD AD1PCFGL = 0x032C;
.................... #WORD IFS0 = 0x0084;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "lcd.h"
.................... /**
....................  @file    lcd.h
....................  @author  Ricardo Gï¿½mez
....................  @brief   LCD management
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __LCD_H
.................... #define __LCD_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... /* SECTION 1: Included header files to compile this file           */
.................... 
.................... /* SECTION 2: Public macros                                        */
.................... 
.................... #define _CLEAR_DISPLAY 				0x01
.................... #define _8BIT_4LINES_NORMAL_RE1_IS0		0x3A
.................... #define _8BIT_4LINES_REVERSE_RE1_IS0		0x3B
.................... #define _8BIT_4LINES_RE0_IS1			0x39
.................... #define _8BIT_4LINES_RE0_IS0			0x38
.................... 
.................... #define _BS1_1					0x1E
.................... #define _POWER_DOWN_DISABLE			0x02
.................... #define _SEGMENT_NORMAL_WAY			0x05
.................... #define _NW					0x09
.................... 
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_ON		0x0F
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_OFF		0x0E
.................... #define _DISPLAY_ON_CURSOR_OFF_BLINK_OFF	0x0C
.................... #define _BS0_1					0x1C
.................... #define _INTERNAL_DIVIDER			0x13
.................... #define _CONTRAST				0x77
.................... #define _POWER_ICON_CONTRAST			0x5C
.................... #define _FOLLOWER_CONTROL			0x6E
.................... 
.................... #define ADDRESS_DDRAM				0x80
.................... 
.................... 
.................... /* SECTION 3: Public types                                         */
.................... 
.................... 
.................... /* SECTION 4: Public variables :: declarations, extern mandatory   */
.................... 
.................... 
.................... /* SECTION 5: Public functions :: declarations, extern optional
....................    Rule exception (callbacks)  :: declarations, extern recommended */
.................... void display_valueADC_title(void);
.................... void LCD_command(unsigned int8);
.................... void lcdi2cinit(void);
.................... void LCD_write(char*);
.................... void initmenu(void);                                      //Inicializa el menu principal
.................... void display_frecuencia(void);       // Muestra frecuencia
.................... void LCD_cursor_at(unsigned int8 line, unsigned int8 column);
.................... void display_alarma_alto(void); // Limpia pantalla y escribe mensaje de alarma
.................... void display_alarma_bajo(void);
.................... void display_final(void);
.................... 
.................... 
.................... #endif // __LCD_H
.................... // Do not write below this line!
.................... 
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... #include "algoritmo.h"
.................... /**
....................  @file    ALGORITMO.h
....................  @author  Ricardo Gomez, Klaudija Ziliute
....................  @brief   PanTompkins header file
.................... */
.................... 
.................... 
.................... #ifndef __ALGORITMO_H
.................... #define __ALGORITMO_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... 
.................... #WORD ADC1BUF0 = 0x0300;
.................... #WORD ADC1CON1 = 0x0320;
.................... #WORD ADC1CON2 = 0x0322;
.................... #WORD ADC1CON3 = 0x0324;
.................... #WORD AD1CHS0 = 0x0328;
.................... #WORD AD1PCFGL = 0x032C;
.................... #WORD IFS0 = 0x0084;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "BEEP.h"
.................... /**
....................  @file    BEEP.h
....................  @author  Julio Gomis-Tena
....................  @brief   Generate n "beeps" of variable frequency
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __BEEP_H
.................... #define __BEEP_H
.................... #include "Header.h"
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #pin_select OC2 = BUZZER
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void); //Inicializa las frecuencias de los beeps y la separaciÃ³n entre ellos
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP(unsigned int8); //Realiza n beeps
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __BEEP_H
.................... 
.................... 
.................... 
.................... int algoritmo(void);
.................... void init_algoritmo(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ALGORITMO_H
.................... 
.................... #include "SD_Card.h"
.................... /**
....................  @file    SD_CARD.h
....................  @author  Ricardo Gomez, Klaudija Ziliute
....................  @brief   PanTompkins header file
.................... */
.................... 
.................... 
.................... #ifndef __SD_CARD_H
.................... #define __SD_CARD_H
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... #include "miFAT.h"
.................... 
.................... #ifndef __MIFAT_H
.................... #define __MIFAT_H
.................... // Definidos en sdcard.h - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... extern unsigned int8 dt[512];
.................... extern unsigned int32 LBA0;
.................... extern unsigned int8 sd_init();
.................... extern unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr);
.................... extern unsigned int8 sd_read_block( unsigned int32 address, unsigned char* ptr);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define MAX_ENTRIES_SECTOR_FAT16        256
.................... #define ENDFILE16                    0xFFFF
.................... #define MAX_ENTRIES_SECTOR_FAT32        128
.................... #define ENDFILE32                0x0FFFFFFF
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... typedef struct{
.................... 	union{
.................... 		unsigned int8 raw[32];
.................... 		struct fields{
.................... 			char name[8];
.................... 			char extension[3];
.................... 			unsigned int8 attrib;			///sï¿½lo lectura, oculto, de sistema, directorio...
.................... 			//unsigned int8 reserved[10];
.................... 			  unsigned int8  reserved;
.................... 	 		  unsigned int8  createTimeMs;
.................... 			  unsigned int16 create_hour;
.................... 			  unsigned int16 create_date;
.................... 			  unsigned int16 last_access;
.................... 			  unsigned int16 eaIndex;
.................... 			  unsigned int16 modif_hour;
.................... 			  unsigned int16 modif_date;
.................... 			  unsigned int16 first_cluster;	///primer cluster (direcciona tabla FAT y sector para escribir contenido)
.................... 			  unsigned int32 size;			///tamaï¿½o en bytes
.................... 		};
.................... 	};
.................... } fileEntry;
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... typedef struct{
.................... 	unsigned int32 currentCluster;
.................... 	unsigned int32 currentSector;
.................... 	unsigned int16 posInSector;      //posiciï¿½n actual al escribir en el sector
.................... 	unsigned int32 sectorAtFAT;      //sector de la 1ï¿½ FAT en el que tenemos el actual puntero de cierre de fichero
.................... 
.................... 	unsigned int32 sectorEntryFile; //direcciï¿½n del sector de entradas de fichero
.................... 	unsigned int8  EntryFile[512];  //sector donde estï¿½ la entrada (root) del fichero (para actualizar tamaï¿½o)
.................... 	unsigned int16 offsetEntry;     //offset en el sector de entradas del fichero
.................... 	unsigned int32 size;            //tamaï¿½o del fichero
.................... }_file;
.................... 
.................... _file file;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... typedef struct _diskinforec{
....................    unsigned int8  jmpBoot[3];   // bytes  0.. 2: Salto a la rutina de arranque
....................    unsigned int8  OEMName[8];   // bytes  3..10: Es una cadena "MSDOS5.0"
....................    unsigned int16 BytsPerSec;   // bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes)
....................    unsigned int8  SectPerClus;  // byte  13:    Numero de sectores contenidos en 1 cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes
....................    unsigned int16 RsrvdCnt;     // bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente
....................    unsigned int8  NumFATs;      // byte  16:    Numero de tablas FAT en el volumen. Habitualmente es 2
....................    unsigned int16 RootEntCnt;   // bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
....................    unsigned int16 TotSect16;    // bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0)
....................    unsigned int8  Media;        // byte  21:    Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0
....................    unsigned int16 FATsz16;      // bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0)
....................    unsigned int16 SectPerTrack; // bytes 24..25: Sectores por track
....................    unsigned int16 NumHeads;     // bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.)
....................    unsigned int32 HiddSec;      // bytes 28..31: Sectores ocultos que preceden a la particion (irrelevante en uSD)
....................    unsigned int32 TotSect32;    // bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta
....................    unsigned int32 FATsz32;      // bytes 36..39: Numero de sectores ocupados por una FAT
....................    unsigned int16 ExtFlags;     // bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0)
....................    unsigned int16 FSVer;        // bytes 42..43: Version del sistema de archivos (empleamos la 0.0)
....................    unsigned int32 RootClus;     // bytes 44..47: Indica el numero del 1er cluster del directorio raiz.
....................    unsigned int16 FSInfo;       // bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1)
....................    unsigned int16 BkBootSec;    // bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque
....................    unsigned int8  RsrvdSys[12]; // bytes 52..63: Bytes reservados para futuros usos del sistema
....................    unsigned int8  DrvNum;       // byte  64:     Numero de la unidad (para MSDOS pero irrelevante en uSD).
....................    unsigned int8  Reserved1;    // byte  65:     Windows NT para formatear un volumen pone este byte a 0
....................    unsigned int8  BootSig;      // byte  66:     Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows)
....................    unsigned int32 VolId;        // bytes 67..70: Numero de volumen (generado por el reloj del sistema).
....................    unsigned int8  VolLab[11];   // bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME     ". Nosotros podemos poner "NUUBO_SD    "
....................    unsigned int8  FilSysType[8];// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   "
....................    unsigned int8  spam[420];    // bytes 90..509:Zona de codigo (no lo empleamos y esta a 0)
....................    unsigned int16 firma;        // byte 510..511:Debe de vale 55 AA
.................... } diskinforec;
.................... 
.................... diskinforec DiskInfo;
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned  int8 FATType; // FAT16 o FAT32
.................... //variables clave: inicio de la FAT1 y la FAT2 y de las entradas de ficheros
.................... unsigned  int8 sect_x_cluster;
.................... unsigned int16 sect_fat_1;
.................... unsigned int16 sect_fat_2;
.................... unsigned int32 sect_ini_datos;
.................... unsigned int32 sect_x_fat;
.................... unsigned int32 sect_entry;
.................... unsigned int16 sect_reserv;
.................... 
.................... //unsigned int8 dFil[32];
.................... unsigned int32 sector_fat32[MAX_ENTRIES_SECTOR_FAT32]; // 128 x 4 = 512
.................... unsigned int16 sector_fat16[MAX_ENTRIES_SECTOR_FAT16]; // 256 x 2 = 512
.................... 
.................... //atributos
.................... #define __FILE		0x20
.................... #define _DIRECTORY	0x10
.................... #define _VOLUMEN	0x08
.................... #define _SYSTEM		0x04
.................... #define _HIDDEN		0x02
.................... #define READONLY	0x01
.................... 
.................... ///variables globales
.................... unsigned int16 year = 2020;
.................... unsigned int8 yearLo=   20;
.................... unsigned int8 month =   10;
.................... unsigned int8 day   =	15;
.................... unsigned int8 hour	=   12;
.................... unsigned int8 minute=   34;
.................... unsigned int8 second=   56;
.................... 
.................... ///funciones
.................... #define getHour() (int16)((int16)hour << 11) + (int16)((int16)minute << 5) + (int16) (second >> 1)		//5 bits: horas, 6 bits: minutos, 5 bits: segundos/2
.................... #define getDate() (((int16)year - 1980) << 9 ) + ((int16)month << 5) + (int16)day	//7 bits: aï¿½o (desde 1980), 4 bits: mes, 5 bits: dia
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... void initFAT(){
....................    unsigned int32 startClusterOfRootDirectory = 2;
....................    unsigned int32 sctrs;
....................    unsigned  int8 *ptrSct;
....................    diskinforec *ptrDiskInfo;
.................... 
.................... 	sd_read_block(LBA0, dt);
....................     						ptrDiskInfo=&DiskInfo;
....................     						ptrSct= &dt[0];
....................    	memcpy((*ptrDiskInfo).jmpBoot, (ptrSct +  0), 3); 			//DiskInfo.jmpBoot[3]	// bytes  0.. 2: Salto a la rutina de arranque
....................    	memcpy((*ptrDiskInfo).OEMName, (ptrSct +  3), 8); 			//DiskInfo.OEMName[8]	// bytes  3..10: Es una cadena, habitualmente "MSDOS5.0"
....................    	DiskInfo.BytsPerSec = make16(dt[12],dt[11]);   				// bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes)
.................... 	DiskInfo.SectPerClus = dt[13];								// byte  13:	 Numero de sectores contenidos en un cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes
.................... 	DiskInfo.RsrvdCnt = make16(dt[15],dt[14]);					// bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente
....................    	DiskInfo.NumFATs = dt[16];									// byte  16:	 Numero de tablas FAT en el volumen. Habitualmente es 2
.................... 	DiskInfo.RootEntCnt = make16(dt[18],dt[17]);				// bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
....................    	DiskInfo.TotSect16 = make16(dt[20],dt[19]);					// bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0)
.................... 	DiskInfo.Media = dt[21];									// byte  21:	 Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0
.................... 	DiskInfo.FATsz16 = make16(dt[23],dt[22]);					// bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0)
.................... 	DiskInfo.SectPerTrack = make16(dt[25],dt[24]); 				// bytes 24..25: Sectores por track
....................    	DiskInfo.NumHeads = make16(dt[27],dt[26]);					// bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.)
.................... 	DiskInfo.HiddSec = make32(dt[31],dt[30],dt[29],dt[28]);		// bytes 28..31: Sectores ocultos que preceden a la particion
.................... 	DiskInfo.TotSect32=make32(dt[35],dt[34],dt[33],dt[32]);		// bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta
.................... 	DiskInfo.FATsz32 = make32(dt[39],dt[38],dt[37],dt[36]);		// bytes 36..39: Numero de sectores ocupados por una FAT
.................... 	DiskInfo.ExtFlags = make16(dt[41],dt[40]); 					// bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0)
.................... 	DiskInfo.FSVer = make16(dt[43],dt[42]); 					// bytes 42..43: Version del sistema de archivos (empleamos la 0.0)
.................... 	DiskInfo.RootClus= make32(dt[47],dt[46],dt[45],dt[44]);		// bytes 44..47: Indica el numero del 1er cluster del directorio raiz.
.................... 	DiskInfo.FSInfo = make16(dt[49],dt[48]); 					// bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1)
.................... 	DiskInfo.BkBootSec = make16(dt[51],dt[50]); 				// bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque
.................... 	//  Estructura en el caso de FAT32 ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½
.................... 	memcpy((*ptrDiskInfo).RsrvdSys, (ptrSct +  52), 12);		//DiskInfo.RsrvdSys[12] 	// bytes 52..63: Bytes reservados para futuros usos del sistema
.................... 	DiskInfo.DrvNum = dt[64];								 	// byte  64: 	 Numero de la unidad
.................... 	DiskInfo.Reserved1 = dt[65];								// byte  65: 	 Windows NT para formatear un volumen pone este byte a 0
.................... 	DiskInfo.BootSig = dt[66]; 									// byte  66: 	 Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows)
.................... 	DiskInfo.VolId = make32(dt[70],dt[69],dt[68],dt[67]); 		// bytes 67..70: Numero de volumen (generado por el reloj del sistema).
.................... 	memcpy((*ptrDiskInfo).VolLab, (ptrSct +  71), 11);			//DiskInfo.VolLab[11]	// bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME    "
.................... 	memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  82), 8);		//DiskInfo.FilSysType[8] 	// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   "
.................... 	memcpy((*ptrDiskInfo).spam, (ptrSct +  90),420);			//DiskInfo.spam[420]		// bytes 90..509:Zona de codigo (en uSD no se emplea y suele estar a 0)
.................... 	DiskInfo.firma = make16(dt[510],dt[511]);								// byte 510..511:Debe de vale 55 AA
.................... 
....................    		FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'3''2'
.................... 
....................    if(FATType == 32){
.................... 						sect_x_fat  = DiskInfo.FATsz32;		// Sectores reservados para la FAT
.................... 						startClusterOfRootDirectory = DiskInfo.RootClus;
....................  	}else{
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);	//DiskInfo.FilSysType[8] 	// bytes 54..61: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT16   "
.................... 						FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'1''6'
.................... 	}
.................... 
.................... 	if(FATType == 16){
.................... 						DiskInfo.VolId = make32(dt[42],dt[41],dt[40],dt[39]);
.................... 						memcpy((*ptrDiskInfo).VolLab, (ptrSct +  43), 11);
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);
.................... 
.................... 						sect_x_fat  = DiskInfo.FATsz16;		// Sectores reservados para la FAT
.................... 						startClusterOfRootDirectory = DiskInfo.RootEntCnt;
....................  					}
.................... 
....................   	sect_x_cluster = DiskInfo.SectPerClus;					// Cada cluster tiene este numero de sectores
.................... 
....................     			      sctrs  = LBA0;
.................... 				  	  sctrs += DiskInfo.RsrvdCnt;
.................... 	sect_reserv 	= sctrs;								// sectores reservados por el sistema
.................... 
....................     sect_fat_1  	= sctrs;               					// A partir de ahï¿½: FAT 1
.................... 				  	  sctrs += sect_x_fat;
.................... 	sect_fat_2  	= sctrs;;								// A partir de ahï¿½: FAT 2 (copia de seguridad)
.................... 				  	  sctrs += sect_x_fat;
.................... 	sect_entry  	= sctrs ;      							// A partir de ahï¿½ empieza el raï¿½z (la lista de ficheros)
.................... 					  sctrs += sect_x_cluster;
.................... 	sect_ini_datos 	= sctrs ;								// A partir de ahi los datos del fichero
.................... 
....................     if(FATType == 16)										// RootEntCnt: Numero de entradas de 32 bytes al
....................     sect_ini_datos = sect_entry+(DiskInfo.RootEntCnt>>4);	// directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
.................... 
.................... }//fin initFAT()
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void cargaConfig(unsigned int32 j);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... // unsigned int8 encontrar_fichero(){
.................... //    unsigned int8 FicheroEncontrado = 0;
.................... //    unsigned int32 i;
.................... //    unsigned int16 j;
.................... //    unsigned int32 SctStart = sect_entry;			//inicio Root
.................... //    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root
.................... //    unsigned int32 ClstIni  = ((FATType==16)?1:2);
.................... //
.................... //    unsigned int32 ClstNxt;
.................... //    unsigned int32 sctrClstr;
.................... //    unsigned int32 posSctr;
.................... //    unsigned int32 clstrSig;
.................... //
.................... //    for(i = SctStart; i < SctEnd; i++){
.................... // 	      sd_read_block(i, dt);
.................... // 		 for(j = 0; j < 512; j += 32){
.................... // 										if(	(dt[j + 0] == 'C')&&
.................... // 											(dt[j + 1] == 'O')&&
.................... // 											(dt[j + 2] == 'N')&&
.................... // 											(dt[j + 3] == 'F')&&
.................... // 											(dt[j + 4] == 'I')&&
.................... // 											(dt[j + 5] == 'G')&&
.................... // 											(dt[j + 6] == ' ')&&
.................... // 											(dt[j + 7] == ' ')&&
.................... // 											(dt[j + 8] == 'T')&&
.................... // 											(dt[j + 9] == 'X')&&
.................... // 											(dt[j + 10]== 'T')){
.................... // 																 cargaConfig(j);
.................... // 																 FicheroEncontrado = 1;
.................... // 																 return FicheroEncontrado;
.................... // 																}//fin if(CNF)
.................... //
.................... // 		}//j
.................... //    }//i
.................... //    return FicheroEncontrado;
.................... // } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void cargaConfig(unsigned int32 j){
....................    unsigned int32 direccion;
....................    unsigned int32 _sector;
.................... 
.................... 	if(FATType==16){
.................... 	   	direccion = make32(0,0,dt[j+27],dt[j+26]);
.................... 		_sector = ((unsigned int32)direccion - 2) * sect_x_cluster + sect_ini_datos;
.................... 	}
.................... 	if(FATType==32){
.................... 	   direccion = make32(dt[j+21],dt[j+20],dt[j+27],dt[j+26]); //en FAT32 se usa EAIndex + first cluster
.................... 	   _sector = ((unsigned int32)direccion - 3) * sect_x_cluster + sect_ini_datos;
....................    }
....................    sd_read_block(_sector, dt); //leer el primer sector de los datos del fichero
.................... 
....................    // Ahora en el vector dt tengo los datos del fichero y puedo emplearlo
....................    // Por ejemplo: el texto que indica la hora y minutos del ensayo lo obtendria como:
....................    // hora   = (dt[140]-'0')*10 + dt[141]-'0' ;
....................    // minutos= (dt[143]-'0')*10 + dt[144]-'0' ;
....................    // ... Y con esos datos haria algo util
.................... 
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 inicializa_fichero(){
....................    unsigned int8 FicheroIncializado = 0;
....................    unsigned int32 i;
....................    unsigned int16 j;
....................    unsigned int32 SctStart = sect_entry;			//inicio Root
....................    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root
....................    unsigned int32 ClstIni  = ((FATType==16)?0:1);
.................... 
....................    unsigned int32 ClstNxt;
....................    unsigned int32 sctrClstr;
....................    unsigned int32 posSctr;
....................    unsigned int32 clstrSig;
.................... 
....................    unsigned int32 startCluster;      //cluster donde empezarï¿½an los datos del fichero
....................    fileEntry newFile;
.................... 
....................    for(i = SctStart; i < SctEnd; i++){
.................... 	      sd_read_block(i, dt);
.................... 		  for(j = 0; j < 512; j += 32){
.................... 			if((dt[j] == 0x00) || dt[j] == 0xFF){
.................... 					   newFile.fields.name[0] = 		'L';
.................... 					   newFile.fields.name[1] = 		'A';
.................... 					   newFile.fields.name[2] = 		'T';
.................... 					   newFile.fields.name[3] = 		'I';
.................... 					   newFile.fields.name[4] = 		'D';
.................... 					   newFile.fields.name[5] = 		'O';
.................... 					   newFile.fields.name[6] = 		'S';
.................... 					   newFile.fields.name[7] = 		'_';
.................... 					   newFile.fields.extension[0] = 	'T';
.................... 					   newFile.fields.extension[1] = 	'X';
.................... 					   newFile.fields.extension[2] = 	'T';
.................... 					   newFile.fields.reserved = 0;
.................... 					   newFile.fields.createTimeMs = 0;
.................... 					   newFile.fields.create_hour = getHour();
.................... 					   newFile.fields.create_date = getDate();
.................... 					   newFile.fields.last_access = newFile.fields.create_date;
.................... 					   newFile.fields.eaIndex = 0;
.................... 					   newFile.fields.attrib = __FILE | READONLY;   //archivo normal + sï¿½lo lectura
.................... 					   newFile.fields.modif_hour = newFile.fields.create_hour;
.................... 					   newFile.fields.modif_date = newFile.fields.create_date;
.................... 					   newFile.fields.first_cluster = 0;
.................... 					   newFile.fields.size = 0;
.................... 
.................... 					   file.offsetEntry = j;
.................... 					   file.sectorEntryFile = i;
.................... 					   sd_read_block(file.sectorEntryFile, file.EntryFile);
.................... 
.................... 					   for(i = 0; i < 32; j++, i++)  dt[j] = newFile.raw[i];
.................... 					   for(i = 0; i < 512; i++)      file.EntryFile[i] = dt[i];
.................... 					   file.posInSector    = 0;   															//empezamos en un sector y cluster nuevos
.................... 					   if(FATType==16){
.................... 					   startCluster = encontrarCluster(2);         											//busco cluster donde empezarï¿½a a almacenarse los datos
.................... 					   file.currentCluster = startCluster;   												//que serï¿½ el cluster en el que escribiremos
.................... 					   file.currentSector  = (file.currentCluster -  2) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster)
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 8) + sect_reserv;						//sector en la FAT donde marcar el cluster usado
.................... 					   }
.................... 					   if(FATType==32){
.................... 					   startCluster = encontrarCluster(3);         											//busco cluster donde empezarï¿½a a almacenarse los datos
.................... 					   file.currentCluster = startCluster;   												//que serï¿½ el cluster en el que escribiremos
.................... 					   file.currentSector  = (file.currentCluster -  3) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster)
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 7) + sect_reserv;						//sector en la FAT donde marcar el cluster usado
.................... 					   }
.................... 					   file.EntryFile[file.offsetEntry + 27] = make8(file.currentCluster, 1); 					//1er cluster del archivo
.................... 					   file.EntryFile[file.offsetEntry + 26] = make8(file.currentCluster, 0);
.................... 					   file.EntryFile[file.offsetEntry + 21] = make8(file.currentCluster, 3);
.................... 					   file.EntryFile[file.offsetEntry + 20] = make8(file.currentCluster, 2);
.................... 					   file.size = 0;																			//Inicialmente el tamaï¿½o es cero
.................... 
.................... 					   if(FATType==16){
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile);
.................... 						sd_read_block (file.sectorAtFAT, sector_fat16);
.................... 						sector_fat16[file.currentCluster % MAX_ENTRIES_SECTOR_FAT16] = ENDFILE16;				//marco el cluster como usado
.................... 						sd_write_block( file.sectorAtFAT, sector_fat16);
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat16);   //FAT2					//ï¿½Ojo! la cosa puede ser mas complicada...
.................... 						}
.................... 					   if(FATType==32){
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile);
.................... 						sd_read_block (file.sectorAtFAT,sector_fat32);
.................... 						sector_fat32[file.currentCluster % MAX_ENTRIES_SECTOR_FAT32] = ENDFILE32;				//marco el cluster como usado
.................... 						sd_write_block( file.sectorAtFAT, sector_fat32);
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat32);   //FAT2					//ï¿½Ojo! la cosa puede ser mas complicada...
.................... 						}
.................... 					   FicheroIncializado = 1;
.................... 					   return FicheroIncializado;
.................... 					   }
.................... 
.................... 		}//j
....................    }//i
....................    return FicheroIncializado;
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart){
....................    unsigned int32 cluster;
....................    unsigned int32 _sector;   //recorrer sectores
....................    unsigned int32 bytes;     //recorrer bytes en cada sector
.................... 
....................    cluster =  clusterStart;
....................    if(FATType==16)
....................    _sector = (clusterStart >> 2) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante
....................    if(FATType==32)
....................    _sector = (clusterStart >> 3) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante
....................    bytes = (clusterStart % ((FATType==16) ? MAX_ENTRIES_SECTOR_FAT16 : MAX_ENTRIES_SECTOR_FAT32));
.................... 
....................    if(FATType==32){
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT
.................... 		  sd_read_block(_sector,sector_fat32); 							//leemos el sector
....................     					      for(; bytes < MAX_ENTRIES_SECTOR_FAT32; bytes++){ //recorremos el sector para buscar un puntero a cluster libre
.................... 					         if(sector_fat32[bytes]== 0){
.................... 					            if(cluster < 3)               continue;  	//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando
.................... 					            return cluster;
.................... 					         }//fin if
.................... 					         cluster++;
.................... 					      }//fin for de recorrer bytes dentro de un sector
.................... 	      bytes = 0;
.................... 	   }//fin for de recorrer sectores
....................    }else
....................     if(FATType==16){
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT
.................... 		  sd_read_block(_sector,sector_fat16); 							//leemos el sector
.................... 
.................... 					      for(; bytes < MAX_ENTRIES_SECTOR_FAT16; bytes++){ 	//recorremos el sector para buscar un puntero a cluster libre
.................... 					         if(sector_fat16[bytes]== 0){
.................... 					            if(cluster < 2)               continue;		//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando
.................... 					            return cluster;
.................... 					         }//fin if
.................... 					         cluster++;
.................... 					      }//fin for de recorrer bytes dentro de un sector
.................... 	      bytes = 0;
.................... 	   }//fin for de recorrer sectores
.................... 	}
....................    return ((FATType==16)?ENDFILE16:ENDFILE32);
.................... }//fin encontrarCluster
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... void escribe_datos_en_fichero(){
....................    unsigned int32 relSector;
....................    unsigned int32 nextCluster;
....................    unsigned int32  oldCluster;
....................    unsigned int16 _hour, date;
.................... 
.................... 	sd_write_block(file.currentSector, dt);
.................... 
.................... 
.................... 
.................... 
.................... 		file.currentSector++;																					//actualizar las FATs
.................... 		if(FATType==16)
.................... 	    relSector= file.currentSector - ((file.currentCluster -  2) * sect_x_cluster + sect_ini_datos);
.................... 		if(FATType==32)
.................... 	    relSector= file.currentSector - ((file.currentCluster -  3) * sect_x_cluster + sect_ini_datos);
.................... 
.................... 	    if((relSector % sect_x_cluster) == 0){   											//ï¿½el siguiente sector estï¿½ en cluster nuevo?
.................... 	      oldCluster = 	file.currentCluster;
.................... 	      nextCluster = encontrarCluster(oldCluster);   									//siguiente cluster
.................... 	      //escribirCluster(oldCluster, nextCluster);  										//marcar actual cluster para que apunte al siguiente
.................... 	      file.currentCluster = nextCluster;
.................... 		  if(FATType==16)
.................... 	      file.currentSector = (nextCluster - 2) * sect_x_cluster + sect_ini_datos;
.................... 		  if(FATType==32)
.................... 	      file.currentSector = (nextCluster - 3) * sect_x_cluster + sect_ini_datos;
.................... 	   }
.................... 
.................... 	   //actualizar el tamaï¿½o del fichero y fechas
.................... 	   file.size += 512;
.................... 	   file.EntryFile[file.offsetEntry + 28] = make8(file.size, 0);   //tamaï¿½o
.................... 	   file.EntryFile[file.offsetEntry + 29] = make8(file.size, 1);
.................... 	   file.EntryFile[file.offsetEntry + 30] = make8(file.size, 2);
.................... 	   file.EntryFile[file.offsetEntry + 31] = make8(file.size, 3);
.................... 	   //ActualizaReloj();
.................... 	   _hour = getHour();
.................... 	   date = getDate();
.................... 	   file.EntryFile[file.offsetEntry + 24] = make8(date, 0);       //fecha modif
.................... 	   file.EntryFile[file.offsetEntry + 25] = make8(date, 1);
.................... 	   file.EntryFile[file.offsetEntry + 22] = make8(_hour, 0);      //hora modif
.................... 	   file.EntryFile[file.offsetEntry + 23] = make8(_hour, 1);
.................... 	   file.EntryFile[file.offsetEntry + 18] = file.EntryFile[file.offsetEntry + 24];   //fecha ï¿½ltimo acceso
.................... 	   file.EntryFile[file.offsetEntry + 19] = file.EntryFile[file.offsetEntry + 25];
.................... 
.................... 	   sd_write_block(file.sectorEntryFile, file.EntryFile);  	// Actualiza root
.................... 
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __MIFAT_H
.................... 
.................... #include "sdcard.h"
.................... 
.................... #ifndef __SDCARD_H
.................... #define __SDCARD_H
.................... 
.................... #bit  SPIRBF    = getenv("SFR:SPI1STAT").0
.................... #bit  SPITBF    = getenv("SFR:SPI1STAT").1
.................... #bit  SPIROV    = getenv("SFR:SPI1STAT").6
.................... #byte SPI1BUF   = getenv("SFR:SPI1BUF")
.................... #byte SPI1STAT  = getenv("SFR:SPI1STAT")
.................... #byte SPI1CON1  = getenv("SFR:SPI1CON1")
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define   CMD0              		0x40      //go to idle				//Commands
.................... #define   CMD1               		0x41      //initialization process
.................... #define   CMD8               		0x48      //verify interface
.................... #define   CMD17              		0x51      //read single block
.................... #define   CMD24              		0x58      //write single block
.................... #define   CMD55              		0x77      //escape for app specific command
.................... #define   CMD58              		0x7a      //read OCR
.................... #define   ACMD41             		0x69      //poll operation range
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define   R1_READY_STATE          	0x00      //sd ready				//Responses
.................... #define   R1_IDLE_STATE           	0x01      //card in idle state
.................... #define   R1_ILLEGAL_COMMAND      	0x04      //illegal command
.................... #define   DATA_START_BLOCK       	0xFE      //start token for read or write
.................... #define   DATA_RES_MASK          	0x1F      //mask for data response
.................... #define   DATA_RES_ACCEPTED      	0x05      //write accepted
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sdhc;
.................... unsigned int8 dt[512];            /// Buffer de escritura  en uSD
.................... unsigned int32 LBA0 = 0;
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... inline unsigned int8 xfer_spi(char envio){
....................    SPIROV = 0;
....................    SPI1BUF= envio;
....................    while( SPITBF);
....................    while(!SPIRBF);
....................    return SPI1BUF;
.................... }//fin xfer_spi
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 Commnd(char befF, int32 SD_Adress, char befH){
....................    unsigned int8 iC1;
....................    xfer_spi(0xFF);
....................    xfer_spi(befF);
....................    xfer_spi(make8(SD_Adress, 3));
....................    xfer_spi(make8(SD_Adress, 2));
....................    xfer_spi(make8(SD_Adress, 1));
....................    xfer_spi(make8(SD_Adress, 0));
....................    xfer_spi(befH);
....................     do{iC1 = xfer_spi(0xFF);
....................    }while(iC1 == 0xFF);
....................    return iC1;
.................... }//fin Commnd
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_init(){
....................  unsigned  int8 R[17]={0}, versionSD= 1, crc;
....................  unsigned int16 iI;
....................  unsigned int32 arg=0;
.................... 
....................  setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_16);
.................... 
....................  memset(dt,0,512);
....................  // CMD0 - GO_IDLE_STATE  (R1)ï¿½ ï¿½ Card Reset  ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 	do{	output_high(CS);   	// tarjeta deshabilitada
.................... 		for (iI = 0; iI < 10; iI++)  	xfer_spi(0xFF);
.................... 		output_low(CS); 	// tarjeta habilitada
.................... 		R[0] = Commnd( CMD0 , 0x00000000 , 0x95); //go to idle
.................... 	}while( R[0] != R1_IDLE_STATE);
....................   // CMD8 - SEND_IF_COND (R7)  ï¿½ Send Interface Condition Commandï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // Argument 00 - 00 - 01 (Voltage supplied = 2.7-3.6V) - AA (Check pattern)
....................   // Response: illegal command -> Version 1
....................   // Response: echo-back 	   -> Version 2
.................... 	R[0] = Commnd(CMD8, 0x000001AA, 0x87);
....................     if(R[0]& R1_ILLEGAL_COMMAND){	  			versionSD = 1;
....................    			}else{	R[1] = xfer_spi(0xFF);
.................... 					R[2] = xfer_spi(0xFF);
.................... 					R[3] = xfer_spi(0xFF);
.................... 					R[4] = xfer_spi(0xFF);
.................... 				    if(R[4]!=0xAA){	output_high(CS); return 1; }		//error
....................       											versionSD = 2;
....................    			}
.................... 
....................   // ACMD41 - SD_SEND_OP_ COND (R1) ï¿½ ï¿½ Initialization Command   ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // If host supports SDHC or SDXC: HCS (Host Capacity Support) is set to 1 (arg= 0x40000000)
....................   // If host only support SDSC:     HCS (Host Capacity Support) is set to 0 (arg= 0)
....................    arg = (versionSD == 2) ? 0x40000000 : 0;
....................    crc = (versionSD == 2) ? 0x77 : 0xFF;
.................... 
.................... 
....................    do{            Commnd(CMD55,    0, 0x65);	// El proceso puede llegar a durar hasta 1 segundo
....................            R[0] = Commnd(ACMD41, arg, crc);		// Application-Specific Command ï¿½ APP_CMD (CMD55)
.................... 		   delay_ms(4);
....................    }while(R[0] != R1_READY_STATE);
.................... 
....................   if(versionSD == 2){
.................... 
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // CMD58 - READ_OCR (R3) ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // Bit 30 - Card Capacity Status bit: 	0 indicates that the card is SDSC.
....................   //										1 indicates that the card is SDHC or SDXC
.................... 	R[0] = Commnd(CMD58, 0x00000000, 0xFF);
....................     if(R[0] == R1_READY_STATE){	R[1] = xfer_spi(0xFF);
.................... 								R[2] = xfer_spi(0xFF);
.................... 								R[3] = xfer_spi(0xFF);
.................... 								R[4] = xfer_spi(0xFF);
.................... 								sdhc = ((R[1]& 0xC0) == 0xC0) ? 1 : 0;
....................    			}else{				output_high(CS); return 1; }		//error
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 
....................   }// versionSD == 2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
....................   setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_1);
.................... 
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 	sd_read_block(0, dt);	//Lee el sector fisico 0 para obtener el LBA0
.................... 	if(dt[510]==0x55)
.................... 	if(dt[511]==0xAA){ 		// Efectivamente parece que estoy en sct 0
.................... 							// Tabla de particiones
.................... 								LBA0 = make32(dt[457],dt[456],dt[455],dt[454]);
.................... 								if(dt[0]==0xEB) // MBR
....................  								LBA0 = 0;
.................... 						  }//55AA
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 
....................   output_high(CS);   									// tarjeta deshabilitada
....................   return 0;
.................... }//char sd_init()- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr){
....................    unsigned int16 iW;
.................... 
....................    if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores
....................    output_low(CS);
.................... 
.................... 		iW = Commnd(CMD24, address, 0xFF);
....................     if( iW == R1_READY_STATE){
....................              								              		xfer_spi(0xFF);
....................                               									xfer_spi(DATA_START_BLOCK);   // Data start token
....................                            			for(iW = 0; iW < 512; iW++)  xfer_spi(ptr[iW]);
....................                            							xfer_spi(0xFF);   // Dummy bytes
....................                           							xfer_spi(0xFF);   // en lugar del CRC16
.................... 
....................                         do{       iW = xfer_spi(0xFF);
....................                         }while( (iW & DATA_RES_MASK) != DATA_RES_ACCEPTED);
.................... 
....................                         do{       iW = xfer_spi(0xFF); delay_us(100);
....................                         }while(   iW == 0 );
.................... 
.................... 						xfer_spi(0xFF);
.................... 						xfer_spi(0xFF);
.................... 
....................    						output_high(CS);   return 0; //correcto
.................... 						}
....................    						output_high(CS);   return 1; //error
.................... }//fin sd_write_block
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr){
....................    unsigned int16 jR;
....................    unsigned int8  iR;
.................... 
....................     if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores
....................     output_low(CS);
.................... 
....................        iR  = Commnd(CMD17, address, 0xFF);
....................     if(iR == R1_READY_STATE){
.................... 								do{     iR  = xfer_spi(0xFF);
.................... 								}while( iR != DATA_START_BLOCK);
.................... 
.................... 								if(iR == DATA_START_BLOCK){
.................... 								for(jR = 0; jR < 512; jR++)
.................... 								         ptr[jR] = xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
....................   								}
.................... 
....................    							output_high(CS);      return 0;
.................... 							}
.................... 							output_high(CS);      return 1;
.................... }//fin sd_read_block
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __SDCARD_H
.................... 
.................... 
.................... void sd_init_global();
.................... void escritura_sd();
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __SD_CARD_H
.................... 
.................... #include "BLUETOOTH.h"
.................... #ifndef Bluetooth_h
.................... #define Bluetooth_h
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use rs232(UART1,baud=115200,STREAM=BT)
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void init_BT(void); //inits and enables uart isr
.................... void enviar_datos(unsigned int16 ppm);
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void)		//4kHz -> T/2= 125us
.................... {
.................... 	setup_timer3(TMR_INTERNAL|TMR_DIV_BY_1, 737); // 5kHz. Frecuencia de los beeps
*
00830:  CLR     112
00832:  MOV     #2E1,W4
00834:  MOV     W4,10E
00836:  MOV     #8000,W4
00838:  MOV     W4,112
.................... 	set_compare_time(2, 0);
0083A:  CLR     188
.................... 	setup_compare(2, COMPARE_OFF);
0083C:  CLR     18A
.................... 
.................... 		// (11059200/2)/256/432 = 50 Hz  <-> 100ms
.................... 	setup_timer4(TMR_INTERNAL|TMR_DIV_BY_8, 1843);
0083E:  CLR     11E
00840:  MOV     #733,W4
00842:  MOV     W4,11A
00844:  MOV     #8010,W4
00846:  MOV     W4,11E
00848:  RETURN  
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 N_beep;
.................... 
.................... void BEEP(unsigned int8 n)
.................... {
.................... 	if(n<127)
*
00362:  MOV     3C32,W0
00364:  CLR.B   1
00366:  MOV     #7F,W4
00368:  CP.B    W4L,W0L
0036A:  BRA     LEU,37A
.................... 		N_beep = 2*n;
0036C:  MOV     3C32,W0
0036E:  SL.B    0
00370:  PUSH    2734
00372:  MOV.B   W0L,[W15-#2]
00374:  POP     2734
00376:  GOTO    380
.................... 	else
.................... 		N_beep = 255;
*
0037A:  MOV     2734,W0
0037C:  MOV.B   #FF,W0L
0037E:  MOV     W0,2734
.................... 
.................... 	enable_interrupts(INT_TIMER4);
00380:  BSET.B  97.3
00382:  RETURN  
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #INT_TIMER4
.................... void isr_TIMER4()			// Cada 100 ms. Espaciado entre beeps. Habra que asociarlo a una interrupcion por software
*
0026C:  PUSH    42
0026E:  PUSH    36
00270:  PUSH    32
00272:  MOV     W0,[W15++]
00274:  MOV     #2,W0
00276:  REPEAT  #C
00278:  MOV     [W0++],[W15++]
.................... {
.................... 		if((N_beep%2)==1)
0027A:  MOV     2734,W0
0027C:  CLR.B   1
0027E:  AND     W0,#1,W5
00280:  CP      W5,#1
00282:  BRA     NZ,28C
.................... 		{
.................... 			setup_compare(2, COMPARE_TOGGLE | COMPARE_TIMER3);
00284:  MOV     #B,W4
00286:  MOV     W4,18A
.................... 		}
00288:  GOTO    292
.................... 		else
.................... 		{
.................... 			setup_compare(2, COMPARE_OFF);
*
0028C:  CLR     18A
.................... 			OFF(BUZZER);
0028E:  BCLR.B  2D0.6
00290:  BCLR.B  2D4.6
.................... 		}
.................... 
.................... 		if( N_beep>0 )
00292:  MOV     2734,W0
00294:  CLR.B   1
00296:  CP0.B   W0L
00298:  BRA     Z,2AA
.................... 		{
.................... 		   	N_beep-=1;
0029A:  MOV     2734,W0
0029C:  CLR.B   1
0029E:  SUB.B   W0L,#1,W0L
002A0:  PUSH    2734
002A2:  MOV.B   W0L,[W15-#2]
002A4:  POP     2734
.................... 		}
002A6:  GOTO    2AE
.................... 		else
.................... 		{
.................... 			disable_interrupts(INT_TIMER4);
*
002AA:  BCLR.B  97.3
002AC:  NOP     
.................... 		}
002AE:  BCLR.B  87.3
002B0:  MOV     #1A,W0
002B2:  REPEAT  #C
002B4:  MOV     [--W15],[W0--]
002B6:  MOV     [--W15],W0
002B8:  POP     32
002BA:  POP     36
002BC:  POP     42
002BE:  RETFIE  
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "BLUETOOTH.h"
.................... #include "BLUETOOTH.h"
.................... #ifndef Bluetooth_h
.................... #define Bluetooth_h
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #ifndef LIB_h
.................... #define LIB_h
.................... 
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device DSPIC33FJ128MC804
*
00200:  CLR     32
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    24,52,00
0020E:  DATA    65,70,00
00210:  DATA    72,65,00
00212:  DATA    73,65,00
00214:  DATA    6E,74,00
00216:  DATA    61,63,00
00218:  DATA    69,6F,00
0021A:  DATA    6E,20,00
0021C:  DATA    67,72,00
0021E:  DATA    61,66,00
00220:  DATA    69,63,00
00222:  DATA    61,2C,00
00224:  DATA    46,75,00
00226:  DATA    6E,63,00
00228:  DATA    69,6F,00
0022A:  DATA    6E,2C,00
0022C:  DATA    64,61,00
0022E:  DATA    74,6F,00
00230:  DATA    73,20,00
00232:  DATA    31,0A,00
00234:  DATA    00,00,00
00236:  CLR     32
00238:  MOV     #242,W3
0023A:  ADD     W3,W0,W0
0023C:  TBLRDL.B[W0],W0L
0023E:  CLR.B   1
00240:  RETURN  
00242:  DATA    26,30,00
00244:  DATA    2C,31,00
00246:  DATA    30,30,00
00248:  DATA    30,2C,00
0024A:  DATA    30,2C,00
0024C:  DATA    31,2C,00
0024E:  DATA    30,0A,00
00250:  DATA    00,00,00
00252:  CLR     32
00254:  MOV     #25E,W3
00256:  ADD     W3,W0,W0
00258:  TBLRDL.B[W0],W0L
0025A:  CLR.B   1
0025C:  RETURN  
0025E:  DATA    23,30,00
00260:  DATA    2C,32,00
00262:  DATA    30,30,00
00264:  DATA    2C,30,00
00266:  DATA    2C,31,00
00268:  DATA    2C,30,00
0026A:  DATA    0A,00,00
*
00C84:  MOV     W5,[W15++]
00C86:  MOV     #C,W5
00C88:  REPEAT  #3
00C8A:  MOV     [W5++],[W15++]
00C8C:  BTSS    W0.F
00C8E:  BRA     CA8
00C90:  NEG     W0,W0
00C92:  BSET    W4.8
00C94:  BTSS    W4.F
00C96:  BRA     CA8
00C98:  MOV     W0,[W15++]
00C9A:  MOV     #2D,W0
00C9C:  BTSC.B  223.1
00C9E:  BRA     C9C
00CA0:  MOV     W0,224
00CA2:  MOV     [--W15],W0
00CA4:  BCLR    W4.8
00CA6:  DEC.B   0008
00CA8:  CLR     W5
00CAA:  MOV     W0,W7
00CAC:  MOV     W4,W9
00CAE:  BCLR    W4.F
00CB0:  CP0.B   W4L
00CB2:  BRA     NZ,CC0
00CB4:  BTSC    W9.F
00CB6:  BRA     CBC
00CB8:  MOV     #0,W5
00CBA:  BRA     CE4
00CBC:  MOV     #0,W5
00CBE:  BRA     CE4
00CC0:  BTSS    W9.8
00CC2:  SUB.B   W4L,#6,W5L
00CC4:  BTSC    W9.8
00CC6:  SUB.B   W4L,#7,W5L
00CC8:  BRA     NC,CE2
00CCA:  MOV     #30,W0
00CCC:  BTSS    W9.F
00CCE:  MOV     #20,W0
00CD0:  MOV     W0,[W15++]
00CD2:  BTSC.B  223.1
00CD4:  BRA     CD2
00CD6:  MOV     W0,224
00CD8:  MOV     [--W15],W0
00CDA:  DEC     W5,W5
00CDC:  BRA     NN,CD0
00CDE:  MOV     #5,W5
00CE0:  BRA     CE4
00CE2:  MOV     W4,W5
00CE4:  MOV     #6,W4
00CE6:  BTSC    W5.8
00CE8:  INC     W4,W4
00CEA:  BSET    W5.E
00CEC:  BTSC    W9.F
00CEE:  BSET    W5.F
00CF0:  MOV     #2710,W8
00CF2:  REPEAT  #11
00CF4:  DIV.U   W7,W8
00CF6:  CALL    D3A
*
00CFA:  MOV     W1,W7
00CFC:  MOV     #3E8,W8
00CFE:  REPEAT  #11
00D00:  DIV.U   W7,W8
00D02:  CALL    D3A
*
00D06:  MOV     W1,W7
00D08:  MOV     #64,W8
00D0A:  REPEAT  #11
00D0C:  DIV.U   W7,W8
00D0E:  CALL    D3A
*
00D12:  MOV     W1,W7
00D14:  MOV     #A,W8
00D16:  REPEAT  #11
00D18:  DIV.U   W7,W8
00D1A:  CALL    D3A
*
00D1E:  BTSS    W9.8
00D20:  BRA     D2C
00D22:  MOV     #2D,W0
00D24:  BTSC.B  223.1
00D26:  BRA     D24
00D28:  MOV     W0,224
00D2A:  BCLR    W9.8
00D2C:  MOV     #30,W0
00D2E:  ADD.B   W1L,W0L,W0L
00D30:  MOV     W0,2A
00D32:  BTSC.B  223.1
00D34:  BRA     D32
00D36:  MOV     W0,224
00D38:  BRA     D7A
00D3A:  MOV     #30,W6
00D3C:  CP0     W0
00D3E:  BRA     NZ,D5C
00D40:  BTSS    W5.E
00D42:  BRA     D70
00D44:  DEC     W4,W4
00D46:  CP.B    W4L,W5L
00D48:  BRA     Z,D4E
00D4A:  BTSC.B  42.0
00D4C:  RETURN  
00D4E:  CP0     W0
00D50:  BRA     NZ,D5C
00D52:  BTSS    W5.E
00D54:  BRA     D70
00D56:  BTSS    W5.F
00D58:  MOV     #20,W6
00D5A:  BRA     D70
00D5C:  BCLR    W5.E
00D5E:  BTSS    W9.8
00D60:  BRA     D70
00D62:  MOV     W0,W10
00D64:  MOV     #2D,W0
00D66:  BTSC.B  223.1
00D68:  BRA     D66
00D6A:  MOV     W0,224
00D6C:  BCLR    W9.8
00D6E:  MOV     W10,W0
00D70:  ADD.B   W6L,W0L,W0L
00D72:  BTSC.B  223.1
00D74:  BRA     D72
00D76:  MOV     W0,224
00D78:  RETURN  
00D7A:  MOV     #12,W5
00D7C:  REPEAT  #3
00D7E:  MOV     [--W15],[W5--]
00D80:  MOV     [--W15],W5
00D82:  RETURN  
.................... 
.................... #list
.................... 
.................... #endif
.................... 
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use rs232(UART1,baud=115200,STREAM=BT)
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void init_BT(void); //inits and enables uart isr
.................... void enviar_datos(unsigned int16 ppm);
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... float phase = 0;
.................... unsigned int8 snd;
.................... 
.................... void init_BT(void)
.................... {
....................   	fprintf(BT,"$$$");	     delay_ms(500); // command mode
....................   	fprintf(BT,"SF,1\r");      delay_ms(500); // factory defaults
....................   	fprintf(BT,"SA,0\r");      delay_ms(500); // authentication 'Open'
....................   	fprintf(BT,"R,1\r");       delay_ms(500); // Run device
.................... }
.................... 
.................... void enviar_datos(unsigned int16 ppm)
.................... {
.................... 	COM:
.................... 	while(!input(COMM));
00D84:  BSET.B  2C1.1
00D86:  NOP     
00D88:  BTSS.B  2C3.1
00D8A:  BRA     D84
.................... 		fprintf(BT,"$Representacion grafica,Funcion,datos 1\n");
00D8C:  MOV     #0,W1
00D8E:  MOV     W1,W0
00D90:  CLR.B   1
00D92:  CALL    200
*
00D96:  INC     W1,W1
00D98:  BTSC.B  223.1
00D9A:  BRA     D98
00D9C:  MOV     W0,224
00D9E:  MOV     #27,W0
00DA0:  CPSGT   W1,W0
00DA2:  BRA     D8E
....................  		fprintf(BT,"&0,1000,0,1,0\n");
00DA4:  MOV     #0,W1
00DA6:  MOV     W1,W0
00DA8:  CLR.B   1
00DAA:  CALL    236
*
00DAE:  INC     W1,W1
00DB0:  BTSC.B  223.1
00DB2:  BRA     DB0
00DB4:  MOV     W0,224
00DB6:  MOV     #D,W0
00DB8:  CPSGT   W1,W0
00DBA:  BRA     DA6
....................  		fprintf(BT,"#0,200,0,1,0\n");
00DBC:  MOV     #0,W1
00DBE:  MOV     W1,W0
00DC0:  CLR.B   1
00DC2:  CALL    252
*
00DC6:  INC     W1,W1
00DC8:  BTSC.B  223.1
00DCA:  BRA     DC8
00DCC:  MOV     W0,224
00DCE:  MOV     #C,W0
00DD0:  CPSGT   W1,W0
00DD2:  BRA     DBE
.................... 
.................... 	while(1)
.................... 	{
....................  		fprintf(BT, "%3d\n", ppm);
00DD4:  MOV     3BEE,W0
00DD6:  MOV     #3,W4
00DD8:  CALL    C84
*
00DDC:  BTSC.B  223.1
00DDE:  BRA     DDC
00DE0:  MOV     #A,W4
00DE2:  MOV     W4,224
.................... 		delay_ms(4);
00DE4:  REPEAT  #3992
00DE6:  NOP     
.................... 		if(!input(COMM))
00DE8:  BSET.B  2C1.1
00DEA:  NOP     
00DEC:  BTSC.B  2C3.1
00DEE:  BRA     DF4
.................... 		goto COM;
00DF0:  GOTO    D84
*
00DF4:  GOTO    DD4
.................... 	}
*
00DF8:  RETURN  
.................... }
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... /**
.................... /**
....................  @file    led.c
....................  @author  Ricardo Gomez
.................... 
....................  @brief   LCD functions
.................... */
.................... // Do not write above this line (except comments)!
.................... /* SECTION 1: Included header files to compile this file           */
.................... 
.................... #include "lcd.h"
.................... /**
....................  @file    lcd.h
....................  @author  Ricardo Gï¿½mez
....................  @brief   LCD management
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __LCD_H
.................... #define __LCD_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #ifndef LIB_h
.................... #define LIB_h
.................... 
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device DSPIC33FJ128MC804
.................... 
.................... #list
.................... 
.................... #endif
.................... 
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... #WORD ADC1BUF0 = 0x0300;
.................... #WORD ADC1CON1 = 0x0320;
.................... #WORD ADC1CON2 = 0x0322;
.................... #WORD ADC1CON3 = 0x0324;
.................... #WORD AD1CHS0 = 0x0328;
.................... #WORD AD1PCFGL = 0x032C;
.................... #WORD IFS0 = 0x0084;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "lcd.h"
.................... /**
....................  @file    lcd.h
....................  @author  Ricardo Gï¿½mez
....................  @brief   LCD management
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __LCD_H
.................... #define __LCD_H
.................... 
.................... #include "common.h"
.................... 
.................... /* SECTION 1: Included header files to compile this file           */
.................... 
.................... /* SECTION 2: Public macros                                        */
.................... 
.................... #define _CLEAR_DISPLAY 				0x01
.................... #define _8BIT_4LINES_NORMAL_RE1_IS0		0x3A
.................... #define _8BIT_4LINES_REVERSE_RE1_IS0		0x3B
.................... #define _8BIT_4LINES_RE0_IS1			0x39
.................... #define _8BIT_4LINES_RE0_IS0			0x38
.................... 
.................... #define _BS1_1					0x1E
.................... #define _POWER_DOWN_DISABLE			0x02
.................... #define _SEGMENT_NORMAL_WAY			0x05
.................... #define _NW					0x09
.................... 
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_ON		0x0F
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_OFF		0x0E
.................... #define _DISPLAY_ON_CURSOR_OFF_BLINK_OFF	0x0C
.................... #define _BS0_1					0x1C
.................... #define _INTERNAL_DIVIDER			0x13
.................... #define _CONTRAST				0x77
.................... #define _POWER_ICON_CONTRAST			0x5C
.................... #define _FOLLOWER_CONTROL			0x6E
.................... 
.................... #define ADDRESS_DDRAM				0x80
.................... 
.................... 
.................... /* SECTION 3: Public types                                         */
.................... 
.................... 
.................... /* SECTION 4: Public variables :: declarations, extern mandatory   */
.................... 
.................... 
.................... /* SECTION 5: Public functions :: declarations, extern optional
....................    Rule exception (callbacks)  :: declarations, extern recommended */
.................... void display_valueADC_title(void);
.................... void LCD_command(unsigned int8);
.................... void lcdi2cinit(void);
.................... void LCD_write(char*);
.................... void initmenu(void);                                      //Inicializa el menu principal
.................... void display_frecuencia(void);       // Muestra frecuencia
.................... void LCD_cursor_at(unsigned int8 line, unsigned int8 column);
.................... void display_alarma_alto(void); // Limpia pantalla y escribe mensaje de alarma
.................... void display_alarma_bajo(void);
.................... void display_final(void);
.................... 
.................... 
.................... #endif // __LCD_H
.................... // Do not write below this line!
.................... 
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #ifndef LIB_h
.................... #define LIB_h
.................... 
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device DSPIC33FJ128MC804
.................... 
.................... #nolist
.................... //////// Program memory: 44032x24  Data RAM: 16384  Stack: 31
.................... //////// I/O: 35   Analog Pins: 9
.................... //////// Fuses: WRTB,NOWRTB,BSSHL,BSSHM,BSSHS,BSSSL,BSSSM,BSSSS,NOBSS
.................... //////// Fuses: RBS1024,RBS256,RBS128,NORBS,WRTSS,NOWRTSS,SSSHL,SSSHM,SSSHS
.................... //////// Fuses: SSSSL,SSSSM,SSSSS,NOSSS,RSS4096,RSS2048,RSS256,NORSS,WRT
.................... //////// Fuses: NOWRT,PROTECT_HIGH,PROTECT,NOPROTECT,FRC,FRC_PLL,PR,PR_PLL
.................... //////// Fuses: SOSC,LPRC,FRC_DIV_BY_16,FRC_PS,NOIESO,IESO,EC,XT,HS,NOPR
.................... //////// Fuses: OSCIO,NOOSCIO,NOIOL1WAY,IOL1WAY,CKSFSM,CKSNOFSM,NOCKSFSM
.................... //////// Fuses: WPOSTS1,WPOSTS2,WPOSTS3,WPOSTS4,WPOSTS5,WPOSTS6,WPOSTS7
.................... //////// Fuses: WPOSTS8,WPOSTS9,WPOSTS10,WPOSTS11,WPOSTS12,WPOSTS13,WPOSTS14
.................... //////// Fuses: WPOSTS15,WPOSTS16,WPRES32,WPRES128,NOWINDIS,WINDIS,NOWDT,WDT
.................... //////// Fuses: NOPUT,PUT2,PUT4,PUT8,PUT16,PUT32,PUT64,PUT128,ALTI2C1
.................... //////// Fuses: NOALTI2C1,LPOL_LOW,LPOL_HIGH,HPOL_LOW,HPOL_HIGH,PWMPIN
.................... //////// Fuses: NOPWMPIN,ICSP3,ICSP2,ICSP1,NOJTAG,JTAG,DEBUG,NODEBUG
.................... ////////
.................... #if (!defined(__PCD__)||defined(__ISNT_CCS__))
.................... #define _bif
.................... #define int8 char
.................... #define int16 int
.................... #define int32 long
.................... #define int48 long
.................... #define int64 long long
.................... #define float32 float
.................... #define float48 float
.................... #define float64 double
.................... #define int1 char
.................... 
.................... #endif
.................... ////////////////////////////////////////////////////////////////// PIN_SELECT
.................... // #pin_select function=pin
.................... // Valid Pins:
.................... //    PIN_B0,PIN_B1,PIN_B2,PIN_B3,PIN_B4,PIN_B5,PIN_B6,PIN_B7,PIN_B8,PIN_B9,
.................... //    PIN_B10,PIN_B11,PIN_B12,PIN_B13,PIN_B14,PIN_B15,PIN_C0,PIN_C1,PIN_C2,
.................... //    PIN_C3,PIN_C4,PIN_C5,PIN_C6,PIN_C7,PIN_C8,PIN_C9
.................... // Input Functions:
.................... //    INT1,INT2,T2CK,T3CK,T4CK,T5CK,IC1,IC2,IC3,IC4,IC5,OCFA,OCFB,U1RX,U1CTS,
.................... //    U2RX,U2CTS,SDI1,SCK1IN,SS1IN,SDI2,SCK2IN,SS2IN,C1RX,IC7,IC8,CSDI,CSCK,COFS,
.................... //    FLTA1,FLTA2,QEA1,QEB1,INDX1,QEA2,QEB2,INDX2,T1CK,FLT1,FLT2,FLT3,FLT4,FLT5,
.................... //    FLT6,FLT7,FLT8,SYNCI1,SYNCI2
.................... // Output Functions:
.................... //    NULL,C1OUT,C2OUT,U1TX,U1RTS,U2TX,U2RTS,SDO1,SCK1OUT,SS1OUT,SDO2,SCK2OUT,
.................... //    SS2OUT,OC1,OC2,OC3,OC4,OC5,C1TX,CSDO,CSCKOUT,COFSOUT,UPDN1,UPDN2,CTPLS,
.................... //    C3OUT,SYNCO1,REFCLKO,CMP1,CMP2,CMP3,CMP4,PWM4H,PWM4L
.................... //
.................... 
.................... ////////////////////////////////////////////////////////////////// I/O
.................... // Discrete I/O Functions: SET_TRIS_x(), OUTPUT_x(), INPUT_x(),
.................... //                         SET_PULLUP(), INPUT(),
.................... //                         OUTPUT_LOW(), OUTPUT_HIGH(),
.................... //                         OUTPUT_FLOAT(), OUTPUT_BIT()
.................... // Discrete I/O Prototypes:
.................... _bif void set_tris_a(unsigned int16 value);
.................... _bif void set_tris_b(unsigned int16 value);
.................... _bif void set_tris_c(unsigned int16 value);
.................... _bif unsigned int16 get_tris_a(void);
.................... _bif unsigned int16 get_tris_b(void);
.................... _bif unsigned int16 get_tris_c(void);
.................... _bif void output_a(unsigned int16 value);
.................... _bif void output_b(unsigned int16 value);
.................... _bif void output_c(unsigned int16 value);
.................... _bif unsigned int16 input_a(void);
.................... _bif unsigned int16 input_b(void);
.................... _bif unsigned int16 input_c(void);
.................... _bif int16 input_change_a(void);
.................... _bif int16 input_change_b(void);
.................... _bif int16 input_change_c(void);
.................... _bif void set_pullup(int1 state);
.................... _bif void set_pullup(int1 state, unsigned int16 pin);
.................... _bif void set_pulldown(int1 state);
.................... _bif void set_pulldown(int1 state, unsigned int16 pin);
.................... _bif int1 input(unsigned int16 pin);
.................... _bif int1 input_state(unsigned int16 pin);
.................... _bif void output_low(unsigned int16 pin);
.................... _bif void output_high(unsigned int16 pin);
.................... _bif void output_toggle(unsigned int16 pin);
.................... _bif void output_bit(unsigned int16 pin, int1 level);
.................... _bif void output_float(unsigned int16 pin);
.................... _bif void output_drive(unsigned int16 pin);
.................... // Constants used to identify pins in the above are:
.................... 
.................... #define PIN_A0  5648
.................... #define PIN_A1  5649
.................... #define PIN_A2  5650
.................... #define PIN_A3  5651
.................... #define PIN_A4  5652
.................... #define PIN_A7  5655
.................... #define PIN_A8  5656
.................... #define PIN_A9  5657
.................... #define PIN_A10  5658
.................... 
.................... #define PIN_B0  5712
.................... #define PIN_B1  5713
.................... #define PIN_B2  5714
.................... #define PIN_B3  5715
.................... #define PIN_B4  5716
.................... #define PIN_B5  5717
.................... #define PIN_B6  5718
.................... #define PIN_B7  5719
.................... #define PIN_B8  5720
.................... #define PIN_B9  5721
.................... #define PIN_B10  5722
.................... #define PIN_B11  5723
.................... #define PIN_B12  5724
.................... #define PIN_B13  5725
.................... #define PIN_B14  5726
.................... #define PIN_B15  5727
.................... 
.................... #define PIN_C0  5776
.................... #define PIN_C1  5777
.................... #define PIN_C2  5778
.................... #define PIN_C3  5779
.................... #define PIN_C4  5780
.................... #define PIN_C5  5781
.................... #define PIN_C6  5782
.................... #define PIN_C7  5783
.................... #define PIN_C8  5784
.................... #define PIN_C9  5785
.................... 
.................... ////////////////////////////////////////////////////////////////// Useful defines
.................... #define FALSE 0
.................... #define TRUE 1
.................... 
.................... #define BYTE unsigned int8
.................... #define BOOLEAN int1
.................... 
.................... #define getc getch
.................... #define fgetc getch
.................... #define getchar getch
.................... #define putc putchar
.................... #define fputc putchar
.................... #define fgets gets
.................... #define fputs puts
.................... 
.................... ////////////////////////////////////////////////////////////////// UART
.................... // UART Prototypes:
.................... _bif void setup_uart(unsigned int32 baud);
.................... _bif void setup_uart(unsigned int32 baud, unsigned int8 stream);
.................... _bif void setup_uart(unsigned int32 baud, unsigned int8 stream, unsigned int32 clock);
.................... _bif void set_uart_speed(unsigned int32 baud);
.................... _bif void set_uart_speed(unsigned int32 baud, unsigned int8 stream);
.................... _bif void set_uart_speed(unsigned int32 baud, unsigned int8 stream, unsigned int32 clock);
.................... // Constants used in setup_uart() are:
.................... // FALSE - Turn UART off
.................... // TRUE  - Turn UART on
.................... #define UART_ADDRESS           2
.................... #define UART_DATA              4
.................... #define UART_AUTODETECT        8
.................... #define UART_AUTODETECT_NOWAIT 9
.................... #define UART_WAKEUP_ON_RDA     10
.................... #define UART_SEND_BREAK        13
.................... 
.................... ////////////////////////////////////////////////////////////////// WDT
.................... // Watch Dog Timer Functions: SETUP_WDT() and RESTART_WDT()
.................... // WDT Prototypes:
.................... _bif void setup_wdt(unsigned int8 mode);
.................... _bif void restart_wdt(void);
.................... // Constants used for SETUP_WDT() are:
.................... #define WDT_ON      1
.................... #define WDT_OFF     0
.................... 
.................... #define  WDT_1MS    0x002
.................... #define  WDT_2MS    0x003
.................... #define  WDT_4MS    0x004
.................... #define  WDT_8MS    0x005
.................... #define  WDT_16MS   0x006
.................... #define  WDT_32MS   0x007
.................... #define  WDT_64MS   0x008
.................... #define  WDT_128MS  0x009
.................... #define  WDT_256MS  0x00A
.................... #define  WDT_512MS  0x00B
.................... #define  WDT_1S     0x00C
.................... #define  WDT_2S     0x00D
.................... #define  WDT_4S     0x00E
.................... #define  WDT_8S     0x00F
.................... #define  WDT_16S    0x010
.................... #define  WDT_33S    0x011
.................... #define  WDT_65S    0x030
.................... #define  WDT_131S   0x031
.................... 
.................... ////////////////////////////////////////////////////////////////// Control
.................... // Control Functions:  RESET_CPU(), SLEEP(), RESTART_CAUSE()
.................... // Prototypes:
.................... _bif unsigned int8 restart_cause(void);
.................... _bif void reset_cpu(void);
.................... _bif void sleep(void);
.................... _bif void sleep(unsigned int8 mode);
.................... // Constants passed into RESTART_CAUSE() are:
.................... #define RESTART_POWER_UP      0
.................... #define RESTART_BROWNOUT      1
.................... #define RESTART_WATCHDOG      4
.................... #define RESTART_SOFTWARE      6
.................... #define RESTART_MCLR          7
.................... #define RESTART_ILLEGAL_OP    14
.................... #define RESTART_TRAP_CONFLICT 15
.................... //
.................... // Constants passed into SLEEP() are:
.................... #define SLEEP_FULL      0  // Default
.................... #define SLEEP_IDLE      1  // Clock and peripherals don't stop
.................... 
.................... ////////////////////////////////////////////////////////////////// INTERNAL RC
.................... // Oscillator Prototypes:
.................... _bif void setup_oscillator(unsigned int8 type, unsigned int32 target);
.................... _bif void setup_oscillator(unsigned int8 type, unsigned int32 target, unsigned int32 source);
.................... // Constants used in setup_oscillator() are:
.................... #define OSC_INTERNAL     32
.................... #define OSC_CRYSTAL       1
.................... #define OSC_CLOCK         2
.................... #define OSC_RC            3
.................... #define OSC_SECONDARY    16
.................... 
.................... ////////////////////////////////////////////////////////////////// Timer
.................... // Timer Functions: SETUP_TIMERx, GET_TIMERx, GET_TIMERxy,
.................... // SET_TIMERx, SET_TIMERxy
.................... // Timer x Prototypes:
.................... _bif void setup_timer1(unsigned int16 mode);
.................... _bif void setup_timer1(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer1(void);
.................... _bif void set_timer1(unsigned int16 value);
.................... _bif void setup_timer2(unsigned int16 mode);
.................... _bif void setup_timer2(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer2(void);
.................... _bif void set_timer2(unsigned int16 value);
.................... _bif void setup_timer3(unsigned int16 mode);
.................... _bif void setup_timer3(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer3(void);
.................... _bif void set_timer3(unsigned int16 value);
.................... _bif unsigned int32 get_timer23(void);
.................... _bif void set_timer23(unsigned int32 value);
.................... _bif void setup_timer4(unsigned int16 mode);
.................... _bif void setup_timer4(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer4(void);
.................... _bif void set_timer4(unsigned int16 value);
.................... _bif void setup_timer5(unsigned int16 mode);
.................... _bif void setup_timer5(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer5(void);
.................... _bif void set_timer5(unsigned int16 value);
.................... _bif unsigned int32 get_timer45(void);
.................... _bif void set_timer45(unsigned int32 value);
.................... // Constants used for SETUP_TIMERx() are:
.................... //      (or (via |) together constants from each group)
.................... #define TMR_DISABLED 0x0000
.................... #define TMR_INTERNAL 0x8000
.................... #define TMR_EXTERNAL 0x8002
.................... #define TMR_GATE     0x0040
.................... 
.................... #define TMR_DIV_BY_1   0x0000
.................... #define TMR_DIV_BY_8   0x0010
.................... #define TMR_DIV_BY_64  0x0020
.................... #define TMR_DIV_BY_256 0x0030
.................... #define TMR_32_BIT     0x0008 // Only for even numbered timers
.................... 
.................... #define TMR_HALT_IDLE      0x2000
.................... #define TMR_CONTINUE_IDLE  0x0000
.................... 
.................... #define T1_EXTERNAL_SYNC  0x8006 //This only applies to Timer1
.................... #define T1_EXTERNAL_RTC   0xC002 //This only applies to Timer1
.................... /////////////////////////////////////////////////////////// INPUT CAPTURE
.................... // Functions: SETUP_CAPTURE, GET_CAPTURE,
.................... // IC Prototypes:
.................... _bif void setup_capture(unsigned int8 module, unsigned int16 mode);
.................... _bif unsigned int16 get_capture(unsigned int8 module);
.................... _bif unsigned int16 get_capture(unsigned int8 module, int1 wait);
.................... // Constants used for SETUP_CAPTURE() are:
.................... #define CAPTURE_OFF               0x0000  // Capture OFF
.................... #define CAPTURE_EE                0x0001  // Capture Every Edge
.................... #define CAPTURE_FE                0x0002  // Capture Falling Edge
.................... #define CAPTURE_RE                0x0003  // Capture Rising Edge
.................... #define CAPTURE_DIV_4             0x0004  // Capture Every 4th Rising Edge
.................... #define CAPTURE_DIV_16            0x0005  // Capture Every 16th Rising Edge
.................... #define CAPTURE_INTERRUPT_ONLY    0x0007  // Interrupt on Rising Edge when in Sleep or Idle
.................... 
.................... // The following defines can be ORed | with above to configure interrupts
.................... #define INTERRUPT_EVERY_CAPTURE   0x0000  // Interrupt on every capture event
.................... #define INTERRUPT_SECOND_CAPTURE  0x0020  // Interrupt on every second capture event
.................... #define INTERRUPT_THIRD_CAPTURE   0x0040  // Interrupt on every third capture event
.................... #define INTERRUPT_FOURTH_CAPTURE  0x0060  // Interrupt on every fourth capture event
.................... 
.................... // The following defines can be ORed | with above to select timer
.................... #define CAPTURE_TIMER2            0x0080  // On capture event Timer 2 is captured
.................... #define CAPTURE_TIMER3            0x0000  // On capture event Timer 3 is captured
.................... 
.................... // The following defines can be ORed | with above to select idle operation mode
.................... #define CAPTURE_HALT_IDLE         0x2000  // Capture module halts during idle mode
.................... #define CAPTURE_CONTINUE_IDLE     0x0000  // Capture module continues during idle mode
.................... 
.................... /////////////////////////////////////////////////////////// OUTPUT COMPARE
.................... // Functions: SETUP_COMPARE, SET_PWM_DUTY, SET_COMPARE_TIME
.................... // OC Prototypes:
.................... _bif void setup_compare(unsigned int8 module, unsigned int16 mode);
.................... _bif void set_pwm_duty(unsigned int8 module, unsigned int16 duty);
.................... _bif void set_compare_time(unsigned int8 module, unsigned int16 ocr);
.................... _bif void set_compare_time(unsigned int8 module, unsigned int16 ocr, unsigned int16 ocrs);
.................... // Constants used for SETUP_COMPARE() are:
.................... #define COMPARE_OFF               0x0000  // Compare OFF
.................... #define COMPARE_SET_ON_MATCH      0x0001  // Pin from low to high on match
.................... #define COMPARE_CLR_ON_MATCH      0x0002  // Pin from high to low on match
.................... #define COMPARE_TOGGLE            0x0003  // Pin will toggle on every match occurrence
.................... #define COMPARE_SINGLE_PULSE      0x0004  // Pin will generate single pulse on first match
.................... #define COMPARE_CONT_PULSE        0x0005  // Pin will pulse for every match
.................... #define COMPARE_PWM               0x0006  // Compare operates as PWM with fault pin disabled
.................... #define COMPARE_PWM_FAULT         0x0007  // Compare operates as PWM with fault pin enabled
.................... 
.................... // The following defines can be ORed | with above to select timer
.................... #define COMPARE_TIMER2            0x0000  // Timer 2 is the base timer
.................... #define COMPARE_TIMER3            0x0008  // Timer 3 is the base timer
.................... 
.................... // The following defines can be ORed | with above to select idle operation mode
.................... #define COMPARE_HALT_IDLE         0x2000  // Compare module halts during idle mode
.................... #define COMPARE_CONTINUE_IDLE     0x0000  // Compare module continues during idle mode
.................... 
.................... ////////////////////////////////////////////////////////////////// SPI
.................... // SPI Functions: SETUP_SPI, SPI_WRITE, SPI_READ, SPI_DATA_IN
.................... // SPI Prototypes:
.................... _bif void setup_spi(unsigned int16 mode);
.................... _bif void spi_write(unsigned int8 data);
.................... _bif void spi_write(int1 wait, unsigned int8 data);
.................... _bif void spi_write_16(unsigned int16 data);
.................... _bif void spi_write_16(int1 wait, unsigned int16 data);
.................... _bif unsigned int8 spi_read(void);
.................... _bif unsigned int8 spi_read(unsigned int8 data);
.................... _bif unsigned int16 spi_read_16(void);
.................... _bif unsigned int16 spi_read_16(unsigned int16 data);
.................... _bif int1 spi_data_in(void);
.................... _bif void setup_spi2(unsigned int16 mode);
.................... _bif void spi_write2(unsigned int8 data);
.................... _bif void spi_write2(int1 wait, unsigned int8 data);
.................... _bif void spi_write2_16(unsigned int16 data);
.................... _bif void spi_write2_16(int1 wait, unsigned int16 data);
.................... _bif unsigned int8 spi_read2(void);
.................... _bif unsigned int8 spi_read2(unsigned int8 data);
.................... _bif unsigned int16 spi_read2_16(void);
.................... _bif unsigned int16 spi_read2_16(unsigned int16 data);
.................... _bif int1 spi_data_in2(void);
.................... // Constants used in SETUP_SPI() are:
.................... //      (or (via |) together constants from each group)
.................... #define SPI_MASTER                 0x0020
.................... #define SPI_SLAVE                  0x0000
.................... 
.................... #define SPI_SCK_IDLE_HIGH          0x0040
.................... #define SPI_SCK_IDLE_LOW           0x0000
.................... 
.................... #define SPI_XMIT_L_TO_H            0x0100
.................... #define SPI_XMIT_H_TO_L            0x0000
.................... 
.................... #define SPI_MODE_16B               0x0400
.................... #define SPI_MODE_8B                0x0000
.................... 
.................... #define SPI_SAMPLE_AT_END          0x0200
.................... #define SPI_SAMPLE_AT_MIDDLE       0x0000
.................... 
.................... #define SPI_SS_ENABLED             0x0000
.................... #define SPI_SS_DISABLED            0x0080
.................... 
.................... //or (via |) one of the following when operating as MASTER
.................... #define SPI_CLK_DIV_1              0x001F
.................... #define SPI_CLK_DIV_2              0x001B
.................... #define SPI_CLK_DIV_3              0x0017
.................... #define SPI_CLK_DIV_4              0x001E
.................... #define SPI_CLK_DIV_5              0x000F
.................... #define SPI_CLK_DIV_6              0x000B
.................... #define SPI_CLK_DIV_7              0x0007
.................... #define SPI_CLK_DIV_8              0x0003
.................... #define SPI_CLK_DIV_12             0x0016
.................... #define SPI_CLK_DIV_16             0x001D
.................... #define SPI_CLK_DIV_20             0x000E
.................... #define SPI_CLK_DIV_24             0x000A
.................... #define SPI_CLK_DIV_28             0x0006
.................... #define SPI_CLK_DIV_32             0x0002
.................... #define SPI_CLK_DIV_48             0x0015
.................... #define SPI_CLK_DIV_64             0x001C
.................... #define SPI_CLK_DIV_80             0x000D
.................... #define SPI_CLK_DIV_96             0x0009
.................... #define SPI_CLK_DIV_112            0x0005
.................... #define SPI_CLK_DIV_128            0x0001
.................... #define SPI_CLK_DIV_192            0x0014
.................... #define SPI_CLK_DIV_256            0x0010
.................... #define SPI_CLK_DIV_320            0x000C
.................... #define SPI_CLK_DIV_384            0x0008
.................... #define SPI_CLK_DIV_448            0x0004
.................... #define SPI_CLK_DIV_512            0x0000
.................... 
.................... //The following defines are provided for compatibility
.................... #define SPI_L_TO_H         SPI_SCK_IDLE_LOW
.................... #define SPI_H_TO_L         SPI_SCK_IDLE_HIGH
.................... 
.................... ////////////////////////////////////////////////////////////////// ADC
.................... // ADC Functions: SETUP_ADC(), SETUP_ADC_PORTS()
.................... //                SET_ADC_CHANNEL(), READ_ADC()
.................... // ADC Prototypes:
.................... _bif void setup_adc(unsigned int32 mode);
.................... _bif void setup_adc_ports(unsigned int32 pins);
.................... _bif void setup_adc_ports(unsigned int32 pins, unsigned int16 reference);
.................... _bif void set_adc_channel(unsigned int8 channel);
.................... _bif void set_adc_channel(unsigned int8 channel, unsigned int8 neg_channel);
.................... _bif unsigned int16 read_adc(void);
.................... _bif unsigned int16 read_adc(unsigned int8 mode);
.................... _bif int1 adc_done(void);
.................... // Constants used for SETUP_ADC() are:
.................... // Clock is at ADCS<5:0> of ADCON3 Reg. (0x02A4)
.................... // Tad = (Tcy/2)*(ADCS<5:0>+1)
.................... #define ADC_OFF                 0x10000
.................... #define ADC_CLOCK                0x0000
.................... #define ADC_CLOCK_DIV_2          0x0001
.................... #define ADC_CLOCK_DIV_4          0x0003
.................... #define ADC_CLOCK_DIV_8          0x0007
.................... #define ADC_CLOCK_DIV_16         0x000F
.................... #define ADC_CLOCK_DIV_32         0x001F
.................... #define ADC_CLOCK_DIV_64         0x003F
.................... #define ADC_CLOCK_INTERNAL       0x8000     // Internal
.................... 
.................... // One of the following may be OR'ed in with the above using |
.................... // Auto-Sample Time bits
.................... #define ADC_TAD_MUL_0            0x1F00
.................... #define ADC_TAD_MUL_2            0x1D00
.................... #define ADC_TAD_MUL_4            0x1B00
.................... #define ADC_TAD_MUL_8            0x1700
.................... #define ADC_TAD_MUL_16           0x0F00
.................... #define ADC_TAD_MUL_31           0x0000
.................... 
.................... // Constants used in READ_ADC() are:
.................... #define ADC_START_AND_READ       0x07
.................... #define ADC_START_ONLY           0x01
.................... #define ADC_READ_ONLY            0x06
.................... 
.................... // Constants used in SET_ADC_CHANNEL() second parameter are:
.................... #define VSS                      0
.................... 
.................... // Constants used in SETUP_ADC_PORTS() are:
.................... // First argument:
.................... // OR together desired pins
.................... #define NO_ANALOGS      0           // None
.................... #define ALL_ANALOG      0xFFFFFFFF  // All
.................... #define sAN0      0x00000001 //| A0
.................... #define sAN1      0x00000002 //| A1
.................... #define sAN2      0x00000004 //| B0
.................... #define sAN3      0x00000008 //| B1
.................... #define sAN4      0x00000010 //| B2
.................... #define sAN5      0x00000020 //| B3
.................... #define sAN6      0x00000040 //| C0
.................... #define sAN7      0x00000080 //| C1
.................... #define sAN8      0x00000100 //| C2
.................... 
.................... // Optional Second argument:
.................... #define VSS_VDD            0x0000 // Range 0-Vdd
.................... #define VREF_VREF          0x6000 // Range VrefL-VrefH
.................... #define VREF_VDD           0x4000 // Range VrefL-Vdd
.................... #define VSS_VREF           0x2000 // Range 0-VrefH
.................... 
.................... ////////////////////////////////////////////////////////////////// COMP
.................... // Comparator Functions: setup_comparator()
.................... // Comparator Variables: C1OUT, C2OUT
.................... // Comparator Prototypes:
.................... _bif void setup_comparator(unsigned int16 mode);
.................... // Constants used in setup_comparator() are:
.................... #define NC_NC_NC_NC      0
.................... #define B2_B3_NC_NC      0x401
.................... #define B2_VR_NC_NC      0x400
.................... #define B3_VR_NC_NC      0x402
.................... #define NC_NC_B0_B1      0x804
.................... #define NC_NC_B0_VR      0x800
.................... #define NC_NC_B1_VR      0x808
.................... #define B2_B3_B0_B1      B2_B3_NC_NC | NC_NC_B0_B1
.................... #define B2_VR_B0_VR      B2_VR_NC_NC | NC_NC_B0_VR
.................... #define B3_VR_B1_VR      B3_VR_NC_NC | NC_NC_B1_VR
.................... 
.................... #define C1_INVERT     0x10
.................... #define C2_INVERT     0x20
.................... #define C1_OUTPUT     0x100
.................... #define C2_OUTPUT     0x200
.................... 
.................... #bit C1OUT = getenv("SFR:CMCON").6
.................... #bit C2OUT = getenv("SFR:CMCON").7
.................... 
.................... ////////////////////////////////////////////////////////////////// VREF
.................... // VREF Prototypes:
.................... _bif void setup_vref(unsigned int16 mode);
.................... // Constants used in setup_vref() are:
.................... #define VREF_DISABLED  0x0000
.................... #define VREF_VSS_VDD   0x0080
.................... #define VREF_ANALOG    0x0090
.................... // One of the following maybe OR'ed in with the above using |
.................... #define VREF_HIGH      0x0080
.................... #define VREF_LOW       0x00A0
.................... // The following maybe OR'ed in with the above using |
.................... #define VREF_OUTPUT    0x0040
.................... // Or (with |) the above with a number 0-15
.................... 
.................... ////////////////////////////////////////////////////////////////// PMP
.................... // PMP Functions: setup_pmp(), pmp_address(), psp_read(), pmp_read(),
.................... // psp_write(), pmp_write(), psp_output_full(),psp_input_full(),
.................... // psp_overflow(), pmp_output_full(), pmp_input_full(),
.................... // pmp_overflow()
.................... // PMP Prototypes:
.................... _bif void setup_pmp(unsigned int32 mode, unsigned int16 address_mask);
.................... _bif void pmp_address(unsigned int16 address);
.................... _bif unsigned int8 pmp_read(void);
.................... _bif void pmp_write(unsigned int8 data);
.................... _bif int1 pmp_output_full(void);
.................... _bif int1 pmp_input_full(void);
.................... _bif int1 pmp_overflow(void);
.................... _bif void setup_psp(unsigned int32 mode, unsigned int16 address_mask);
.................... _bif unsigned int8 psp_read(void);
.................... _bif unsigned int8 psp_read(unsigned int16 address);
.................... _bif void psp_write(unsigned int8 data);
.................... _bif void psp_write(unsigned int8 data, unsigned int16 address);
.................... _bif int1 psp_output_full(void);
.................... _bif int1 psp_input_full(void);
.................... _bif int1 psp_overflow(void);
.................... // Constants used in SETUP_PMP() and SETUP_PSP() are:
.................... #define PAR_ENABLE                0x8000
.................... #define PAR_DISABLE               0x0000    // Module enable/disable options
.................... #define PAR_STOP_IN_IDLE          0x2000
.................... #define PAR_CONTINUE_IN_IDLE      0x0000
.................... #define PAR_ADDR_NOT_MULTIPLEXED  0x0000    // Address multiplexing options
.................... #define PAR_LOW_ADDR_MULTIPLEXED  0x0800    // Address multiplexing options
.................... #define PAR_FULL_ADDR_MULTIPLEXED 0x1000    // Address multiplexing options
.................... #define PAR_PTBEEN_ENABLE         0x0400  // Byte Enable Port Enable bit
.................... #define PAR_PTWREN_ENABLE         0x0200  // Write Enable Strobe bit
.................... #define PAR_PTRDEN_ENABLE         0x0100  // Read/Write Strobe Port bit
.................... #define PAR_ALP_ACTIVE_HIGH       0x0020 // Address latch polarity high
.................... #define PAR_BEP_ACTIVE_HIGH       0x0004 // Byte Enable Polarity
.................... #define PAR_WRSP_ACTIVE_HIGH      0x0002 // Write strobe Polarity bit
.................... #define PAR_RDSP_ACTIVE_HIGH      0x0001 // Read strobe Polarity bit
.................... #define PAR_CS_XX                 0x0000   // Chip select pins used for address
.................... #define PAR_CS_X1                 0x0008   // Chip select pin 1 used, active high
.................... #define PAR_CS_X0                 0x0000   // Chip select pin 1 used, active low
.................... #define PAR_CS_1X                 0x0050   // Chip select pin 2 used, active high
.................... #define PAR_CS_0X                 0x0040   // Chip select pin 2 used, active low
.................... #define PAR_CS_00                 0x0080   // Chip select pins 1,2 used, active low
.................... #define PAR_CS_11                 0x0098   // Chip select pins 1,2 used, active high
.................... #define PAR_CS_10                 0x0090   // Chip select pins 1,2 used, 1 is active low, 2 is high
.................... #define PAR_CS_01                 0x0088   // Chip select pins 1,2 used, 1 is active high, 2 is low
.................... #define PAR_INTR_ON_RW                0x20000000  // Interrupt on read write
.................... #define PAR_NO_INTR_STALL_ACTIVATED   0x40000000  // No interrupt, processor stall activated
.................... #define PAR_INTR_ON_3_RW_BUF          0x60000000 // Interrupt on write to Buffer 3 or read from Buffer 3
.................... #define PAR_PSP_AUTO_INC              0x18000000 // Read write buffers auto increment
.................... #define PAR_DEC_ADDR                  0x10000000 // Increment the address
.................... #define PAR_INC_ADDR                  0x08000000 // Decrement the address
.................... #define PAR_MASTER_MODE_1             0x03000000  // Master mode 1
.................... #define PAR_MASTER_MODE_2             0x02000000  // Master mode 2
.................... #define PAR_WAITB1                    0x00000000 // 1 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB2                    0x00400000 // 2 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB3                    0x00800000 // 3 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB4                    0x00C00000 // 4 Tcy Wait state for data setup R/W
.................... #define PAR_WAITM0                    0x00000000 // 0 wait state for Read to byte
.................... #define PAR_WAITM1                    0x00040000 // 1 Tcy wait state for Read to byte
.................... #define PAR_WAITM2                    0x00080000 // 2 Tcy wait state for Read to byte
.................... #define PAR_WAITM3                    0x000C0000 // 3 Tcy wait state for Read to byte
.................... #define PAR_WAITM15                   0x003C0000 // 15 wait states
.................... #define PAR_WAITE1                    0x00000000  // 1 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE2                    0x00010000 // 2 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE3                    0x00020000 // 3 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE4                    0x00030000 // 4 Tcy Wait for data hold after strobe
.................... 
.................... ////////////////////////////////////////////////////////////////// CRC
.................... // CRC Functions: setup_crc(), crc_init(), crc_calc(), crc_calc8()
.................... // CRC Prototypes:
.................... _bif void setup_crc(unsigned int8 poly_terms, ...);
.................... _bif void crc_init(unsigned int16 value);
.................... _bif unsigned int16 crc_calc(unsigned int16 data);
.................... _bif unsigned int16 crc_calc(unsigned int16 *ptr, unsigned int16 count);
.................... _bif unsigned int8 crc_calc8(unsigned int8 data);
.................... _bif unsigned int8 crc_calc8(unsigned int8 *ptr, unsigned int16 count);
.................... 
.................... ////////////////////////////////////////////////////////////////// RTC
.................... // RTC Functions: setup_rtc(), setup_rtc_alarm(), rtc_read(),
.................... //                rtc_write(), rtc_alarm_read(), rtc_alarm_write()
.................... // Structure used in read and write functions (pass pointer):
.................... typedef struct {
....................    unsigned int8 tm_year;
....................    unsigned int8 tm_temp;  // Not used by built in functions, place holder only do not use
....................    unsigned int8 tm_mday;
....................    unsigned int8 tm_mon;
....................    unsigned int8 tm_hour;
....................    unsigned int8 tm_wday;
....................    unsigned int8 tm_sec;
....................    unsigned int8 tm_min;
....................    unsigned int8 tm_isdst; // Not used by built in functions
.................... } rtc_time_t;
.................... // RTC Prototypes:
.................... _bif void setup_rtc(unsigned int16 mode, unsigned int8 calibration);
.................... _bif void setup_rtc_alarm(unsigned int16 mode, unsigned int16 mask, unsigned int8 repeat);
.................... _bif void rtc_read(rtc_time_t *time);
.................... _bif void rtc_write(rtc_time_t *time);
.................... _bif void rtc_alarm_read(rtc_time_t *time);
.................... _bif void rtc_alarm_write(rtc_time_t *time);
.................... // Constants used in setup_rtc() are:  // Second param is calibration
.................... #define RTC_ENABLE           0x8000
.................... #define RTC_DISABLE          0
.................... #define RTC_OUTPUT_SECONDS   0x20400
.................... #define RTC_OUTPUT_ALARM     0x00400
.................... //
.................... // Constants used in setup_rtc_alarm() first param are:
.................... #define RTC_ALARM_ENABLE     0x8000
.................... #define RTC_ALARM_DISABLE    0
.................... #define RTC_CHIME_ENABLE     0x4000
.................... #define RTC_CHIME_DISABLE    0
.................... // Constants used in setup_rtc_alarm() second param are:  // Third param is repeat#
.................... #define RTC_ALARM_HALFSECOND 0x0000
.................... #define RTC_ALARM_SECOND     0x0400
.................... #define RTC_ALARM_10_SECONDS 0x0800
.................... #define RTC_ALARM_MINUTE     0x0C00
.................... #define RTC_ALARM_10_MINUTES 0x1000
.................... #define RTC_ALARM_HOUR       0x1400
.................... #define RTC_ALARM_DAY        0x1800
.................... #define RTC_ALARM_WEEK       0x1C00
.................... #define RTC_ALARM_MONTH      0x2000
.................... #define RTC_ALARM_YEAR       0x2400
.................... 
.................... ////////////////////////////////////////////////////////////////// QEI
.................... // QEI Functions: setup_qei(), qei_set_count(), qei_get_count(),
.................... //                qei_status()
.................... // QEI Prototypes:
.................... _bif void setup_qei(unsigned int16 mode, unsigned int16 filter, unsigned int16 maxcount);
.................... _bif void setup_qei(unsigned int8 unit, unsigned int16 mode, unsigned int16 filter, unsigned int16 maxcount);
.................... _bif void qei_set_count(unsigned int16 count);
.................... _bif void qei_set_count(unsigned int8 unit, unsigned int16 count);
.................... _bif unsigned int16 qei_get_count(void);
.................... _bif unsigned int16 qei_get_count(unsigned int8 unit);
.................... _bif unsigned int16 qei_status(void);
.................... _bif unsigned int16 qei_status(unsigned int8 unit);
.................... // Constants used in setup_qei() first param are:
.................... #define QEI_DISABLED        0
.................... #define QEI_MODE_X2         0x0400
.................... #define QEI_MODE_X4         0x0600
.................... #define QEI_MODE_TIMER      0x0100
.................... #define QEI_STOP_WHEN_IDLE  0x2000
.................... #define QEI_SWAP_AB         0x0080
.................... #define QEI_OUTPUT_ENABLE   0x0040
.................... #define QEI_RESET_WHEN_MAXCOUNT  0x0100
.................... #define QEI_RESET_WHEN_IDX_PULSE 0x0004
.................... #define QEI_TIMER_GATED      0x0020
.................... #define QEI_TIMER_INTERNAL   0x0000
.................... #define QEI_TIMER_EXTERNAL   0x0002
.................... #define QEI_TIMER_DIV_BY_1   0x0000
.................... #define QEI_TIMER_DIV_BY_8   0x0008
.................... #define QEI_TIMER_DIV_BY_64  0x0010
.................... #define QEI_TIMER_DIV_BY_256 0x0018
.................... // Constants used in setup_qei() second param are:   // Third param is MAXCOUNT
.................... #define QEI_FILTER_DIV_1     0x0000
.................... #define QEI_FILTER_DIV_2     0x0010
.................... #define QEI_FILTER_DIV_4     0x0020
.................... #define QEI_FILTER_DIV_16    0x0030
.................... #define QEI_FILTER_DIV_32    0x0040
.................... #define QEI_FILTER_DIV_64    0x0050
.................... #define QEI_FILTER_DIV_128   0x0060
.................... #define QEI_FILTER_DIV_256   0x0070
.................... #define QEI_FILTER_OUTPUT    0x0080
.................... #define QEI_NO_ERROR_INTS    0x0100
.................... #define QEI_IDX_WHEN_A0      0x0000  // for 2X mode
.................... #define QEI_IDX_WHEN_A1      0x0200  // for 2X mode
.................... #define QEI_IDX_WHEN_B0      0x0400  // for 2X mode
.................... #define QEI_IDX_WHEN_B1      0x0600  // for 2X mode
.................... #define QEI_IDX_WHEN_A0_B0   0x0000  // for 4X mode
.................... #define QEI_IDX_WHEN_A1_B0   0x0200  // for 4X mode
.................... #define QEI_IDX_WHEN_A0_B1   0x0400  // for 4X mode
.................... #define QEI_IDX_WHEN_A1_B1   0x0600  // for 4X mode
.................... // Constants returned from qei_status() are:
.................... #define QEI_POS_ERROR        0x8000
.................... #define QEI_FORWARD          0x0800
.................... #define QEI_INDEX_PIN        0x1000
.................... 
.................... ////////////////////////////////////////////////////////////////// MOTOR PWM
.................... // MPWM Functions: setup_motor_pwm(), set_motor_unit(),
.................... //                 set_motor_pwm_duty(), set_motor_pwm_event(),
.................... //                 get_motor_pwm_count()
.................... // MPWM Prototypes:
.................... _bif void setup_motor_pwm(unsigned int8 pwm, unsigned int32 mode, unsigned int32 timebase);
.................... _bif void setup_motor_pwm(unsigned int8 pwm, unsigned int32 mode, unsigned int8 prescale, unsigned int8 postscale, unsigned int16 period);
.................... _bif void set_motor_unit(unsigned int8 pwm, unsigned int8 pin_pair, unsigned int16 mode, unsigned int8 active_deadtime, unsigned int8 inactive_deadtime);
.................... _bif void set_motor_pwm_duty(unsigned int8 pwm, unsigned int8 pin_pair, unsigned int16 duty);
.................... _bif void set_motor_pmw_event(unsigned int8, signed int16 time);
.................... _bif unsigned int16 get_motor_pwm_count(unsigned int8 pwm);
.................... // Constants used in setup_motor_pwm() second param are (first param is unit number 1,2...):
.................... #define MPWM_DISABLED          0
.................... #define MPWM_FREE_RUN          0x8000
.................... #define MPWM_SINGLE_PULSE      0x8001
.................... #define MPWM_UP_DOWN           0x8002
.................... #define MPWM_UP_DOWN_WITH_INTS 0x8003
.................... // OR in any of the following:
.................... #define MPWM_HALT_WHEN_IDLE            0x2000
.................... #define MPWM_DUTY_UPDATES_IMMEADIATE  0x40000
.................... #define MPWM_SYNC_OVERRIDES           0x20000
.................... #define MPWM_DISABLE_UPDATES          0x10000
.................... #define MPWM_LATCH_FAULTS            0x100000
.................... 
.................... // Constants used in set_motor_unit() third param are:  (first param is unit number 1,2... and second param is pwm pin pair 1,2,3 or 4)
.................... #define MPWM_INDEPENDENT     0x0001
.................... #define MPWM_ENABLE          0x0006  // both H and L
.................... #define MPWM_ENABLE_H        0x0004
.................... #define MPWM_ENABLE_L        0x0002
.................... 
.................... #define MPWM_FORCE_L_0       0x0010
.................... #define MPWM_FORCE_L_1       0x0050
.................... #define MPWM_FORCE_H_0       0x0020
.................... #define MPWM_FORCE_H_1       0x00A0
.................... 
.................... #define MPWM_FAULTA_LA_HA     0x0700
.................... #define MPWM_FAULTA_LA_HI     0x0500
.................... #define MPWM_FAULTA_LI_HA     0x0600
.................... #define MPWM_FAULTA_LI_HI     0x0400
.................... #define MPWM_FAULTB_LA_HA     0x7000
.................... #define MPWM_FAULTB_LA_HI     0x5000
.................... #define MPWM_FAULTB_LI_HA     0x6000
.................... #define MPWM_FAULTB_LI_HI     0x4000
.................... #define MPWM_FAULT_NO_CHANGE 0x0000
.................... 
.................... ////////////////////////////////////////////////////////////////// DCI
.................... // DCI Functions: setup_dci(), dci_start(), dci_read(), dci_write(),
.................... //                dci_data_received(), dci_transmit_ready()
.................... // DCI Prototypes:
.................... _bif void setup_dci(unsigned int16 mode, unsigned int16 size, unsigned int16 receive_slot, unsigned int16 transmit_slot, unsigned int16 sample_rate);
.................... _bif void dci_start(void);
.................... _bif signed int16 dci_read(void);
.................... _bif void dci_write(signed int16);
.................... _bif int1 dci_data_received(void);
.................... _bif int1 dci_transmit_ready(void);
.................... // Constants used in setup_dci() first param are:
.................... #define MULTICHANNEL_MODE  0x0000
.................... #define I2S_MODE           0x0001
.................... #define AC97_16BIT_MODE    0x0002
.................... #define AC97_20BIT_MODE    0x0003
.................... 
.................... #define JUSTIFY_DATA       0x0020 //Start data transmission on the same clock cycle as COFS pulses (multichannel)
.................... #define MULTI_DEVICE_BUS   0x0040 //Tri-states the CSDO pin during unused time slots, normally drives '0'
.................... 
.................... #define UNDERFLOW_LAST     0x0080 //Transmits the last written value to the dci when data underflow occurs. Default is undeflow silence.
.................... #define UNDERFLOW_SILENCE  0x0000 //Transmit '0's on data undeflow. This will cause a clicking noise if you are underflowing data while outputing to a codec.
.................... 
.................... #define DCI_SLAVE          0x0100 //Default is master
.................... #define DCI_MASTER         0x0000
.................... 
.................... #define SAMPLE_FALLING_EDGE 0x0000 //Default is Sample on the rising edge of the clock
.................... #define SAMPLE_RISING_EDGE 0x0200
.................... 
.................... #define DCI_CLOCK_INPUT    0x0400 //SCLK is an input (supplied by codec or external source)
.................... #define DCI_CLOCK_OUTPUT   0x0000 //Default is clock output
.................... 
.................... #define ENABLE_LOOPBACK    0x0800 //Connect the CSDI/CSDO internally; loops all of the sound back onto the bus
.................... 
.................... #define CODEC_MULTICHANNEL  0x0000  //enables multichannel (generic) codec support
.................... #define CODEC_I2S           0x0001  //enables the I2S protocol
.................... #define CODEC_AC16          0x0002  //enables the AC-16 protocol, setupCodecTransmission has no effect
.................... #define CODEC_AC20          0x0003  //enables the AC-20 protocol, setupCodecTransmission has no effect
.................... 
.................... #define BUS_MASTER          0x0000  //designates this device as the bus master
.................... #define BUS_SLAVE           0x0300  //designates this device as a slave on a bus controlled by another codec
.................... 
.................... #define TRISTATE_BUS        0x0040        //when in master mode, the module will be in high impedance
....................                                     //during disabled frames (default drives 0's onto bus)
.................... #define SYNC_COFS_DATA_PULSE 0x0020 //signifies that data starts transmitting on the same SCK pulse as the edge of the COFS pulse
....................                                     //(default data starts on the clock after the rising edge of COFS
.................... /* Determines when a sample is taken */
.................... #define SAMPLE_RISING        0x0200 //sample data on the rising edge of the clock
.................... #define SAMPLE_FALLING       0x0000 //sample data on the falling edge of the clock
.................... 
.................... // Constants used in setup_dci() second param are:
.................... #define DCI_4BIT_WORD      0x0003
.................... #define DCI_5BIT_WORD      0x0004
.................... #define DCI_6BIT_WORD      0x0005
.................... #define DCI_7BIT_WORD      0x0006
.................... #define DCI_8BIT_WORD      0x0007
.................... #define DCI_9BIT_WORD      0x0008
.................... #define DCI_10BIT_WORD     0x0009
.................... #define DCI_11BIT_WORD     0x000A
.................... #define DCI_12BIT_WORD     0x000B
.................... #define DCI_13BIT_WORD     0x000C
.................... #define DCI_14BIT_WORD     0x000D
.................... #define DCI_15BIT_WORD     0x000E
.................... #define DCI_16BIT_WORD     0x000F
.................... 
.................... #define DCI_1WORD_FRAME    0x0000
.................... #define DCI_2WORD_FRAME    0x0010 << 1
.................... #define DCI_3WORD_FRAME    0x0020 << 1
.................... #define DCI_4WORD_FRAME    0x0030 << 1
.................... #define DCI_5WORD_FRAME    0x0040 << 1
.................... #define DCI_6WORD_FRAME    0x0050 << 1
.................... #define DCI_7WORD_FRAME    0x0060 << 1
.................... #define DCI_8WORD_FRAME    0x0070 << 1
.................... #define DCI_9WORD_FRAME    0x0080 << 1
.................... #define DCI_10WORD_FRAME   0x0090 << 1
.................... #define DCI_11WORD_FRAME   0x00A0 << 1
.................... #define DCI_12WORD_FRAME   0x00B0 << 1
.................... #define DCI_13WORD_FRAME   0x00C0 << 1
.................... #define DCI_14WORD_FRAME   0x00D0 << 1
.................... #define DCI_15WORD_FRAME   0x00E0 << 1
.................... #define DCI_16WORD_FRAME   0x00F0 << 1
.................... 
.................... #define DCI_1WORD_INTERRUPT 0x0000
.................... #define DCI_2WORD_INTERRUPT 0x0400
.................... #define DCI_3WORD_INTERRUPT 0x0800
.................... #define DCI_4WORD_INTERRUPT 0x0C00
.................... 
.................... // Constants used in setup_dci() third param are:
.................... #define RECEIVE_NONE    0x0000
.................... #define RECEIVE_ALL     0xFFFF
.................... #define RECEIVE_SLOT0   0x0001
.................... #define RECEIVE_SLOT1   0x0002
.................... #define RECEIVE_SLOT2   0x0004
.................... #define RECEIVE_SLOT3   0x0008
.................... #define RECEIVE_SLOT4   0x0010
.................... #define RECEIVE_SLOT5   0x0020
.................... #define RECEIVE_SLOT6   0x0040
.................... #define RECEIVE_SLOT7   0x0080
.................... #define RECEIVE_SLOT8   0x0100
.................... #define RECEIVE_SLOT9   0x0200
.................... #define RECEIVE_SLOT10  0x0400
.................... #define RECEIVE_SLOT11  0x0800
.................... #define RECEIVE_SLOT12  0x1000
.................... #define RECEIVE_SLOT13  0x2000
.................... #define RECEIVE_SLOT14  0x4000
.................... #define RECEIVE_SLOT15  0x8000
.................... 
.................... // Constants used in setup_dci() forth param are:
.................... #define TRANSMIT_NONE   0x0000
.................... #define TRANSMIT_ALL    0xFFFF
.................... #define TRANSMIT_SLOT0  0x0001
.................... #define TRANSMIT_SLOT1  0x0002
.................... #define TRANSMIT_SLOT2  0x0004
.................... #define TRANSMIT_SLOT3  0x0008
.................... #define TRANSMIT_SLOT4  0x0010
.................... #define TRANSMIT_SLOT5  0x0020
.................... #define TRANSMIT_SLOT6  0x0040
.................... #define TRANSMIT_SLOT7  0x0080
.................... #define TRANSMIT_SLOT8  0x0100
.................... #define TRANSMIT_SLOT9  0x0200
.................... #define TRANSMIT_SLOT10 0x0400
.................... #define TRANSMIT_SLOT11 0x0800
.................... #define TRANSMIT_SLOT12 0x1000
.................... #define TRANSMIT_SLOT13 0x2000
.................... #define TRANSMIT_SLOT14 0x4000
.................... #define TRANSMIT_SLOT15 0x8000
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////// DMA
.................... // DMA Functions: setup_dma(), dma_start(), dma_status()
.................... // DMA Prototypes:
.................... _bif void setup_dma(unsigned int8 channel, unsigned int32 pheripheral, unsigned int8 mode);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 count);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 addressb);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 addressb, unsigned int16 count);
.................... _bif unsigned int8 dma_status(unsigned int8 channel);
.................... // Constants used in setup_dma() second param are:
.................... #define DMA_IN_SPI1      (0x0A0000|getenv("sfr:SPI1BUF"))
.................... #define DMA_OUT_SPI1     (0x8A0000|getenv("sfr:SPI1BUF"))
.................... #define DMA_IN_SPI2      (0x210000|getenv("sfr:SPI2BUF"))
.................... #define DMA_OUT_SPI2     (0xA10000|getenv("sfr:SPI2BUF"))
.................... #define DMA_IN_UART1     (0x0B0000|getenv("sfr:U1RXREG"))
.................... #define DMA_OUT_UART1    (0x8C0000|getenv("sfr:U1TXREG"))
.................... #define DMA_IN_UART2     (0x1E0000|getenv("sfr:U2RXREG"))
.................... #define DMA_OUT_UART2    (0x9F0000|getenv("sfr:U2TXREG"))
.................... #define DMA_IN_ADC1      (0x0D0000|getenv("sfr:ADC1BUF0"))
.................... ////////////////////////////////////////////////////////////////// DAC
.................... // Digital to Analog Functions: SETUP_DAC(), DAC_WRITE()
.................... // DAC Prototypes:
.................... _bif void setup_dac(unsigned int32 mode);
.................... _bif void setup_dac(unsigned int32 mode, unsigned int8 divisor);
.................... _bif void dac_write(unsigned int8 channel, unsigned value);
.................... // Constants used in SETUP_DAC() are:
.................... #define DAC_OFF  0
.................... #define DAC_RIGHT_ON   0x00808000
.................... #define DAC_LEFT_ON    0x80008000
.................... #define DAC_RIGHT_MIDPOINT 0x00A08000
.................... #define DAC_LEFT_MIDPOINT  0xA0008000
.................... #define DAC_SIGNED   0x100
.................... #define DAC_SLEEP_ON 0x1000
.................... #define DAC_IDLE_OFF 0x2000
.................... // Constants used as the first param in DAC_WRITE() are:
.................... #define DAC_DEFAULT  0
.................... #define DAC_RIGHT    1
.................... #define DAC_LEFT     2
.................... 
.................... #define DMA_IN_ECAN1     (0x220000|getenv("sfr:C1RXD"))
.................... #define DMA_OUT_ECAN1    (0xC60000|getenv("sfr:C1TXD"))
.................... #define DMA_INT0         0x000000 // or in direction and perif address
.................... #define DMA_IC1          0x010000 // or in direction and perif address
.................... #define DMA_IN_IC1       (0x010000|getenv("sfr:IC1BUF"))
.................... #define DMA_IC2          0x050000 // or in direction and perif address
.................... #define DMA_IN_IC2       (0x050000|getenv("sfr:IC2BUF"))
.................... #define DMA_OC1          0x020000 // or in direction and perif address
.................... #define DMA_OC2          0x060000 // or in direction and perif address
.................... #define DMA_TIMER2       0x070000 // or in direction and perif address
.................... #define DMA_TIMER3       0x080000 // or in direction and perif address
.................... #define DMA_OUT_DCI      (0xBC0000|getenv("sfr:TXBUF0"))
.................... #define DMA_IN_DCI       (0x3C0000|getenv("sfr:RXBUF0"))
.................... #define DMA_OUT_DACR     (0xCE0000|getenv("sfr:DAC1RDAT"))
.................... #define DMA_OUT_DACL     (0xCF0000|getenv("sfr:DAC1LDAT"))
.................... #define DMA_IN          0x00
.................... #define DMA_OUT         0x800000
.................... // Constants used in setup_dma() third param are:
.................... #define DMA_BYTE        0x40
.................... #define DMA_WORD        0x00  // default
.................... #define DMA_HALF_INT    0x10  // interrupt when half full
.................... #define DMA_WRITE_NULL  0x08
.................... // Constants used in dma_start() second param are:
.................... #define DMA_CONTINOUS   0x00
.................... #define DMA_ONE_SHOT    0x01
.................... #define DMA_PING_PONG   0x02
.................... #define DMA_NO_INC      0x10
.................... #define DMA_PERIF_ADDR  0x20 // Device supplies address
.................... #define DMA_FORCE_NOW  0x100
.................... // Constants returned from dma_status() are:
.................... #define DMA_IN_ERROR    0x01
.................... #define DMA_OUT_ERROR   0x02
.................... #define DMA_B_SELECT    0x04
.................... 
.................... ////////////////////////////////////////////////////////////////// BIF
.................... // Built In Functions Prototypes
.................... //
.................... // Math Prototypes:
.................... _bif signed int8 abs(signed int8 x);
.................... _bif signed int16 abs(signed int16 x);
.................... _bif signed int32 abs(signed int32 x);
.................... _bif float32 abs(float32 x);
.................... _bif unsigned int16 _mul(unsigned int8, unsigned int8);
.................... _bif signed int16 _mul(signed int8, signed int8);
.................... _bif unsigned int32 _mul(unsigned int16, unsigned int16);
.................... _bif signed int32 _mul(signed int16, signed int16);
.................... _bif signed int48 abs(signed int48 x);
.................... _bif signed int64 abs(signed int64 x);
.................... _bif float48 abs(float48 x);
.................... _bif float64 abs(float64 x);
.................... _bif unsigned int64 _mul(unsigned int32, unsigned int32);
.................... _bif signed int64 _mul(signed int32, signed int32);
.................... _bif unsigned int64 _mul(unsigned int48, unsigned int48);
.................... _bif signed int64 _mul(signed int48, signed int48);
.................... 
.................... // Memory Manipulation Prototypes:
.................... _bif void strcpy(char* dest, char* src);
.................... _bif void memset(unsigned int8* destination, unsigned int8 value, unsigned int16 num);
.................... _bif void memcpy(unsigned int8* destination, unsigned int8* source, unsigned int16 num);
.................... 
.................... // Data Manipulators Prototypes:
.................... _bif int1 shift_left(unsigned int8* address, unsigned int8 bytes, int1 value);
.................... _bif int1 shift_right(unsigned int8* address, unsigned int8 bytes, int1 value);
.................... _bif void rotate_left(unsigned int8* address, unsigned int8 bytes);
.................... _bif void rotate_right(unsigned int8* address, unsigned int8 bytes);
.................... _bif void swap(unsigned int8 value);
.................... _bif unsigned int8 make8(unsigned int16 var, unsigned int8 offset);
.................... _bif unsigned int8 make8(unsigned int32 var, unsigned int8 offset);
.................... _bif unsigned int16 make16(unsigned int8 varhigh, unsigned int8 varlow);
.................... _bif unsigned int32 make32(unsigned int16 var1);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int16 var2);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int8 var2);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int8 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int8 var3, unsigned int8 var4);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int16 var2);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int16 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int16 var3);
.................... _bif void bit_set(unsigned int8 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int16 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int32 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int8 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int16 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int32 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int8 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int16 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int32 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int48 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int64 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int48 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int64 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int48 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int64 var, unsigned int8 bit);
.................... _bif unsigned int8 bit_first(int1 value, unsigned int16 var);
.................... _bif unsigned int8 bit_last(int16 var);
.................... _bif unsigned int8 bit_last(int1 value, int16 var);
.................... 
.................... // #use delay() Prototypes:
.................... _bif void delay_cycles(unsigned int16 count);
.................... _bif void delay_ms(unsigned int16 time);
.................... _bif void delay_us(unsigned int16 time);
.................... 
.................... // #use rs232() Prototypes:
.................... _bif void putchar(char cdata);
.................... _bif void putchar(char cdata, unsigned int8 stream);
.................... _bif void puts(char* string);
.................... _bif void puts(char* string, unsigned int8 stream);
.................... _bif char getch(void);
.................... _bif char getch(unsigned int8 stream);
.................... _bif void gets(char* string);
.................... _bif void gets(char* string, unsigned int8 stream);
.................... _bif int1 kbhit(void);
.................... _bif int1 kbhit(unsigned int8 stream);
.................... _bif void printf(char* string, ...);
.................... _bif void fprintf(unsigned int8 stream, char* string, ...);
.................... _bif void putc_send(void);
.................... _bif void fputc_send(unsigned int8 stream);
.................... _bif int1 rcv_buffer_full(void);
.................... _bif int1 rcv_buffer_full(unsigned int8 stream);
.................... _bif unsigned int16 rcv_buffer_bytes(void);
.................... _bif unsigned int16 rcv_buffer_bytes(unsigned int8 stream);
.................... _bif int1 tx_buffer_full(void);
.................... _bif int1 tx_buffer_full(unsigned int8 stream);
.................... _bif unsigned int16 tx_buffer_bytes(void);
.................... _bif unsigned int16 tx_buffer_bytes(unsigned int8 stream);
.................... 
.................... // #use i2c() Prototypes:
.................... _bif unsigned int8 i2c_read(void);
.................... _bif unsigned int8 i2c_read(unsigned int8 stream);
.................... _bif unsigned int8 i2c_read(unsigned int8 stream, int1 ack);
.................... _bif int1 i2c_write(unsigned int8 data);
.................... _bif int1 i2c_write(unsigned int8 stream, unsigned int8 data);
.................... _bif void i2c_start(void);
.................... _bif void i2c_start(unsigned int8 stream);
.................... _bif void i2c_start(unsigned int8 stream, unsigned int8 restart);
.................... _bif void i2c_stop(void);
.................... _bif void i2c_stop(unsigned int8 stream);
.................... _bif int8 i2c_isr_state(void);
.................... _bif void i2c_slaveaddr(unsigned int8 addr);
.................... _bif void i2c_slaveaddr(unsigned int8 stream, unsigned int8 addr);
.................... _bif int1 i2c_poll(void);
.................... _bif int1 i2c_poll(unsigned int8 stream);
.................... _bif void i2c_init(unsigned int32 baud);
.................... _bif void i2c_init(unsigned int8 stream, unsigned int32 baud);
.................... 
.................... // #use spi() Prototypes:
.................... _bif unsigned int8 spi_xfer(void);
.................... _bif unsigned int16 spi_xfer(void);
.................... _bif unsigned int32 spi_xfer(void);
.................... _bif unsigned int8 spi_xfer(unsigned int8 data);
.................... _bif unsigned int16 spi_xfer(unsigned int16 data);
.................... _bif unsigned int32 spi_xfer(unsigned int32 data);
.................... _bif unsigned int8 spi_xfer(unsigned int8 stream, unsigned int8 data);
.................... _bif unsigned int16 spi_xfer(unsigned int8 stream, unsigned int16 data);
.................... _bif unsigned int32 spi_xfer(unsigned int8 stream, unsigned int32 data);
.................... _bif unsigned int8 spi_xfer(unsigned int8 stream, unsigned int8 data, unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer(unsigned int8 stream, unsigned int16 data, unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer(unsigned int8 stream, unsigned int32 data, unsigned int8 bits);
.................... _bif void spi_init(unsigned int32 baud);
.................... _bif void spi_init(unsigned int8 stream, unsigned int32 baud);
.................... _bif void spi_speed(unsigned int32 baud);
.................... _bif void spi_speed(unsigned int8 stream, unsigned int32 baud);
.................... _bif void spi_speed(unsigned int8 stream, unsigned int32 baud, unsigned int32 clock);
.................... _bif void spi_prewrite(unsigned int8 data);
.................... _bif void spi_prewrite(unsigned int16 data);
.................... _bif void spi_prewrite(unsigned int32 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int8 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int16 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int32 data);
.................... _bif unsigned int8 spi_xfer_in(void);
.................... _bif unsigned int16 spi_xfer_in(void);
.................... _bif unsigned int32 spi_xfer_in(void);
.................... _bif unsigned int8 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int8 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... 
.................... // #use rtos() Prototypes:
.................... _bif void rtos_run(void);
.................... _bif void rtos_yield(void);
.................... _bif void rtos_enable(unsigned int8 task);
.................... _bif void rtos_disable(unsigned int8 task);
.................... _bif void rtos_terminate(void);
.................... _bif void rtos_await(int1 flag);
.................... _bif void rtos_wait(unsigned int8 sem);
.................... _bif void rtos_signal(unsigned int8 sem);
.................... _bif void rtos_msg_send(unsigned int8 task, unsigned int8 msg);
.................... _bif unsigned int8 rtos_msg_read(void);
.................... _bif unsigned int8 rtos_msg_poll(void);
.................... _bif int1 rtos_overrun(unsigned int8 task);
.................... _bif void rtos_stats(unsigned int8 task, unsigned int8* stat);
.................... 
.................... // #use timer() Prototypes:
.................... _bif unsigned int8 get_ticks(void);
.................... _bif unsigned int16 get_ticks(void);
.................... _bif unsigned int32 get_ticks(void);
.................... _bif unsigned int64 get_ticks(void);
.................... _bif unsigned int8 get_ticks(unsigned int8 stream);
.................... _bif unsigned int16 get_ticks(unsigned int8 stream);
.................... _bif unsigned int32 get_ticks(unsigned int8 stream);
.................... _bif unsigned int64 get_ticks(unsigned int8 stream);
.................... _bif void set_ticks(unsigned int8 value);
.................... _bif void set_ticks(unsigned int16 value);
.................... _bif void set_ticks(unsigned int32 value);
.................... _bif void set_ticks(unsigned int64 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int8 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int16 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int32 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int64 value);
.................... 
.................... // #use pwm() Prototypes:
.................... _bif void pwm_on(void);
.................... _bif void pwm_on(unsigned int8 stream);
.................... _bif void pwm_off(void);
.................... _bif void pwm_off(unsigned int8 stream);
.................... _bif void pwm_set_duty(unsigned int16 duty);
.................... _bif void pwm_set_duty(unsigned int8 stream, unsigned int16 duty);
.................... _bif void pwm_set_duty_percent(unsigned int16 percent);
.................... _bif void pwm_set_duty_percent(unsigned int8 stream, unsigned int16 percent);
.................... _bif void pwm_set_frequency(unsigned int32 frequency);
.................... _bif void pwm_set_frequency(unsigned int8 stream, unsigned int32 frequency);
.................... 
.................... // #use capture() Prototypes:
.................... _bif unsigned int16 get_capture_time(void);
.................... _bif unsigned int16 get_capture_time(unsigned int8 stream);
.................... _bif int1 get_capture_event(void);
.................... _bif int1 get_capture_event(unsigned int8 stream);
.................... 
.................... // Environment Prototypes:
.................... //_bif unsigned int8 getenv(char* cstring);
.................... 
.................... // Address Prototypes:
.................... #ifndef __ADDRESS__
.................... #define __ADDRESS__ unsigned int32
.................... #endif
.................... _bif void goto_address(__ADDRESS__ address);
.................... _bif __ADDRESS__ label_address(__ADDRESS__ label);
.................... 
.................... // Program Memory Prototypes:
.................... _bif void read_program_memory(__ADDRESS__ address, unsigned int8* dataptr, unsigned int16 count);
.................... _bif void erase_program_memory(__ADDRESS__ address);
.................... _bif void write_program_memory(__ADDRESS__ address, unsigned int8* dataptr, unsigned int16 count);
.................... _bif void read_configuration_memory(unsigned int8* dataptr, unsigned int8 count);
.................... _bif void write_configuration_memory(unsigned int8* dataptr, unsigned int8 count);
.................... 
.................... ////////////////////////////////////////////////////////////////// INT
.................... // Interrupt Functions: ENABLE_INTERRUPTS(), DISABLE_INTERRUPTS(),
.................... //                      CLEAR_INTERRUPT(), INTERRUPT_ACTIVE(),
.................... //                      EXT_INT_EDGE()
.................... // INT Prototypes:
.................... _bif void enable_interrupts(unsigned int16 interrupt);
.................... _bif void disable_interrupts(unsigned int16 interrupt);
.................... _bif void clear_interrupt(unsigned int16 interrupt);
.................... _bif int1 interrupt_active(unsigned int16 interrupt);
.................... _bif int1 interrupt_enabled(unsigned int16 interrupt);
.................... _bif void ext_int_edge(unsigned int8 source, unsigned int8 edge);
.................... _bif void jump_to_isr(unsigned int16 address);
.................... // Constants used in EXT_INT_EDGE() are:
.................... #define L_TO_H              0x40
.................... #define H_TO_L                 0
.................... //
.................... // Constants used in other interrupt functions are:
.................... #define INTR_GLOBAL               0x400
.................... #define GLOBAL                    0x400  // For compatibility with PIC16/18
.................... #define INTR_NORMAL               0x100
.................... #define INTR_ALTERNATE            0x200
.................... #define INTR_LEVEL0               0x500
.................... #define INTR_LEVEL1               0x501
.................... #define INTR_LEVEL2               0x502
.................... #define INTR_LEVEL3               0x503
.................... #define INTR_LEVEL4               0x504
.................... #define INTR_LEVEL5               0x505
.................... #define INTR_LEVEL6               0x506
.................... #define INTR_LEVEL7               0x507
.................... 
.................... #define INTR_CN_PIN              0x8000  // or in a PIN_xx constant
.................... 
.................... #define INT_OSCFAIL               1
.................... #define INT_ADDRERR               2
.................... #define INT_STACKERR              3
.................... #define INT_MATHERR               4
.................... #define INT_DMAERR                5
.................... #define INT_EXT0                  6
.................... #define INT_IC1                   7
.................... #define INT_OC1                   8
.................... #define INT_TIMER1                9
.................... #define INT_DMA0                  69
.................... #define INT_IC2                   70
.................... #define INT_OC2                   71
.................... #define INT_TIMER2                72
.................... #define INT_TIMER3                73
.................... #define INT_SPI1E                 74
.................... #define INT_SPI1                  75
.................... #define INT_RDA                   76
.................... #define INT_TBE                   77
.................... #define INT_ADC1                  78
.................... #define INT_DMA1                  79
.................... #define INT_SI2C                  81
.................... #define INT_MI2C                  82
.................... #define INT_CNI                   84
.................... #define INT_EXT1                  85
.................... #define INT_IC7                   87
.................... #define INT_IC8                   88
.................... #define INT_DMA2                  89
.................... #define INT_OC3                   90
.................... #define INT_OC4                   91
.................... #define INT_TIMER4                92
.................... #define INT_TIMER5                93
.................... #define INT_EXT2                  94
.................... #define INT_RDA2                  95
.................... #define INT_TBE2                  96
.................... #define INT_SPI2E                 97
.................... #define INT_SPI2                  98
.................... #define INT_C1RX                  99
.................... #define INT_CAN1                  100
.................... #define INT_DMA3                  101
.................... #define INT_PWM1                  110
.................... #define INT_DMA4                  111
.................... #define INT_QEI                   123
.................... #define INT_DMA5                  126
.................... #define INT_PWM2                  127
.................... #define INT_FAULTA                128
.................... #define INT_UART1E                130
.................... #define INT_UART2E                131
.................... #define INT_QEI2                  132
.................... #define INT_DMA6                  133
.................... #define INT_DMA7                  134
.................... #define INT_C1TX                  135
.................... #define INT_FAULTA2               139
.................... #define INT_COMP                  152
.................... #define INT_PMP                   164
.................... #define INT_RTC                   173
.................... #define INT_CRC                   174
.................... #define INT_DAC1R                 177
.................... #define INT_DAC1L                 178
.................... 
.................... #list
.................... 
.................... #endif
.................... 
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... #include "algoritmo.h"
.................... /**
....................  @file    ALGORITMO.h
....................  @author  Ricardo Gomez, Klaudija Ziliute
....................  @brief   PanTompkins header file
.................... */
.................... 
.................... 
.................... #ifndef __ALGORITMO_H
.................... #define __ALGORITMO_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... 
.................... #WORD ADC1BUF0 = 0x0300;
.................... #WORD ADC1CON1 = 0x0320;
.................... #WORD ADC1CON2 = 0x0322;
.................... #WORD ADC1CON3 = 0x0324;
.................... #WORD AD1CHS0 = 0x0328;
.................... #WORD AD1PCFGL = 0x032C;
.................... #WORD IFS0 = 0x0084;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "BEEP.h"
.................... /**
....................  @file    BEEP.h
....................  @author  Julio Gomis-Tena
....................  @brief   Generate n "beeps" of variable frequency
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __BEEP_H
.................... #define __BEEP_H
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #pin_select OC2 = BUZZER
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void); //Inicializa las frecuencias de los beeps y la separaciÃ³n entre ellos
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP(unsigned int8); //Realiza n beeps
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __BEEP_H
.................... 
.................... 
.................... 
.................... int algoritmo(void);
.................... void init_algoritmo(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ALGORITMO_H
.................... 
.................... #include "SD_Card.h"
.................... /**
....................  @file    SD_CARD.h
....................  @author  Ricardo Gomez, Klaudija Ziliute
....................  @brief   PanTompkins header file
.................... */
.................... 
.................... 
.................... #ifndef __SD_CARD_H
.................... #define __SD_CARD_H
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... #include "miFAT.h"
.................... 
.................... #ifndef __MIFAT_H
.................... #define __MIFAT_H
.................... // Definidos en sdcard.h - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... extern unsigned int8 dt[512];
.................... extern unsigned int32 LBA0;
.................... extern unsigned int8 sd_init();
.................... extern unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr);
.................... extern unsigned int8 sd_read_block( unsigned int32 address, unsigned char* ptr);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define MAX_ENTRIES_SECTOR_FAT16        256
.................... #define ENDFILE16                    0xFFFF
.................... #define MAX_ENTRIES_SECTOR_FAT32        128
.................... #define ENDFILE32                0x0FFFFFFF
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... typedef struct{
.................... 	union{
.................... 		unsigned int8 raw[32];
.................... 		struct fields{
.................... 			char name[8];
.................... 			char extension[3];
.................... 			unsigned int8 attrib;			///sï¿½lo lectura, oculto, de sistema, directorio...
.................... 			//unsigned int8 reserved[10];
.................... 			  unsigned int8  reserved;
.................... 	 		  unsigned int8  createTimeMs;
.................... 			  unsigned int16 create_hour;
.................... 			  unsigned int16 create_date;
.................... 			  unsigned int16 last_access;
.................... 			  unsigned int16 eaIndex;
.................... 			  unsigned int16 modif_hour;
.................... 			  unsigned int16 modif_date;
.................... 			  unsigned int16 first_cluster;	///primer cluster (direcciona tabla FAT y sector para escribir contenido)
.................... 			  unsigned int32 size;			///tamaï¿½o en bytes
.................... 		};
.................... 	};
.................... } fileEntry;
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... typedef struct{
.................... 	unsigned int32 currentCluster;
.................... 	unsigned int32 currentSector;
.................... 	unsigned int16 posInSector;      //posiciï¿½n actual al escribir en el sector
.................... 	unsigned int32 sectorAtFAT;      //sector de la 1ï¿½ FAT en el que tenemos el actual puntero de cierre de fichero
.................... 
.................... 	unsigned int32 sectorEntryFile; //direcciï¿½n del sector de entradas de fichero
.................... 	unsigned int8  EntryFile[512];  //sector donde estï¿½ la entrada (root) del fichero (para actualizar tamaï¿½o)
.................... 	unsigned int16 offsetEntry;     //offset en el sector de entradas del fichero
.................... 	unsigned int32 size;            //tamaï¿½o del fichero
.................... }_file;
.................... 
.................... _file file;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... typedef struct _diskinforec{
....................    unsigned int8  jmpBoot[3];   // bytes  0.. 2: Salto a la rutina de arranque
....................    unsigned int8  OEMName[8];   // bytes  3..10: Es una cadena "MSDOS5.0"
....................    unsigned int16 BytsPerSec;   // bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes)
....................    unsigned int8  SectPerClus;  // byte  13:    Numero de sectores contenidos en 1 cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes
....................    unsigned int16 RsrvdCnt;     // bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente
....................    unsigned int8  NumFATs;      // byte  16:    Numero de tablas FAT en el volumen. Habitualmente es 2
....................    unsigned int16 RootEntCnt;   // bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
....................    unsigned int16 TotSect16;    // bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0)
....................    unsigned int8  Media;        // byte  21:    Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0
....................    unsigned int16 FATsz16;      // bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0)
....................    unsigned int16 SectPerTrack; // bytes 24..25: Sectores por track
....................    unsigned int16 NumHeads;     // bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.)
....................    unsigned int32 HiddSec;      // bytes 28..31: Sectores ocultos que preceden a la particion (irrelevante en uSD)
....................    unsigned int32 TotSect32;    // bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta
....................    unsigned int32 FATsz32;      // bytes 36..39: Numero de sectores ocupados por una FAT
....................    unsigned int16 ExtFlags;     // bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0)
....................    unsigned int16 FSVer;        // bytes 42..43: Version del sistema de archivos (empleamos la 0.0)
....................    unsigned int32 RootClus;     // bytes 44..47: Indica el numero del 1er cluster del directorio raiz.
....................    unsigned int16 FSInfo;       // bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1)
....................    unsigned int16 BkBootSec;    // bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque
....................    unsigned int8  RsrvdSys[12]; // bytes 52..63: Bytes reservados para futuros usos del sistema
....................    unsigned int8  DrvNum;       // byte  64:     Numero de la unidad (para MSDOS pero irrelevante en uSD).
....................    unsigned int8  Reserved1;    // byte  65:     Windows NT para formatear un volumen pone este byte a 0
....................    unsigned int8  BootSig;      // byte  66:     Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows)
....................    unsigned int32 VolId;        // bytes 67..70: Numero de volumen (generado por el reloj del sistema).
....................    unsigned int8  VolLab[11];   // bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME     ". Nosotros podemos poner "NUUBO_SD    "
....................    unsigned int8  FilSysType[8];// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   "
....................    unsigned int8  spam[420];    // bytes 90..509:Zona de codigo (no lo empleamos y esta a 0)
....................    unsigned int16 firma;        // byte 510..511:Debe de vale 55 AA
.................... } diskinforec;
.................... 
.................... diskinforec DiskInfo;
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned  int8 FATType; // FAT16 o FAT32
.................... //variables clave: inicio de la FAT1 y la FAT2 y de las entradas de ficheros
.................... unsigned  int8 sect_x_cluster;
.................... unsigned int16 sect_fat_1;
.................... unsigned int16 sect_fat_2;
.................... unsigned int32 sect_ini_datos;
.................... unsigned int32 sect_x_fat;
.................... unsigned int32 sect_entry;
.................... unsigned int16 sect_reserv;
.................... 
.................... //unsigned int8 dFil[32];
.................... unsigned int32 sector_fat32[MAX_ENTRIES_SECTOR_FAT32]; // 128 x 4 = 512
.................... unsigned int16 sector_fat16[MAX_ENTRIES_SECTOR_FAT16]; // 256 x 2 = 512
.................... 
.................... //atributos
.................... #define __FILE		0x20
.................... #define _DIRECTORY	0x10
.................... #define _VOLUMEN	0x08
.................... #define _SYSTEM		0x04
.................... #define _HIDDEN		0x02
.................... #define READONLY	0x01
.................... 
.................... ///variables globales
.................... unsigned int16 year = 2020;
.................... unsigned int8 yearLo=   20;
.................... unsigned int8 month =   10;
.................... unsigned int8 day   =	15;
.................... unsigned int8 hour	=   12;
.................... unsigned int8 minute=   34;
.................... unsigned int8 second=   56;
.................... 
.................... ///funciones
.................... #define getHour() (int16)((int16)hour << 11) + (int16)((int16)minute << 5) + (int16) (second >> 1)		//5 bits: horas, 6 bits: minutos, 5 bits: segundos/2
.................... #define getDate() (((int16)year - 1980) << 9 ) + ((int16)month << 5) + (int16)day	//7 bits: aï¿½o (desde 1980), 4 bits: mes, 5 bits: dia
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... void initFAT(){
....................    unsigned int32 startClusterOfRootDirectory = 2;
....................    unsigned int32 sctrs;
....................    unsigned  int8 *ptrSct;
....................    diskinforec *ptrDiskInfo;
.................... 
.................... 	sd_read_block(LBA0, dt);
....................     						ptrDiskInfo=&DiskInfo;
....................     						ptrSct= &dt[0];
....................    	memcpy((*ptrDiskInfo).jmpBoot, (ptrSct +  0), 3); 			//DiskInfo.jmpBoot[3]	// bytes  0.. 2: Salto a la rutina de arranque
....................    	memcpy((*ptrDiskInfo).OEMName, (ptrSct +  3), 8); 			//DiskInfo.OEMName[8]	// bytes  3..10: Es una cadena, habitualmente "MSDOS5.0"
....................    	DiskInfo.BytsPerSec = make16(dt[12],dt[11]);   				// bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes)
.................... 	DiskInfo.SectPerClus = dt[13];								// byte  13:	 Numero de sectores contenidos en un cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes
.................... 	DiskInfo.RsrvdCnt = make16(dt[15],dt[14]);					// bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente
....................    	DiskInfo.NumFATs = dt[16];									// byte  16:	 Numero de tablas FAT en el volumen. Habitualmente es 2
.................... 	DiskInfo.RootEntCnt = make16(dt[18],dt[17]);				// bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
....................    	DiskInfo.TotSect16 = make16(dt[20],dt[19]);					// bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0)
.................... 	DiskInfo.Media = dt[21];									// byte  21:	 Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0
.................... 	DiskInfo.FATsz16 = make16(dt[23],dt[22]);					// bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0)
.................... 	DiskInfo.SectPerTrack = make16(dt[25],dt[24]); 				// bytes 24..25: Sectores por track
....................    	DiskInfo.NumHeads = make16(dt[27],dt[26]);					// bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.)
.................... 	DiskInfo.HiddSec = make32(dt[31],dt[30],dt[29],dt[28]);		// bytes 28..31: Sectores ocultos que preceden a la particion
.................... 	DiskInfo.TotSect32=make32(dt[35],dt[34],dt[33],dt[32]);		// bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta
.................... 	DiskInfo.FATsz32 = make32(dt[39],dt[38],dt[37],dt[36]);		// bytes 36..39: Numero de sectores ocupados por una FAT
.................... 	DiskInfo.ExtFlags = make16(dt[41],dt[40]); 					// bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0)
.................... 	DiskInfo.FSVer = make16(dt[43],dt[42]); 					// bytes 42..43: Version del sistema de archivos (empleamos la 0.0)
.................... 	DiskInfo.RootClus= make32(dt[47],dt[46],dt[45],dt[44]);		// bytes 44..47: Indica el numero del 1er cluster del directorio raiz.
.................... 	DiskInfo.FSInfo = make16(dt[49],dt[48]); 					// bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1)
.................... 	DiskInfo.BkBootSec = make16(dt[51],dt[50]); 				// bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque
.................... 	//  Estructura en el caso de FAT32 ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½
.................... 	memcpy((*ptrDiskInfo).RsrvdSys, (ptrSct +  52), 12);		//DiskInfo.RsrvdSys[12] 	// bytes 52..63: Bytes reservados para futuros usos del sistema
.................... 	DiskInfo.DrvNum = dt[64];								 	// byte  64: 	 Numero de la unidad
.................... 	DiskInfo.Reserved1 = dt[65];								// byte  65: 	 Windows NT para formatear un volumen pone este byte a 0
.................... 	DiskInfo.BootSig = dt[66]; 									// byte  66: 	 Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows)
.................... 	DiskInfo.VolId = make32(dt[70],dt[69],dt[68],dt[67]); 		// bytes 67..70: Numero de volumen (generado por el reloj del sistema).
.................... 	memcpy((*ptrDiskInfo).VolLab, (ptrSct +  71), 11);			//DiskInfo.VolLab[11]	// bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME    "
.................... 	memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  82), 8);		//DiskInfo.FilSysType[8] 	// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   "
.................... 	memcpy((*ptrDiskInfo).spam, (ptrSct +  90),420);			//DiskInfo.spam[420]		// bytes 90..509:Zona de codigo (en uSD no se emplea y suele estar a 0)
.................... 	DiskInfo.firma = make16(dt[510],dt[511]);								// byte 510..511:Debe de vale 55 AA
.................... 
....................    		FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'3''2'
.................... 
....................    if(FATType == 32){
.................... 						sect_x_fat  = DiskInfo.FATsz32;		// Sectores reservados para la FAT
.................... 						startClusterOfRootDirectory = DiskInfo.RootClus;
....................  	}else{
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);	//DiskInfo.FilSysType[8] 	// bytes 54..61: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT16   "
.................... 						FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'1''6'
.................... 	}
.................... 
.................... 	if(FATType == 16){
.................... 						DiskInfo.VolId = make32(dt[42],dt[41],dt[40],dt[39]);
.................... 						memcpy((*ptrDiskInfo).VolLab, (ptrSct +  43), 11);
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);
.................... 
.................... 						sect_x_fat  = DiskInfo.FATsz16;		// Sectores reservados para la FAT
.................... 						startClusterOfRootDirectory = DiskInfo.RootEntCnt;
....................  					}
.................... 
....................   	sect_x_cluster = DiskInfo.SectPerClus;					// Cada cluster tiene este numero de sectores
.................... 
....................     			      sctrs  = LBA0;
.................... 				  	  sctrs += DiskInfo.RsrvdCnt;
.................... 	sect_reserv 	= sctrs;								// sectores reservados por el sistema
.................... 
....................     sect_fat_1  	= sctrs;               					// A partir de ahï¿½: FAT 1
.................... 				  	  sctrs += sect_x_fat;
.................... 	sect_fat_2  	= sctrs;;								// A partir de ahï¿½: FAT 2 (copia de seguridad)
.................... 				  	  sctrs += sect_x_fat;
.................... 	sect_entry  	= sctrs ;      							// A partir de ahï¿½ empieza el raï¿½z (la lista de ficheros)
.................... 					  sctrs += sect_x_cluster;
.................... 	sect_ini_datos 	= sctrs ;								// A partir de ahi los datos del fichero
.................... 
....................     if(FATType == 16)										// RootEntCnt: Numero de entradas de 32 bytes al
....................     sect_ini_datos = sect_entry+(DiskInfo.RootEntCnt>>4);	// directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
.................... 
.................... }//fin initFAT()
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void cargaConfig(unsigned int32 j);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... // unsigned int8 encontrar_fichero(){
.................... //    unsigned int8 FicheroEncontrado = 0;
.................... //    unsigned int32 i;
.................... //    unsigned int16 j;
.................... //    unsigned int32 SctStart = sect_entry;			//inicio Root
.................... //    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root
.................... //    unsigned int32 ClstIni  = ((FATType==16)?1:2);
.................... //
.................... //    unsigned int32 ClstNxt;
.................... //    unsigned int32 sctrClstr;
.................... //    unsigned int32 posSctr;
.................... //    unsigned int32 clstrSig;
.................... //
.................... //    for(i = SctStart; i < SctEnd; i++){
.................... // 	      sd_read_block(i, dt);
.................... // 		 for(j = 0; j < 512; j += 32){
.................... // 										if(	(dt[j + 0] == 'C')&&
.................... // 											(dt[j + 1] == 'O')&&
.................... // 											(dt[j + 2] == 'N')&&
.................... // 											(dt[j + 3] == 'F')&&
.................... // 											(dt[j + 4] == 'I')&&
.................... // 											(dt[j + 5] == 'G')&&
.................... // 											(dt[j + 6] == ' ')&&
.................... // 											(dt[j + 7] == ' ')&&
.................... // 											(dt[j + 8] == 'T')&&
.................... // 											(dt[j + 9] == 'X')&&
.................... // 											(dt[j + 10]== 'T')){
.................... // 																 cargaConfig(j);
.................... // 																 FicheroEncontrado = 1;
.................... // 																 return FicheroEncontrado;
.................... // 																}//fin if(CNF)
.................... //
.................... // 		}//j
.................... //    }//i
.................... //    return FicheroEncontrado;
.................... // } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void cargaConfig(unsigned int32 j){
....................    unsigned int32 direccion;
....................    unsigned int32 _sector;
.................... 
.................... 	if(FATType==16){
.................... 	   	direccion = make32(0,0,dt[j+27],dt[j+26]);
.................... 		_sector = ((unsigned int32)direccion - 2) * sect_x_cluster + sect_ini_datos;
.................... 	}
.................... 	if(FATType==32){
.................... 	   direccion = make32(dt[j+21],dt[j+20],dt[j+27],dt[j+26]); //en FAT32 se usa EAIndex + first cluster
.................... 	   _sector = ((unsigned int32)direccion - 3) * sect_x_cluster + sect_ini_datos;
....................    }
....................    sd_read_block(_sector, dt); //leer el primer sector de los datos del fichero
.................... 
....................    // Ahora en el vector dt tengo los datos del fichero y puedo emplearlo
....................    // Por ejemplo: el texto que indica la hora y minutos del ensayo lo obtendria como:
....................    // hora   = (dt[140]-'0')*10 + dt[141]-'0' ;
....................    // minutos= (dt[143]-'0')*10 + dt[144]-'0' ;
....................    // ... Y con esos datos haria algo util
.................... 
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 inicializa_fichero(){
....................    unsigned int8 FicheroIncializado = 0;
....................    unsigned int32 i;
....................    unsigned int16 j;
....................    unsigned int32 SctStart = sect_entry;			//inicio Root
....................    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root
....................    unsigned int32 ClstIni  = ((FATType==16)?0:1);
.................... 
....................    unsigned int32 ClstNxt;
....................    unsigned int32 sctrClstr;
....................    unsigned int32 posSctr;
....................    unsigned int32 clstrSig;
.................... 
....................    unsigned int32 startCluster;      //cluster donde empezarï¿½an los datos del fichero
....................    fileEntry newFile;
.................... 
....................    for(i = SctStart; i < SctEnd; i++){
.................... 	      sd_read_block(i, dt);
.................... 		  for(j = 0; j < 512; j += 32){
.................... 			if((dt[j] == 0x00) || dt[j] == 0xFF){
.................... 					   newFile.fields.name[0] = 		'L';
.................... 					   newFile.fields.name[1] = 		'A';
.................... 					   newFile.fields.name[2] = 		'T';
.................... 					   newFile.fields.name[3] = 		'I';
.................... 					   newFile.fields.name[4] = 		'D';
.................... 					   newFile.fields.name[5] = 		'O';
.................... 					   newFile.fields.name[6] = 		'S';
.................... 					   newFile.fields.name[7] = 		'_';
.................... 					   newFile.fields.extension[0] = 	'T';
.................... 					   newFile.fields.extension[1] = 	'X';
.................... 					   newFile.fields.extension[2] = 	'T';
.................... 					   newFile.fields.reserved = 0;
.................... 					   newFile.fields.createTimeMs = 0;
.................... 					   newFile.fields.create_hour = getHour();
.................... 					   newFile.fields.create_date = getDate();
.................... 					   newFile.fields.last_access = newFile.fields.create_date;
.................... 					   newFile.fields.eaIndex = 0;
.................... 					   newFile.fields.attrib = __FILE | READONLY;   //archivo normal + sï¿½lo lectura
.................... 					   newFile.fields.modif_hour = newFile.fields.create_hour;
.................... 					   newFile.fields.modif_date = newFile.fields.create_date;
.................... 					   newFile.fields.first_cluster = 0;
.................... 					   newFile.fields.size = 0;
.................... 
.................... 					   file.offsetEntry = j;
.................... 					   file.sectorEntryFile = i;
.................... 					   sd_read_block(file.sectorEntryFile, file.EntryFile);
.................... 
.................... 					   for(i = 0; i < 32; j++, i++)  dt[j] = newFile.raw[i];
.................... 					   for(i = 0; i < 512; i++)      file.EntryFile[i] = dt[i];
.................... 					   file.posInSector    = 0;   															//empezamos en un sector y cluster nuevos
.................... 					   if(FATType==16){
.................... 					   startCluster = encontrarCluster(2);         											//busco cluster donde empezarï¿½a a almacenarse los datos
.................... 					   file.currentCluster = startCluster;   												//que serï¿½ el cluster en el que escribiremos
.................... 					   file.currentSector  = (file.currentCluster -  2) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster)
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 8) + sect_reserv;						//sector en la FAT donde marcar el cluster usado
.................... 					   }
.................... 					   if(FATType==32){
.................... 					   startCluster = encontrarCluster(3);         											//busco cluster donde empezarï¿½a a almacenarse los datos
.................... 					   file.currentCluster = startCluster;   												//que serï¿½ el cluster en el que escribiremos
.................... 					   file.currentSector  = (file.currentCluster -  3) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster)
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 7) + sect_reserv;						//sector en la FAT donde marcar el cluster usado
.................... 					   }
.................... 					   file.EntryFile[file.offsetEntry + 27] = make8(file.currentCluster, 1); 					//1er cluster del archivo
.................... 					   file.EntryFile[file.offsetEntry + 26] = make8(file.currentCluster, 0);
.................... 					   file.EntryFile[file.offsetEntry + 21] = make8(file.currentCluster, 3);
.................... 					   file.EntryFile[file.offsetEntry + 20] = make8(file.currentCluster, 2);
.................... 					   file.size = 0;																			//Inicialmente el tamaï¿½o es cero
.................... 
.................... 					   if(FATType==16){
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile);
.................... 						sd_read_block (file.sectorAtFAT, sector_fat16);
.................... 						sector_fat16[file.currentCluster % MAX_ENTRIES_SECTOR_FAT16] = ENDFILE16;				//marco el cluster como usado
.................... 						sd_write_block( file.sectorAtFAT, sector_fat16);
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat16);   //FAT2					//ï¿½Ojo! la cosa puede ser mas complicada...
.................... 						}
.................... 					   if(FATType==32){
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile);
.................... 						sd_read_block (file.sectorAtFAT,sector_fat32);
.................... 						sector_fat32[file.currentCluster % MAX_ENTRIES_SECTOR_FAT32] = ENDFILE32;				//marco el cluster como usado
.................... 						sd_write_block( file.sectorAtFAT, sector_fat32);
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat32);   //FAT2					//ï¿½Ojo! la cosa puede ser mas complicada...
.................... 						}
.................... 					   FicheroIncializado = 1;
.................... 					   return FicheroIncializado;
.................... 					   }
.................... 
.................... 		}//j
....................    }//i
....................    return FicheroIncializado;
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart){
....................    unsigned int32 cluster;
....................    unsigned int32 _sector;   //recorrer sectores
....................    unsigned int32 bytes;     //recorrer bytes en cada sector
.................... 
....................    cluster =  clusterStart;
....................    if(FATType==16)
....................    _sector = (clusterStart >> 2) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante
....................    if(FATType==32)
....................    _sector = (clusterStart >> 3) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante
....................    bytes = (clusterStart % ((FATType==16) ? MAX_ENTRIES_SECTOR_FAT16 : MAX_ENTRIES_SECTOR_FAT32));
.................... 
....................    if(FATType==32){
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT
.................... 		  sd_read_block(_sector,sector_fat32); 							//leemos el sector
....................     					      for(; bytes < MAX_ENTRIES_SECTOR_FAT32; bytes++){ //recorremos el sector para buscar un puntero a cluster libre
.................... 					         if(sector_fat32[bytes]== 0){
.................... 					            if(cluster < 3)               continue;  	//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando
.................... 					            return cluster;
.................... 					         }//fin if
.................... 					         cluster++;
.................... 					      }//fin for de recorrer bytes dentro de un sector
.................... 	      bytes = 0;
.................... 	   }//fin for de recorrer sectores
....................    }else
....................     if(FATType==16){
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT
.................... 		  sd_read_block(_sector,sector_fat16); 							//leemos el sector
.................... 
.................... 					      for(; bytes < MAX_ENTRIES_SECTOR_FAT16; bytes++){ 	//recorremos el sector para buscar un puntero a cluster libre
.................... 					         if(sector_fat16[bytes]== 0){
.................... 					            if(cluster < 2)               continue;		//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando
.................... 					            return cluster;
.................... 					         }//fin if
.................... 					         cluster++;
.................... 					      }//fin for de recorrer bytes dentro de un sector
.................... 	      bytes = 0;
.................... 	   }//fin for de recorrer sectores
.................... 	}
....................    return ((FATType==16)?ENDFILE16:ENDFILE32);
.................... }//fin encontrarCluster
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... void escribe_datos_en_fichero(){
....................    unsigned int32 relSector;
....................    unsigned int32 nextCluster;
....................    unsigned int32  oldCluster;
....................    unsigned int16 _hour, date;
.................... 
.................... 	sd_write_block(file.currentSector, dt);
.................... 
.................... 
.................... 
.................... 
.................... 		file.currentSector++;																					//actualizar las FATs
.................... 		if(FATType==16)
.................... 	    relSector= file.currentSector - ((file.currentCluster -  2) * sect_x_cluster + sect_ini_datos);
.................... 		if(FATType==32)
.................... 	    relSector= file.currentSector - ((file.currentCluster -  3) * sect_x_cluster + sect_ini_datos);
.................... 
.................... 	    if((relSector % sect_x_cluster) == 0){   											//ï¿½el siguiente sector estï¿½ en cluster nuevo?
.................... 	      oldCluster = 	file.currentCluster;
.................... 	      nextCluster = encontrarCluster(oldCluster);   									//siguiente cluster
.................... 	      //escribirCluster(oldCluster, nextCluster);  										//marcar actual cluster para que apunte al siguiente
.................... 	      file.currentCluster = nextCluster;
.................... 		  if(FATType==16)
.................... 	      file.currentSector = (nextCluster - 2) * sect_x_cluster + sect_ini_datos;
.................... 		  if(FATType==32)
.................... 	      file.currentSector = (nextCluster - 3) * sect_x_cluster + sect_ini_datos;
.................... 	   }
.................... 
.................... 	   //actualizar el tamaï¿½o del fichero y fechas
.................... 	   file.size += 512;
.................... 	   file.EntryFile[file.offsetEntry + 28] = make8(file.size, 0);   //tamaï¿½o
.................... 	   file.EntryFile[file.offsetEntry + 29] = make8(file.size, 1);
.................... 	   file.EntryFile[file.offsetEntry + 30] = make8(file.size, 2);
.................... 	   file.EntryFile[file.offsetEntry + 31] = make8(file.size, 3);
.................... 	   //ActualizaReloj();
.................... 	   _hour = getHour();
.................... 	   date = getDate();
.................... 	   file.EntryFile[file.offsetEntry + 24] = make8(date, 0);       //fecha modif
.................... 	   file.EntryFile[file.offsetEntry + 25] = make8(date, 1);
.................... 	   file.EntryFile[file.offsetEntry + 22] = make8(_hour, 0);      //hora modif
.................... 	   file.EntryFile[file.offsetEntry + 23] = make8(_hour, 1);
.................... 	   file.EntryFile[file.offsetEntry + 18] = file.EntryFile[file.offsetEntry + 24];   //fecha ï¿½ltimo acceso
.................... 	   file.EntryFile[file.offsetEntry + 19] = file.EntryFile[file.offsetEntry + 25];
.................... 
.................... 	   sd_write_block(file.sectorEntryFile, file.EntryFile);  	// Actualiza root
.................... 
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __MIFAT_H
.................... 
.................... #include "sdcard.h"
.................... 
.................... #ifndef __SDCARD_H
.................... #define __SDCARD_H
.................... 
.................... #bit  SPIRBF    = getenv("SFR:SPI1STAT").0
.................... #bit  SPITBF    = getenv("SFR:SPI1STAT").1
.................... #bit  SPIROV    = getenv("SFR:SPI1STAT").6
.................... #byte SPI1BUF   = getenv("SFR:SPI1BUF")
.................... #byte SPI1STAT  = getenv("SFR:SPI1STAT")
.................... #byte SPI1CON1  = getenv("SFR:SPI1CON1")
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define   CMD0              		0x40      //go to idle				//Commands
.................... #define   CMD1               		0x41      //initialization process
.................... #define   CMD8               		0x48      //verify interface
.................... #define   CMD17              		0x51      //read single block
.................... #define   CMD24              		0x58      //write single block
.................... #define   CMD55              		0x77      //escape for app specific command
.................... #define   CMD58              		0x7a      //read OCR
.................... #define   ACMD41             		0x69      //poll operation range
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define   R1_READY_STATE          	0x00      //sd ready				//Responses
.................... #define   R1_IDLE_STATE           	0x01      //card in idle state
.................... #define   R1_ILLEGAL_COMMAND      	0x04      //illegal command
.................... #define   DATA_START_BLOCK       	0xFE      //start token for read or write
.................... #define   DATA_RES_MASK          	0x1F      //mask for data response
.................... #define   DATA_RES_ACCEPTED      	0x05      //write accepted
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sdhc;
.................... unsigned int8 dt[512];            /// Buffer de escritura  en uSD
.................... unsigned int32 LBA0 = 0;
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... inline unsigned int8 xfer_spi(char envio){
....................    SPIROV = 0;
....................    SPI1BUF= envio;
....................    while( SPITBF);
....................    while(!SPIRBF);
....................    return SPI1BUF;
.................... }//fin xfer_spi
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 Commnd(char befF, int32 SD_Adress, char befH){
....................    unsigned int8 iC1;
....................    xfer_spi(0xFF);
....................    xfer_spi(befF);
....................    xfer_spi(make8(SD_Adress, 3));
....................    xfer_spi(make8(SD_Adress, 2));
....................    xfer_spi(make8(SD_Adress, 1));
....................    xfer_spi(make8(SD_Adress, 0));
....................    xfer_spi(befH);
....................     do{iC1 = xfer_spi(0xFF);
....................    }while(iC1 == 0xFF);
....................    return iC1;
.................... }//fin Commnd
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_init(){
....................  unsigned  int8 R[17]={0}, versionSD= 1, crc;
....................  unsigned int16 iI;
....................  unsigned int32 arg=0;
.................... 
....................  setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_16);
.................... 
....................  memset(dt,0,512);
....................  // CMD0 - GO_IDLE_STATE  (R1)ï¿½ ï¿½ Card Reset  ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 	do{	output_high(CS);   	// tarjeta deshabilitada
.................... 		for (iI = 0; iI < 10; iI++)  	xfer_spi(0xFF);
.................... 		output_low(CS); 	// tarjeta habilitada
.................... 		R[0] = Commnd( CMD0 , 0x00000000 , 0x95); //go to idle
.................... 	}while( R[0] != R1_IDLE_STATE);
....................   // CMD8 - SEND_IF_COND (R7)  ï¿½ Send Interface Condition Commandï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // Argument 00 - 00 - 01 (Voltage supplied = 2.7-3.6V) - AA (Check pattern)
....................   // Response: illegal command -> Version 1
....................   // Response: echo-back 	   -> Version 2
.................... 	R[0] = Commnd(CMD8, 0x000001AA, 0x87);
....................     if(R[0]& R1_ILLEGAL_COMMAND){	  			versionSD = 1;
....................    			}else{	R[1] = xfer_spi(0xFF);
.................... 					R[2] = xfer_spi(0xFF);
.................... 					R[3] = xfer_spi(0xFF);
.................... 					R[4] = xfer_spi(0xFF);
.................... 				    if(R[4]!=0xAA){	output_high(CS); return 1; }		//error
....................       											versionSD = 2;
....................    			}
.................... 
....................   // ACMD41 - SD_SEND_OP_ COND (R1) ï¿½ ï¿½ Initialization Command   ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // If host supports SDHC or SDXC: HCS (Host Capacity Support) is set to 1 (arg= 0x40000000)
....................   // If host only support SDSC:     HCS (Host Capacity Support) is set to 0 (arg= 0)
....................    arg = (versionSD == 2) ? 0x40000000 : 0;
....................    crc = (versionSD == 2) ? 0x77 : 0xFF;
.................... 
.................... 
....................    do{            Commnd(CMD55,    0, 0x65);	// El proceso puede llegar a durar hasta 1 segundo
....................            R[0] = Commnd(ACMD41, arg, crc);		// Application-Specific Command ï¿½ APP_CMD (CMD55)
.................... 		   delay_ms(4);
....................    }while(R[0] != R1_READY_STATE);
.................... 
....................   if(versionSD == 2){
.................... 
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // CMD58 - READ_OCR (R3) ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // Bit 30 - Card Capacity Status bit: 	0 indicates that the card is SDSC.
....................   //										1 indicates that the card is SDHC or SDXC
.................... 	R[0] = Commnd(CMD58, 0x00000000, 0xFF);
....................     if(R[0] == R1_READY_STATE){	R[1] = xfer_spi(0xFF);
.................... 								R[2] = xfer_spi(0xFF);
.................... 								R[3] = xfer_spi(0xFF);
.................... 								R[4] = xfer_spi(0xFF);
.................... 								sdhc = ((R[1]& 0xC0) == 0xC0) ? 1 : 0;
....................    			}else{				output_high(CS); return 1; }		//error
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 
....................   }// versionSD == 2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
....................   setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_1);
.................... 
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 	sd_read_block(0, dt);	//Lee el sector fisico 0 para obtener el LBA0
.................... 	if(dt[510]==0x55)
.................... 	if(dt[511]==0xAA){ 		// Efectivamente parece que estoy en sct 0
.................... 							// Tabla de particiones
.................... 								LBA0 = make32(dt[457],dt[456],dt[455],dt[454]);
.................... 								if(dt[0]==0xEB) // MBR
....................  								LBA0 = 0;
.................... 						  }//55AA
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 
....................   output_high(CS);   									// tarjeta deshabilitada
....................   return 0;
.................... }//char sd_init()- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr){
....................    unsigned int16 iW;
.................... 
....................    if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores
....................    output_low(CS);
.................... 
.................... 		iW = Commnd(CMD24, address, 0xFF);
....................     if( iW == R1_READY_STATE){
....................              								              		xfer_spi(0xFF);
....................                               									xfer_spi(DATA_START_BLOCK);   // Data start token
....................                            			for(iW = 0; iW < 512; iW++)  xfer_spi(ptr[iW]);
....................                            							xfer_spi(0xFF);   // Dummy bytes
....................                           							xfer_spi(0xFF);   // en lugar del CRC16
.................... 
....................                         do{       iW = xfer_spi(0xFF);
....................                         }while( (iW & DATA_RES_MASK) != DATA_RES_ACCEPTED);
.................... 
....................                         do{       iW = xfer_spi(0xFF); delay_us(100);
....................                         }while(   iW == 0 );
.................... 
.................... 						xfer_spi(0xFF);
.................... 						xfer_spi(0xFF);
.................... 
....................    						output_high(CS);   return 0; //correcto
.................... 						}
....................    						output_high(CS);   return 1; //error
.................... }//fin sd_write_block
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr){
....................    unsigned int16 jR;
....................    unsigned int8  iR;
.................... 
....................     if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores
....................     output_low(CS);
.................... 
....................        iR  = Commnd(CMD17, address, 0xFF);
....................     if(iR == R1_READY_STATE){
.................... 								do{     iR  = xfer_spi(0xFF);
.................... 								}while( iR != DATA_START_BLOCK);
.................... 
.................... 								if(iR == DATA_START_BLOCK){
.................... 								for(jR = 0; jR < 512; jR++)
.................... 								         ptr[jR] = xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
....................   								}
.................... 
....................    							output_high(CS);      return 0;
.................... 							}
.................... 							output_high(CS);      return 1;
.................... }//fin sd_read_block
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __SDCARD_H
.................... 
.................... 
.................... void sd_init_global();
.................... void escritura_sd();
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __SD_CARD_H
.................... 
.................... #include "BLUETOOTH.h"
.................... #ifndef Bluetooth_h
.................... #define Bluetooth_h
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use rs232(UART1,baud=115200,STREAM=BT)
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void init_BT(void); //inits and enables uart isr
.................... void enviar_datos(unsigned int16 ppm);
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... /* SECTION 1: Included header files to compile this file           */
.................... 
.................... /* SECTION 2: Public macros                                        */
.................... 
.................... #define _CLEAR_DISPLAY 				0x01
.................... #define _8BIT_4LINES_NORMAL_RE1_IS0		0x3A
.................... #define _8BIT_4LINES_REVERSE_RE1_IS0		0x3B
.................... #define _8BIT_4LINES_RE0_IS1			0x39
.................... #define _8BIT_4LINES_RE0_IS0			0x38
.................... 
.................... #define _BS1_1					0x1E
.................... #define _POWER_DOWN_DISABLE			0x02
.................... #define _SEGMENT_NORMAL_WAY			0x05
.................... #define _NW					0x09
.................... 
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_ON		0x0F
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_OFF		0x0E
.................... #define _DISPLAY_ON_CURSOR_OFF_BLINK_OFF	0x0C
.................... #define _BS0_1					0x1C
.................... #define _INTERNAL_DIVIDER			0x13
.................... #define _CONTRAST				0x77
.................... #define _POWER_ICON_CONTRAST			0x5C
.................... #define _FOLLOWER_CONTROL			0x6E
.................... 
.................... #define ADDRESS_DDRAM				0x80
.................... 
.................... 
.................... /* SECTION 3: Public types                                         */
.................... 
.................... 
.................... /* SECTION 4: Public variables :: declarations, extern mandatory   */
.................... 
.................... 
.................... /* SECTION 5: Public functions :: declarations, extern optional
....................    Rule exception (callbacks)  :: declarations, extern recommended */
.................... void display_valueADC_title(void);
.................... void LCD_command(unsigned int8);
.................... void lcdi2cinit(void);
.................... void LCD_write(char*);
.................... void initmenu(void);                                      //Inicializa el menu principal
.................... void display_frecuencia(void);       // Muestra frecuencia
.................... void LCD_cursor_at(unsigned int8 line, unsigned int8 column);
.................... void display_alarma_alto(void); // Limpia pantalla y escribe mensaje de alarma
.................... void display_alarma_bajo(void);
.................... void display_final(void);
.................... 
.................... 
.................... #endif // __LCD_H
.................... // Do not write below this line!
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... void LCD_command(unsigned int8);
.................... void LCD_write(char*);
.................... void LCD_cursor_at(unsigned int8, unsigned int8);
.................... 
.................... void lcdi2cinit(void)
.................... {
.................... 
....................   OFF(SD);
*
0078C:  BCLR.B  2D0.1
0078E:  BCLR.B  2D4.1
....................   delay_ms(200);
00790:  MOV     #C8,W0
00792:  CALL    732
....................   ON(PIN_C1);
*
00796:  BCLR.B  2D0.1
00798:  BSET.B  2D4.1
.................... 
....................   //leds output en open drain
....................   output_float(PIN_B8);
0079A:  BSET.B  2C9.0
....................   output_float(PIN_B9);
0079C:  BSET.B  2C9.1
.................... 
....................   //pullups
....................   set_pullup(TRUE, PIN_B8);
0079E:  BSET.B  6A.6
....................   set_pullup(TRUE, PIN_B9);
007A0:  BSET.B  6A.5
.................... 
.................... 
....................   //dspic as master, velocidad, nombre de la conexion
....................   #use i2c(Master, Fast=1000000, i2c1)
*
00742:  MOV     #FFFF,W0
00744:  BTSS.B  208.3
00746:  BRA     752
00748:  BTSC.B  209.6
0074A:  BRA     748
0074C:  MOV     W1,202
0074E:  BTSC.B  209.6
00750:  BRA     74E
00752:  MOV     #0,W0
00754:  BTSC.B  209.7
00756:  INC     W0,W0
00758:  RETURN  
.................... 
....................   LCD_command(_CLEAR_DISPLAY);
*
007A2:  MOV     3C2E,W0
007A4:  MOV.B   #1,W0L
007A6:  MOV     W0,3C2E
007A8:  CALL    75A
....................   LCD_command(_8BIT_4LINES_NORMAL_RE1_IS0);
*
007AC:  MOV     3C2E,W0
007AE:  MOV.B   #3A,W0L
007B0:  MOV     W0,3C2E
007B2:  CALL    75A
....................   LCD_command(_BS1_1);
*
007B6:  MOV     3C2E,W0
007B8:  MOV.B   #1E,W0L
007BA:  MOV     W0,3C2E
007BC:  CALL    75A
....................   LCD_command(_POWER_DOWN_DISABLE);
*
007C0:  MOV     3C2E,W0
007C2:  MOV.B   #2,W0L
007C4:  MOV     W0,3C2E
007C6:  CALL    75A
....................   LCD_command(_SEGMENT_NORMAL_WAY);
*
007CA:  MOV     3C2E,W0
007CC:  MOV.B   #5,W0L
007CE:  MOV     W0,3C2E
007D0:  CALL    75A
....................   LCD_command(_NW);
*
007D4:  MOV     3C2E,W0
007D6:  MOV.B   #9,W0L
007D8:  MOV     W0,3C2E
007DA:  CALL    75A
....................   LCD_command(_8BIT_4LINES_RE0_IS1);
*
007DE:  MOV     3C2E,W0
007E0:  MOV.B   #39,W0L
007E2:  MOV     W0,3C2E
007E4:  CALL    75A
....................   LCD_command(_DISPLAY_ON_CURSOR_ON_BLINK_OFF);
*
007E8:  MOV     3C2E,W0
007EA:  MOV.B   #E,W0L
007EC:  MOV     W0,3C2E
007EE:  CALL    75A
....................   LCD_command(_BS0_1);
*
007F2:  MOV     3C2E,W0
007F4:  MOV.B   #1C,W0L
007F6:  MOV     W0,3C2E
007F8:  CALL    75A
....................   LCD_command(_INTERNAL_DIVIDER);
*
007FC:  MOV     3C2E,W0
007FE:  MOV.B   #13,W0L
00800:  MOV     W0,3C2E
00802:  CALL    75A
....................   LCD_command(_CONTRAST);
*
00806:  MOV     3C2E,W0
00808:  MOV.B   #77,W0L
0080A:  MOV     W0,3C2E
0080C:  CALL    75A
....................   LCD_command(_POWER_ICON_CONTRAST);
*
00810:  MOV     3C2E,W0
00812:  MOV.B   #5C,W0L
00814:  MOV     W0,3C2E
00816:  CALL    75A
....................   LCD_command(_FOLLOWER_CONTROL);
*
0081A:  MOV     3C2E,W0
0081C:  MOV.B   #6E,W0L
0081E:  MOV     W0,3C2E
00820:  CALL    75A
....................   LCD_command(_8BIT_4LINES_RE0_IS0);
*
00824:  MOV     3C2E,W0
00826:  MOV.B   #38,W0L
00828:  MOV     W0,3C2E
0082A:  CALL    75A
*
0082E:  RETURN  
.................... 
.................... }
.................... 
.................... void LCD_command(unsigned int8 cmd)
.................... {
....................   i2c_start();
*
0075A:  BTSS.B  208.3
0075C:  BRA     766
0075E:  BSET.B  206.1
00760:  BTSC.B  206.1
00762:  BRA     760
00764:  BRA     76C
00766:  BSET.B  206.0
00768:  BTSC.B  206.0
0076A:  BRA     768
....................   i2c_write(0x78);
0076C:  MOV.B   #78,W1L
0076E:  CALL    742
....................   i2c_write(0x00);
*
00772:  CLR.B   W1
00774:  CALL    742
....................   i2c_write(cmd);
*
00778:  MOV     3C2E,W1
0077A:  CALL    742
....................   i2c_stop();
*
0077E:  MOV     #1F,W0
00780:  AND     206,W0
00782:  BRA     NZ,77E
00784:  BSET.B  206.2
00786:  BTSC.B  206.2
00788:  BRA     786
0078A:  RETURN  
.................... }
.................... 
.................... void LCD_write(char* cd)
*
0086A:  MOV     W5,[W15++]
0086C:  MOV     W6,[W15++]
0086E:  MOV     3C2A,W0
00870:  MOV.B   #0,W0L
00872:  MOV     W0,3C2A
.................... {
....................   unsigned int8 c=0;
....................   i2c_start();
00874:  BTSS.B  208.3
00876:  BRA     880
00878:  BSET.B  206.1
0087A:  BTSC.B  206.1
0087C:  BRA     87A
0087E:  BRA     886
00880:  BSET.B  206.0
00882:  BTSC.B  206.0
00884:  BRA     882
....................   i2c_write(0x78);
00886:  MOV.B   #78,W1L
00888:  CALL    742
....................   i2c_write(0x40);
*
0088C:  MOV.B   #40,W1L
0088E:  CALL    742
....................   while(cd[c]!=0)
*
00892:  MOV     3C2A,W4
00894:  CLR.B   9
00896:  MOV     3C28,W0
00898:  ADD     W4,W0,W0
0089A:  MOV.B   [W0],W5L
0089C:  SE      W5,W5
0089E:  CP0     W5
008A0:  BRA     Z,8C0
....................   {
....................     i2c_write(cd[c]);
008A2:  MOV     3C2A,W4
008A4:  CLR.B   9
008A6:  MOV     3C28,W0
008A8:  ADD     W4,W0,W0
008AA:  MOV.B   [W0],W5L
008AC:  MOV.B   W5L,W1L
008AE:  CALL    742
....................     c++;
*
008B2:  MOV     3C2A,W0
008B4:  INC.B   W0L,W0L
008B6:  PUSH    3C2A
008B8:  MOV.B   W0L,[W15-#2]
008BA:  POP     3C2A
008BC:  GOTO    892
....................   }
....................   i2c_stop();
*
008C0:  MOV     #1F,W0
008C2:  AND     206,W0
008C4:  BRA     NZ,8C0
008C6:  BSET.B  206.2
008C8:  BTSC.B  206.2
008CA:  BRA     8C8
008CC:  MOV     [--W15],W6
008CE:  MOV     [--W15],W5
008D0:  RETURN  
.................... }
.................... 
.................... void LCD_cursor_at(unsigned int8 line, unsigned int8 column)
*
0084A:  MOV     W5,[W15++]
.................... {
....................   LCD_command(0x80 | (line*0x20+column));
0084C:  MOV     3C28,W0
0084E:  CLR.B   1
00850:  SL      W0,#5,W5
00852:  MOV     3C28,W4
00854:  LSR     W4,#8,W4
00856:  ADD     W5,W4,W0
00858:  MOV     W0,W5
0085A:  IOR     #80,W5
0085C:  PUSH    3C2E
0085E:  MOV.B   W5L,[W15-#2]
00860:  POP     3C2E
00862:  CALL    75A
*
00866:  MOV     [--W15],W5
00868:  RETURN  
.................... }
.................... 
.................... void initmenu(void)
.................... {
.................... 	char cabecera[]="----WELCOME-----";
*
008D2:  MOV     #2D2D,W4
008D4:  MOV     W4,3BEE
008D6:  MOV     #2D2D,W4
008D8:  MOV     W4,3BF0
008DA:  MOV     #4557,W4
008DC:  MOV     W4,3BF2
008DE:  MOV     #434C,W4
008E0:  MOV     W4,3BF4
008E2:  MOV     #4D4F,W4
008E4:  MOV     W4,3BF6
008E6:  MOV     #2D45,W4
008E8:  MOV     W4,3BF8
008EA:  MOV     #2D2D,W4
008EC:  MOV     W4,3BFA
008EE:  MOV     #2D2D,W4
008F0:  MOV     W4,3BFC
008F2:  MOV     3BFE,W0
008F4:  MOV.B   #0,W0L
008F6:  MOV     W0,3BFE
.................... 	char boton[]="-------------";
008F8:  MOV     #2D2D,W4
008FA:  MOV     W4,3C00
008FC:  MOV     #2D2D,W4
008FE:  MOV     W4,3C02
00900:  MOV     #2D2D,W4
00902:  MOV     W4,3C04
00904:  MOV     #2D2D,W4
00906:  MOV     W4,3C06
00908:  MOV     #2D2D,W4
0090A:  MOV     W4,3C08
0090C:  MOV     #2D2D,W4
0090E:  MOV     W4,3C0A
00910:  MOV     #2D,W4
00912:  MOV     W4,3C0C
.................... 	char palabra1[]="PRESS OK";
00914:  MOV     #5250,W4
00916:  MOV     W4,3C0E
00918:  MOV     #5345,W4
0091A:  MOV     W4,3C10
0091C:  MOV     #2053,W4
0091E:  MOV     W4,3C12
00920:  MOV     #4B4F,W4
00922:  MOV     W4,3C14
00924:  MOV     3C16,W0
00926:  MOV.B   #0,W0L
00928:  MOV     W0,3C16
.................... 	//char palabra2[]="OPCION 2";
.................... 	//char palabra3[]="OPCION 3";
.................... 	//char palabra4[]="OPCION 4";
.................... 
.................... 	LCD_cursor_at(0,0);
0092A:  MOV     3C28,W0
0092C:  MOV.B   #0,W0L
0092E:  MOV     W0,3C28
00930:  MOV     3C28,W0
00932:  CLR.B   1
00934:  MOV     W0,3C28
00936:  CALL    84A
.................... 	LCD_write(cabecera);
*
0093A:  MOV     #3BEE,W4
0093C:  MOV     W4,3C28
0093E:  CALL    86A
.................... 	LCD_cursor_at(1,0);
*
00942:  MOV     3C28,W0
00944:  MOV.B   #1,W0L
00946:  MOV     W0,3C28
00948:  MOV     3C28,W0
0094A:  CLR.B   1
0094C:  MOV     W0,3C28
0094E:  CALL    84A
.................... 	LCD_write(boton);
*
00952:  MOV     #3C00,W4
00954:  MOV     W4,3C28
00956:  CALL    86A
.................... 	LCD_cursor_at(2,1);
*
0095A:  MOV     3C28,W0
0095C:  MOV.B   #2,W0L
0095E:  MOV     W0,3C28
00960:  MOV     3C28,W0
00962:  SWAP    W0
00964:  MOV.B   #1,W0L
00966:  SWAP    W0
00968:  MOV     W0,3C28
0096A:  CALL    84A
.................... 	LCD_write(palabra1);
*
0096E:  MOV     #3C0E,W4
00970:  MOV     W4,3C28
00972:  CALL    86A
*
00976:  RETURN  
.................... }
.................... 
.................... void errorfichero(void)
.................... {
.................... 	char cabecera[]="------ERROR------";
.................... 	char boton[]="NO CONFIG.TXT DETE";
.................... 	char palabra1[]="PRESS RESET";
.................... 	//char palabra2[]="OPCION 2";
.................... 	//char palabra3[]="OPCION 3";
.................... 	//char palabra4[]="OPCION 4";
.................... 
.................... 	LCD_cursor_at(0,0);
.................... 	LCD_write(cabecera);
.................... 	LCD_cursor_at(1,0);
.................... 	LCD_write(boton);
.................... 	LCD_cursor_at(2,1);
.................... 	LCD_write(palabra1);
.................... }
.................... 
.................... void display_frecuencia(void)
.................... {
....................   LCD_command(_DISPLAY_ON_CURSOR_OFF_BLINK_OFF);
*
009D4:  MOV     3C2E,W0
009D6:  MOV.B   #C,W0L
009D8:  MOV     W0,3C2E
009DA:  CALL    75A
....................   LCD_command(_CLEAR_DISPLAY);
*
009DE:  MOV     3C2E,W0
009E0:  MOV.B   #1,W0L
009E2:  MOV     W0,3C2E
009E4:  CALL    75A
.................... 	char cabecera[]="FRECUENCIA PPM: ";
*
009E8:  MOV     #5246,W4
009EA:  MOV     W4,3BEE
009EC:  MOV     #4345,W4
009EE:  MOV     W4,3BF0
009F0:  MOV     #4555,W4
009F2:  MOV     W4,3BF2
009F4:  MOV     #434E,W4
009F6:  MOV     W4,3BF4
009F8:  MOV     #4149,W4
009FA:  MOV     W4,3BF6
009FC:  MOV     #5020,W4
009FE:  MOV     W4,3BF8
00A00:  MOV     #4D50,W4
00A02:  MOV     W4,3BFA
00A04:  MOV     #203A,W4
00A06:  MOV     W4,3BFC
00A08:  MOV     3BFE,W0
00A0A:  MOV.B   #0,W0L
00A0C:  MOV     W0,3BFE
....................   char palabra1[]="-------------------";
00A0E:  MOV     #2D2D,W4
00A10:  MOV     W4,3C00
00A12:  MOV     #2D2D,W4
00A14:  MOV     W4,3C02
00A16:  MOV     #2D2D,W4
00A18:  MOV     W4,3C04
00A1A:  MOV     #2D2D,W4
00A1C:  MOV     W4,3C06
00A1E:  MOV     #2D2D,W4
00A20:  MOV     W4,3C08
00A22:  MOV     #2D2D,W4
00A24:  MOV     W4,3C0A
00A26:  MOV     #2D2D,W4
00A28:  MOV     W4,3C0C
00A2A:  MOV     #2D2D,W4
00A2C:  MOV     W4,3C0E
00A2E:  MOV     #2D2D,W4
00A30:  MOV     W4,3C10
00A32:  MOV     #2D,W4
00A34:  MOV     W4,3C12
....................   char palabra2[]="BTOK PARA FINALIZAR";
00A36:  MOV     #5442,W4
00A38:  MOV     W4,3C14
00A3A:  MOV     #4B4F,W4
00A3C:  MOV     W4,3C16
00A3E:  MOV     #5020,W4
00A40:  MOV     W4,3C18
00A42:  MOV     #5241,W4
00A44:  MOV     W4,3C1A
00A46:  MOV     #2041,W4
00A48:  MOV     W4,3C1C
00A4A:  MOV     #4946,W4
00A4C:  MOV     W4,3C1E
00A4E:  MOV     #414E,W4
00A50:  MOV     W4,3C20
00A52:  MOV     #494C,W4
00A54:  MOV     W4,3C22
00A56:  MOV     #415A,W4
00A58:  MOV     W4,3C24
00A5A:  MOV     #52,W4
00A5C:  MOV     W4,3C26
.................... 	LCD_cursor_at(0,0);
00A5E:  MOV     3C28,W0
00A60:  MOV.B   #0,W0L
00A62:  MOV     W0,3C28
00A64:  MOV     3C28,W0
00A66:  CLR.B   1
00A68:  MOV     W0,3C28
00A6A:  CALL    84A
....................   LCD_write(cabecera);
*
00A6E:  MOV     #3BEE,W4
00A70:  MOV     W4,3C28
00A72:  CALL    86A
....................   LCD_cursor_at(1,0);
*
00A76:  MOV     3C28,W0
00A78:  MOV.B   #1,W0L
00A7A:  MOV     W0,3C28
00A7C:  MOV     3C28,W0
00A7E:  CLR.B   1
00A80:  MOV     W0,3C28
00A82:  CALL    84A
....................   LCD_write(palabra1);
*
00A86:  MOV     #3C00,W4
00A88:  MOV     W4,3C28
00A8A:  CALL    86A
....................   LCD_cursor_at(2,0);
*
00A8E:  MOV     3C28,W0
00A90:  MOV.B   #2,W0L
00A92:  MOV     W0,3C28
00A94:  MOV     3C28,W0
00A96:  CLR.B   1
00A98:  MOV     W0,3C28
00A9A:  CALL    84A
....................   LCD_write(palabra2);
*
00A9E:  MOV     #3C14,W4
00AA0:  MOV     W4,3C28
00AA2:  CALL    86A
*
00AA6:  RETURN  
.................... }
.................... 
.................... void display_valueADC_title(void)
.................... {
....................   char cabecera[]="VALOR ADC: ";
....................   //char palabra2[]="OPCION 2";
....................   //char palabra3[]="OPCION 3";
....................   //char palabra4[]="OPCION 4";
.................... 
....................   LCD_cursor_at(0,0);
....................   LCD_write(cabecera);
.................... }
.................... 
.................... void display_alarma_bajo(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
*
00AFA:  MOV     3C2E,W0
00AFC:  MOV.B   #1,W0L
00AFE:  MOV     W0,3C2E
00B00:  CALL    75A
....................   LCD_cursor_at(0,0);
*
00B04:  MOV     3C28,W0
00B06:  MOV.B   #0,W0L
00B08:  MOV     W0,3C28
00B0A:  MOV     3C28,W0
00B0C:  CLR.B   1
00B0E:  MOV     W0,3C28
00B10:  CALL    84A
....................   char peligro[]="PULSACIONES BAJAS";
*
00B14:  MOV     #5550,W4
00B16:  MOV     W4,3BEE
00B18:  MOV     #534C,W4
00B1A:  MOV     W4,3BF0
00B1C:  MOV     #4341,W4
00B1E:  MOV     W4,3BF2
00B20:  MOV     #4F49,W4
00B22:  MOV     W4,3BF4
00B24:  MOV     #454E,W4
00B26:  MOV     W4,3BF6
00B28:  MOV     #2053,W4
00B2A:  MOV     W4,3BF8
00B2C:  MOV     #4142,W4
00B2E:  MOV     W4,3BFA
00B30:  MOV     #414A,W4
00B32:  MOV     W4,3BFC
00B34:  MOV     #53,W4
00B36:  MOV     W4,3BFE
....................   LCD_write(peligro);
00B38:  MOV     #3BEE,W4
00B3A:  MOV     W4,3C28
00B3C:  CALL    86A
*
00B40:  RETURN  
.................... }
.................... 
.................... void display_alarma_alto(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
*
00AA8:  MOV     3C2E,W0
00AAA:  MOV.B   #1,W0L
00AAC:  MOV     W0,3C2E
00AAE:  CALL    75A
....................   LCD_cursor_at(0,0);
*
00AB2:  MOV     3C28,W0
00AB4:  MOV.B   #0,W0L
00AB6:  MOV     W0,3C28
00AB8:  MOV     3C28,W0
00ABA:  CLR.B   1
00ABC:  MOV     W0,3C28
00ABE:  CALL    84A
....................   char peligro[]="PULSACIONES ELEVADAS";
*
00AC2:  MOV     #5550,W4
00AC4:  MOV     W4,3BEE
00AC6:  MOV     #534C,W4
00AC8:  MOV     W4,3BF0
00ACA:  MOV     #4341,W4
00ACC:  MOV     W4,3BF2
00ACE:  MOV     #4F49,W4
00AD0:  MOV     W4,3BF4
00AD2:  MOV     #454E,W4
00AD4:  MOV     W4,3BF6
00AD6:  MOV     #2053,W4
00AD8:  MOV     W4,3BF8
00ADA:  MOV     #4C45,W4
00ADC:  MOV     W4,3BFA
00ADE:  MOV     #5645,W4
00AE0:  MOV     W4,3BFC
00AE2:  MOV     #4441,W4
00AE4:  MOV     W4,3BFE
00AE6:  MOV     #5341,W4
00AE8:  MOV     W4,3C00
00AEA:  MOV     3C02,W0
00AEC:  MOV.B   #0,W0L
00AEE:  MOV     W0,3C02
....................   LCD_write(peligro);
00AF0:  MOV     #3BEE,W4
00AF2:  MOV     W4,3C28
00AF4:  CALL    86A
*
00AF8:  RETURN  
.................... }
.................... 
.................... void display_final(void)
.................... {
....................   LCD_command(_CLEAR_DISPLAY);
*
00DFA:  MOV     3C2E,W0
00DFC:  MOV.B   #1,W0L
00DFE:  MOV     W0,3C2E
00E00:  CALL    75A
....................   LCD_cursor_at(0,0);
*
00E04:  MOV     3C28,W0
00E06:  MOV.B   #0,W0L
00E08:  MOV     W0,3C28
00E0A:  MOV     3C28,W0
00E0C:  CLR.B   1
00E0E:  MOV     W0,3C28
00E10:  CALL    84A
....................   char fin[]="Fin del programa";
*
00E14:  MOV     #6946,W4
00E16:  MOV     W4,3BEE
00E18:  MOV     #206E,W4
00E1A:  MOV     W4,3BF0
00E1C:  MOV     #6564,W4
00E1E:  MOV     W4,3BF2
00E20:  MOV     #206C,W4
00E22:  MOV     W4,3BF4
00E24:  MOV     #7270,W4
00E26:  MOV     W4,3BF6
00E28:  MOV     #676F,W4
00E2A:  MOV     W4,3BF8
00E2C:  MOV     #6172,W4
00E2E:  MOV     W4,3BFA
00E30:  MOV     #616D,W4
00E32:  MOV     W4,3BFC
00E34:  MOV     3BFE,W0
00E36:  MOV.B   #0,W0L
00E38:  MOV     W0,3BFE
....................   LCD_write(fin);
00E3A:  MOV     #3BEE,W4
00E3C:  MOV     W4,3C28
00E3E:  CALL    86A
*
00E42:  RETURN  
.................... }
.................... 
.................... /**
.................... /**
....................  @file    main.c
....................  @author  Ricardo Gomez
.................... 
....................  @brief   main EEC
.................... */
.................... 
.................... /* SECTION 1: Included header files to compile this file           */
.................... 
.................... #include <common.h>
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #ifndef LIB_h
.................... #define LIB_h
.................... 
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device DSPIC33FJ128MC804
*
00B42:  MOV     W1,[W15++]
00B44:  MOV     3BDE,W1
00B46:  MOV.B   W0L,[W1++]
00B48:  CLR.B   [W1]
00B4A:  MOV     [--W15],W1
00B4C:  MOV     3BDE,W0
00B4E:  INC     W0,W0
00B50:  MOV     W0,3BDE
00B52:  RETURN  
00B54:  MOV     W5,[W15++]
00B56:  MOV     #C,W5
00B58:  REPEAT  #3
00B5A:  MOV     [W5++],[W15++]
00B5C:  BTSS    W0.F
00B5E:  BRA     B7E
00B60:  NEG     W0,W0
00B62:  BSET    W4.8
00B64:  BTSS    W4.F
00B66:  BRA     B7E
00B68:  MOV     W0,[W15++]
00B6A:  MOV     #2D,W0
00B6C:  MOV     W4,[W15++]
00B6E:  MOV     W0,[W15++]
00B70:  MOV     [--W15],W0
00B72:  CALL    B42
*
00B76:  MOV     [--W15],W4
00B78:  MOV     [--W15],W0
00B7A:  BCLR    W4.8
00B7C:  DEC.B   0008
00B7E:  CLR     W5
00B80:  MOV     W0,W7
00B82:  MOV     W4,W9
00B84:  BCLR    W4.F
00B86:  CP0.B   W4L
00B88:  BRA     NZ,B96
00B8A:  BTSC    W9.F
00B8C:  BRA     B92
00B8E:  MOV     #0,W5
00B90:  BRA     BC0
00B92:  MOV     #0,W5
00B94:  BRA     BC0
00B96:  BTSS    W9.8
00B98:  SUB.B   W4L,#6,W5L
00B9A:  BTSC    W9.8
00B9C:  SUB.B   W4L,#7,W5L
00B9E:  BRA     NC,BBE
00BA0:  MOV     #30,W0
00BA2:  BTSS    W9.F
00BA4:  MOV     #20,W0
00BA6:  MOV     W0,[W15++]
00BA8:  MOV     W4,[W15++]
00BAA:  MOV     W0,[W15++]
00BAC:  MOV     [--W15],W0
00BAE:  CALL    B42
*
00BB2:  MOV     [--W15],W4
00BB4:  MOV     [--W15],W0
00BB6:  DEC     W5,W5
00BB8:  BRA     NN,BA6
00BBA:  MOV     #5,W5
00BBC:  BRA     BC0
00BBE:  MOV     W4,W5
00BC0:  MOV     #6,W4
00BC2:  BTSC    W5.8
00BC4:  INC     W4,W4
00BC6:  BSET    W5.E
00BC8:  BTSC    W9.F
00BCA:  BSET    W5.F
00BCC:  MOV     #2710,W8
00BCE:  REPEAT  #11
00BD0:  DIV.U   W7,W8
00BD2:  CALL    C26
*
00BD6:  MOV     W1,W7
00BD8:  MOV     #3E8,W8
00BDA:  REPEAT  #11
00BDC:  DIV.U   W7,W8
00BDE:  CALL    C26
*
00BE2:  MOV     W1,W7
00BE4:  MOV     #64,W8
00BE6:  REPEAT  #11
00BE8:  DIV.U   W7,W8
00BEA:  CALL    C26
*
00BEE:  MOV     W1,W7
00BF0:  MOV     #A,W8
00BF2:  REPEAT  #11
00BF4:  DIV.U   W7,W8
00BF6:  CALL    C26
*
00BFA:  BTSS    W9.8
00BFC:  BRA     C12
00BFE:  MOV     #2D,W0
00C00:  MOV     W1,[W15++]
00C02:  MOV     W4,[W15++]
00C04:  MOV     W0,[W15++]
00C06:  MOV     [--W15],W0
00C08:  CALL    B42
*
00C0C:  MOV     [--W15],W4
00C0E:  MOV     [--W15],W1
00C10:  BCLR    W9.8
00C12:  MOV     #30,W0
00C14:  ADD.B   W1L,W0L,W0L
00C16:  MOV     W0,2A
00C18:  MOV     W4,[W15++]
00C1A:  MOV     W0,[W15++]
00C1C:  MOV     [--W15],W0
00C1E:  CALL    B42
*
00C22:  MOV     [--W15],W4
00C24:  BRA     C7A
00C26:  MOV     #30,W6
00C28:  CP0     W0
00C2A:  BRA     NZ,C48
00C2C:  BTSS    W5.E
00C2E:  BRA     C66
00C30:  DEC     W4,W4
00C32:  CP.B    W4L,W5L
00C34:  BRA     Z,C3A
00C36:  BTSC.B  42.0
00C38:  RETURN  
00C3A:  CP0     W0
00C3C:  BRA     NZ,C48
00C3E:  BTSS    W5.E
00C40:  BRA     C66
00C42:  BTSS    W5.F
00C44:  MOV     #20,W6
00C46:  BRA     C66
00C48:  BCLR    W5.E
00C4A:  BTSS    W9.8
00C4C:  BRA     C66
00C4E:  MOV     W0,W10
00C50:  MOV     #2D,W0
00C52:  MOV     W1,[W15++]
00C54:  MOV     W4,[W15++]
00C56:  MOV     W0,[W15++]
00C58:  MOV     [--W15],W0
00C5A:  CALL    B42
*
00C5E:  MOV     [--W15],W4
00C60:  MOV     [--W15],W1
00C62:  BCLR    W9.8
00C64:  MOV     W10,W0
00C66:  ADD.B   W6L,W0L,W0L
00C68:  MOV     W1,[W15++]
00C6A:  MOV     W4,[W15++]
00C6C:  MOV     W0,[W15++]
00C6E:  MOV     [--W15],W0
00C70:  CALL    B42
*
00C74:  MOV     [--W15],W4
00C76:  MOV     [--W15],W1
00C78:  RETURN  
00C7A:  MOV     #12,W5
00C7C:  REPEAT  #3
00C7E:  MOV     [--W15],[W5--]
00C80:  MOV     [--W15],W5
00C82:  RETURN  
.................... 
.................... #list
.................... 
.................... #endif
.................... 
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... #WORD ADC1BUF0 = 0x0300;
.................... #WORD ADC1CON1 = 0x0320;
.................... #WORD ADC1CON2 = 0x0322;
.................... #WORD ADC1CON3 = 0x0324;
.................... #WORD AD1CHS0 = 0x0328;
.................... #WORD AD1PCFGL = 0x032C;
.................... #WORD IFS0 = 0x0084;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "lcd.h"
.................... /**
....................  @file    lcd.h
....................  @author  Ricardo Gï¿½mez
....................  @brief   LCD management
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __LCD_H
.................... #define __LCD_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... /* SECTION 1: Included header files to compile this file           */
.................... 
.................... /* SECTION 2: Public macros                                        */
.................... 
.................... #define _CLEAR_DISPLAY 				0x01
.................... #define _8BIT_4LINES_NORMAL_RE1_IS0		0x3A
.................... #define _8BIT_4LINES_REVERSE_RE1_IS0		0x3B
.................... #define _8BIT_4LINES_RE0_IS1			0x39
.................... #define _8BIT_4LINES_RE0_IS0			0x38
.................... 
.................... #define _BS1_1					0x1E
.................... #define _POWER_DOWN_DISABLE			0x02
.................... #define _SEGMENT_NORMAL_WAY			0x05
.................... #define _NW					0x09
.................... 
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_ON		0x0F
.................... #define _DISPLAY_ON_CURSOR_ON_BLINK_OFF		0x0E
.................... #define _DISPLAY_ON_CURSOR_OFF_BLINK_OFF	0x0C
.................... #define _BS0_1					0x1C
.................... #define _INTERNAL_DIVIDER			0x13
.................... #define _CONTRAST				0x77
.................... #define _POWER_ICON_CONTRAST			0x5C
.................... #define _FOLLOWER_CONTROL			0x6E
.................... 
.................... #define ADDRESS_DDRAM				0x80
.................... 
.................... 
.................... /* SECTION 3: Public types                                         */
.................... 
.................... 
.................... /* SECTION 4: Public variables :: declarations, extern mandatory   */
.................... 
.................... 
.................... /* SECTION 5: Public functions :: declarations, extern optional
....................    Rule exception (callbacks)  :: declarations, extern recommended */
.................... void display_valueADC_title(void);
.................... void LCD_command(unsigned int8);
.................... void lcdi2cinit(void);
.................... void LCD_write(char*);
.................... void initmenu(void);                                      //Inicializa el menu principal
.................... void display_frecuencia(void);       // Muestra frecuencia
.................... void LCD_cursor_at(unsigned int8 line, unsigned int8 column);
.................... void display_alarma_alto(void); // Limpia pantalla y escribe mensaje de alarma
.................... void display_alarma_bajo(void);
.................... void display_final(void);
.................... 
.................... 
.................... #endif // __LCD_H
.................... // Do not write below this line!
.................... 
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #ifndef LIB_h
.................... #define LIB_h
.................... 
.................... //////////// Standard Header file for the DSPIC33FJ128MC804 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device DSPIC33FJ128MC804
.................... 
.................... #nolist
.................... //////// Program memory: 44032x24  Data RAM: 16384  Stack: 31
.................... //////// I/O: 35   Analog Pins: 9
.................... //////// Fuses: WRTB,NOWRTB,BSSHL,BSSHM,BSSHS,BSSSL,BSSSM,BSSSS,NOBSS
.................... //////// Fuses: RBS1024,RBS256,RBS128,NORBS,WRTSS,NOWRTSS,SSSHL,SSSHM,SSSHS
.................... //////// Fuses: SSSSL,SSSSM,SSSSS,NOSSS,RSS4096,RSS2048,RSS256,NORSS,WRT
.................... //////// Fuses: NOWRT,PROTECT_HIGH,PROTECT,NOPROTECT,FRC,FRC_PLL,PR,PR_PLL
.................... //////// Fuses: SOSC,LPRC,FRC_DIV_BY_16,FRC_PS,NOIESO,IESO,EC,XT,HS,NOPR
.................... //////// Fuses: OSCIO,NOOSCIO,NOIOL1WAY,IOL1WAY,CKSFSM,CKSNOFSM,NOCKSFSM
.................... //////// Fuses: WPOSTS1,WPOSTS2,WPOSTS3,WPOSTS4,WPOSTS5,WPOSTS6,WPOSTS7
.................... //////// Fuses: WPOSTS8,WPOSTS9,WPOSTS10,WPOSTS11,WPOSTS12,WPOSTS13,WPOSTS14
.................... //////// Fuses: WPOSTS15,WPOSTS16,WPRES32,WPRES128,NOWINDIS,WINDIS,NOWDT,WDT
.................... //////// Fuses: NOPUT,PUT2,PUT4,PUT8,PUT16,PUT32,PUT64,PUT128,ALTI2C1
.................... //////// Fuses: NOALTI2C1,LPOL_LOW,LPOL_HIGH,HPOL_LOW,HPOL_HIGH,PWMPIN
.................... //////// Fuses: NOPWMPIN,ICSP3,ICSP2,ICSP1,NOJTAG,JTAG,DEBUG,NODEBUG
.................... ////////
.................... #if (!defined(__PCD__)||defined(__ISNT_CCS__))
.................... #define _bif
.................... #define int8 char
.................... #define int16 int
.................... #define int32 long
.................... #define int48 long
.................... #define int64 long long
.................... #define float32 float
.................... #define float48 float
.................... #define float64 double
.................... #define int1 char
.................... 
.................... #endif
.................... ////////////////////////////////////////////////////////////////// PIN_SELECT
.................... // #pin_select function=pin
.................... // Valid Pins:
.................... //    PIN_B0,PIN_B1,PIN_B2,PIN_B3,PIN_B4,PIN_B5,PIN_B6,PIN_B7,PIN_B8,PIN_B9,
.................... //    PIN_B10,PIN_B11,PIN_B12,PIN_B13,PIN_B14,PIN_B15,PIN_C0,PIN_C1,PIN_C2,
.................... //    PIN_C3,PIN_C4,PIN_C5,PIN_C6,PIN_C7,PIN_C8,PIN_C9
.................... // Input Functions:
.................... //    INT1,INT2,T2CK,T3CK,T4CK,T5CK,IC1,IC2,IC3,IC4,IC5,OCFA,OCFB,U1RX,U1CTS,
.................... //    U2RX,U2CTS,SDI1,SCK1IN,SS1IN,SDI2,SCK2IN,SS2IN,C1RX,IC7,IC8,CSDI,CSCK,COFS,
.................... //    FLTA1,FLTA2,QEA1,QEB1,INDX1,QEA2,QEB2,INDX2,T1CK,FLT1,FLT2,FLT3,FLT4,FLT5,
.................... //    FLT6,FLT7,FLT8,SYNCI1,SYNCI2
.................... // Output Functions:
.................... //    NULL,C1OUT,C2OUT,U1TX,U1RTS,U2TX,U2RTS,SDO1,SCK1OUT,SS1OUT,SDO2,SCK2OUT,
.................... //    SS2OUT,OC1,OC2,OC3,OC4,OC5,C1TX,CSDO,CSCKOUT,COFSOUT,UPDN1,UPDN2,CTPLS,
.................... //    C3OUT,SYNCO1,REFCLKO,CMP1,CMP2,CMP3,CMP4,PWM4H,PWM4L
.................... //
.................... 
.................... ////////////////////////////////////////////////////////////////// I/O
.................... // Discrete I/O Functions: SET_TRIS_x(), OUTPUT_x(), INPUT_x(),
.................... //                         SET_PULLUP(), INPUT(),
.................... //                         OUTPUT_LOW(), OUTPUT_HIGH(),
.................... //                         OUTPUT_FLOAT(), OUTPUT_BIT()
.................... // Discrete I/O Prototypes:
.................... _bif void set_tris_a(unsigned int16 value);
.................... _bif void set_tris_b(unsigned int16 value);
.................... _bif void set_tris_c(unsigned int16 value);
.................... _bif unsigned int16 get_tris_a(void);
.................... _bif unsigned int16 get_tris_b(void);
.................... _bif unsigned int16 get_tris_c(void);
.................... _bif void output_a(unsigned int16 value);
.................... _bif void output_b(unsigned int16 value);
.................... _bif void output_c(unsigned int16 value);
.................... _bif unsigned int16 input_a(void);
.................... _bif unsigned int16 input_b(void);
.................... _bif unsigned int16 input_c(void);
.................... _bif int16 input_change_a(void);
.................... _bif int16 input_change_b(void);
.................... _bif int16 input_change_c(void);
.................... _bif void set_pullup(int1 state);
.................... _bif void set_pullup(int1 state, unsigned int16 pin);
.................... _bif void set_pulldown(int1 state);
.................... _bif void set_pulldown(int1 state, unsigned int16 pin);
.................... _bif int1 input(unsigned int16 pin);
.................... _bif int1 input_state(unsigned int16 pin);
.................... _bif void output_low(unsigned int16 pin);
.................... _bif void output_high(unsigned int16 pin);
.................... _bif void output_toggle(unsigned int16 pin);
.................... _bif void output_bit(unsigned int16 pin, int1 level);
.................... _bif void output_float(unsigned int16 pin);
.................... _bif void output_drive(unsigned int16 pin);
.................... // Constants used to identify pins in the above are:
.................... 
.................... #define PIN_A0  5648
.................... #define PIN_A1  5649
.................... #define PIN_A2  5650
.................... #define PIN_A3  5651
.................... #define PIN_A4  5652
.................... #define PIN_A7  5655
.................... #define PIN_A8  5656
.................... #define PIN_A9  5657
.................... #define PIN_A10  5658
.................... 
.................... #define PIN_B0  5712
.................... #define PIN_B1  5713
.................... #define PIN_B2  5714
.................... #define PIN_B3  5715
.................... #define PIN_B4  5716
.................... #define PIN_B5  5717
.................... #define PIN_B6  5718
.................... #define PIN_B7  5719
.................... #define PIN_B8  5720
.................... #define PIN_B9  5721
.................... #define PIN_B10  5722
.................... #define PIN_B11  5723
.................... #define PIN_B12  5724
.................... #define PIN_B13  5725
.................... #define PIN_B14  5726
.................... #define PIN_B15  5727
.................... 
.................... #define PIN_C0  5776
.................... #define PIN_C1  5777
.................... #define PIN_C2  5778
.................... #define PIN_C3  5779
.................... #define PIN_C4  5780
.................... #define PIN_C5  5781
.................... #define PIN_C6  5782
.................... #define PIN_C7  5783
.................... #define PIN_C8  5784
.................... #define PIN_C9  5785
.................... 
.................... ////////////////////////////////////////////////////////////////// Useful defines
.................... #define FALSE 0
.................... #define TRUE 1
.................... 
.................... #define BYTE unsigned int8
.................... #define BOOLEAN int1
.................... 
.................... #define getc getch
.................... #define fgetc getch
.................... #define getchar getch
.................... #define putc putchar
.................... #define fputc putchar
.................... #define fgets gets
.................... #define fputs puts
.................... 
.................... ////////////////////////////////////////////////////////////////// UART
.................... // UART Prototypes:
.................... _bif void setup_uart(unsigned int32 baud);
.................... _bif void setup_uart(unsigned int32 baud, unsigned int8 stream);
.................... _bif void setup_uart(unsigned int32 baud, unsigned int8 stream, unsigned int32 clock);
.................... _bif void set_uart_speed(unsigned int32 baud);
.................... _bif void set_uart_speed(unsigned int32 baud, unsigned int8 stream);
.................... _bif void set_uart_speed(unsigned int32 baud, unsigned int8 stream, unsigned int32 clock);
.................... // Constants used in setup_uart() are:
.................... // FALSE - Turn UART off
.................... // TRUE  - Turn UART on
.................... #define UART_ADDRESS           2
.................... #define UART_DATA              4
.................... #define UART_AUTODETECT        8
.................... #define UART_AUTODETECT_NOWAIT 9
.................... #define UART_WAKEUP_ON_RDA     10
.................... #define UART_SEND_BREAK        13
.................... 
.................... ////////////////////////////////////////////////////////////////// WDT
.................... // Watch Dog Timer Functions: SETUP_WDT() and RESTART_WDT()
.................... // WDT Prototypes:
.................... _bif void setup_wdt(unsigned int8 mode);
.................... _bif void restart_wdt(void);
.................... // Constants used for SETUP_WDT() are:
.................... #define WDT_ON      1
.................... #define WDT_OFF     0
.................... 
.................... #define  WDT_1MS    0x002
.................... #define  WDT_2MS    0x003
.................... #define  WDT_4MS    0x004
.................... #define  WDT_8MS    0x005
.................... #define  WDT_16MS   0x006
.................... #define  WDT_32MS   0x007
.................... #define  WDT_64MS   0x008
.................... #define  WDT_128MS  0x009
.................... #define  WDT_256MS  0x00A
.................... #define  WDT_512MS  0x00B
.................... #define  WDT_1S     0x00C
.................... #define  WDT_2S     0x00D
.................... #define  WDT_4S     0x00E
.................... #define  WDT_8S     0x00F
.................... #define  WDT_16S    0x010
.................... #define  WDT_33S    0x011
.................... #define  WDT_65S    0x030
.................... #define  WDT_131S   0x031
.................... 
.................... ////////////////////////////////////////////////////////////////// Control
.................... // Control Functions:  RESET_CPU(), SLEEP(), RESTART_CAUSE()
.................... // Prototypes:
.................... _bif unsigned int8 restart_cause(void);
.................... _bif void reset_cpu(void);
.................... _bif void sleep(void);
.................... _bif void sleep(unsigned int8 mode);
.................... // Constants passed into RESTART_CAUSE() are:
.................... #define RESTART_POWER_UP      0
.................... #define RESTART_BROWNOUT      1
.................... #define RESTART_WATCHDOG      4
.................... #define RESTART_SOFTWARE      6
.................... #define RESTART_MCLR          7
.................... #define RESTART_ILLEGAL_OP    14
.................... #define RESTART_TRAP_CONFLICT 15
.................... //
.................... // Constants passed into SLEEP() are:
.................... #define SLEEP_FULL      0  // Default
.................... #define SLEEP_IDLE      1  // Clock and peripherals don't stop
.................... 
.................... ////////////////////////////////////////////////////////////////// INTERNAL RC
.................... // Oscillator Prototypes:
.................... _bif void setup_oscillator(unsigned int8 type, unsigned int32 target);
.................... _bif void setup_oscillator(unsigned int8 type, unsigned int32 target, unsigned int32 source);
.................... // Constants used in setup_oscillator() are:
.................... #define OSC_INTERNAL     32
.................... #define OSC_CRYSTAL       1
.................... #define OSC_CLOCK         2
.................... #define OSC_RC            3
.................... #define OSC_SECONDARY    16
.................... 
.................... ////////////////////////////////////////////////////////////////// Timer
.................... // Timer Functions: SETUP_TIMERx, GET_TIMERx, GET_TIMERxy,
.................... // SET_TIMERx, SET_TIMERxy
.................... // Timer x Prototypes:
.................... _bif void setup_timer1(unsigned int16 mode);
.................... _bif void setup_timer1(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer1(void);
.................... _bif void set_timer1(unsigned int16 value);
.................... _bif void setup_timer2(unsigned int16 mode);
.................... _bif void setup_timer2(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer2(void);
.................... _bif void set_timer2(unsigned int16 value);
.................... _bif void setup_timer3(unsigned int16 mode);
.................... _bif void setup_timer3(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer3(void);
.................... _bif void set_timer3(unsigned int16 value);
.................... _bif unsigned int32 get_timer23(void);
.................... _bif void set_timer23(unsigned int32 value);
.................... _bif void setup_timer4(unsigned int16 mode);
.................... _bif void setup_timer4(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer4(void);
.................... _bif void set_timer4(unsigned int16 value);
.................... _bif void setup_timer5(unsigned int16 mode);
.................... _bif void setup_timer5(unsigned int16 mode, unsigned int16 period);
.................... _bif unsigned int16 get_timer5(void);
.................... _bif void set_timer5(unsigned int16 value);
.................... _bif unsigned int32 get_timer45(void);
.................... _bif void set_timer45(unsigned int32 value);
.................... // Constants used for SETUP_TIMERx() are:
.................... //      (or (via |) together constants from each group)
.................... #define TMR_DISABLED 0x0000
.................... #define TMR_INTERNAL 0x8000
.................... #define TMR_EXTERNAL 0x8002
.................... #define TMR_GATE     0x0040
.................... 
.................... #define TMR_DIV_BY_1   0x0000
.................... #define TMR_DIV_BY_8   0x0010
.................... #define TMR_DIV_BY_64  0x0020
.................... #define TMR_DIV_BY_256 0x0030
.................... #define TMR_32_BIT     0x0008 // Only for even numbered timers
.................... 
.................... #define TMR_HALT_IDLE      0x2000
.................... #define TMR_CONTINUE_IDLE  0x0000
.................... 
.................... #define T1_EXTERNAL_SYNC  0x8006 //This only applies to Timer1
.................... #define T1_EXTERNAL_RTC   0xC002 //This only applies to Timer1
.................... /////////////////////////////////////////////////////////// INPUT CAPTURE
.................... // Functions: SETUP_CAPTURE, GET_CAPTURE,
.................... // IC Prototypes:
.................... _bif void setup_capture(unsigned int8 module, unsigned int16 mode);
.................... _bif unsigned int16 get_capture(unsigned int8 module);
.................... _bif unsigned int16 get_capture(unsigned int8 module, int1 wait);
.................... // Constants used for SETUP_CAPTURE() are:
.................... #define CAPTURE_OFF               0x0000  // Capture OFF
.................... #define CAPTURE_EE                0x0001  // Capture Every Edge
.................... #define CAPTURE_FE                0x0002  // Capture Falling Edge
.................... #define CAPTURE_RE                0x0003  // Capture Rising Edge
.................... #define CAPTURE_DIV_4             0x0004  // Capture Every 4th Rising Edge
.................... #define CAPTURE_DIV_16            0x0005  // Capture Every 16th Rising Edge
.................... #define CAPTURE_INTERRUPT_ONLY    0x0007  // Interrupt on Rising Edge when in Sleep or Idle
.................... 
.................... // The following defines can be ORed | with above to configure interrupts
.................... #define INTERRUPT_EVERY_CAPTURE   0x0000  // Interrupt on every capture event
.................... #define INTERRUPT_SECOND_CAPTURE  0x0020  // Interrupt on every second capture event
.................... #define INTERRUPT_THIRD_CAPTURE   0x0040  // Interrupt on every third capture event
.................... #define INTERRUPT_FOURTH_CAPTURE  0x0060  // Interrupt on every fourth capture event
.................... 
.................... // The following defines can be ORed | with above to select timer
.................... #define CAPTURE_TIMER2            0x0080  // On capture event Timer 2 is captured
.................... #define CAPTURE_TIMER3            0x0000  // On capture event Timer 3 is captured
.................... 
.................... // The following defines can be ORed | with above to select idle operation mode
.................... #define CAPTURE_HALT_IDLE         0x2000  // Capture module halts during idle mode
.................... #define CAPTURE_CONTINUE_IDLE     0x0000  // Capture module continues during idle mode
.................... 
.................... /////////////////////////////////////////////////////////// OUTPUT COMPARE
.................... // Functions: SETUP_COMPARE, SET_PWM_DUTY, SET_COMPARE_TIME
.................... // OC Prototypes:
.................... _bif void setup_compare(unsigned int8 module, unsigned int16 mode);
.................... _bif void set_pwm_duty(unsigned int8 module, unsigned int16 duty);
.................... _bif void set_compare_time(unsigned int8 module, unsigned int16 ocr);
.................... _bif void set_compare_time(unsigned int8 module, unsigned int16 ocr, unsigned int16 ocrs);
.................... // Constants used for SETUP_COMPARE() are:
.................... #define COMPARE_OFF               0x0000  // Compare OFF
.................... #define COMPARE_SET_ON_MATCH      0x0001  // Pin from low to high on match
.................... #define COMPARE_CLR_ON_MATCH      0x0002  // Pin from high to low on match
.................... #define COMPARE_TOGGLE            0x0003  // Pin will toggle on every match occurrence
.................... #define COMPARE_SINGLE_PULSE      0x0004  // Pin will generate single pulse on first match
.................... #define COMPARE_CONT_PULSE        0x0005  // Pin will pulse for every match
.................... #define COMPARE_PWM               0x0006  // Compare operates as PWM with fault pin disabled
.................... #define COMPARE_PWM_FAULT         0x0007  // Compare operates as PWM with fault pin enabled
.................... 
.................... // The following defines can be ORed | with above to select timer
.................... #define COMPARE_TIMER2            0x0000  // Timer 2 is the base timer
.................... #define COMPARE_TIMER3            0x0008  // Timer 3 is the base timer
.................... 
.................... // The following defines can be ORed | with above to select idle operation mode
.................... #define COMPARE_HALT_IDLE         0x2000  // Compare module halts during idle mode
.................... #define COMPARE_CONTINUE_IDLE     0x0000  // Compare module continues during idle mode
.................... 
.................... ////////////////////////////////////////////////////////////////// SPI
.................... // SPI Functions: SETUP_SPI, SPI_WRITE, SPI_READ, SPI_DATA_IN
.................... // SPI Prototypes:
.................... _bif void setup_spi(unsigned int16 mode);
.................... _bif void spi_write(unsigned int8 data);
.................... _bif void spi_write(int1 wait, unsigned int8 data);
.................... _bif void spi_write_16(unsigned int16 data);
.................... _bif void spi_write_16(int1 wait, unsigned int16 data);
.................... _bif unsigned int8 spi_read(void);
.................... _bif unsigned int8 spi_read(unsigned int8 data);
.................... _bif unsigned int16 spi_read_16(void);
.................... _bif unsigned int16 spi_read_16(unsigned int16 data);
.................... _bif int1 spi_data_in(void);
.................... _bif void setup_spi2(unsigned int16 mode);
.................... _bif void spi_write2(unsigned int8 data);
.................... _bif void spi_write2(int1 wait, unsigned int8 data);
.................... _bif void spi_write2_16(unsigned int16 data);
.................... _bif void spi_write2_16(int1 wait, unsigned int16 data);
.................... _bif unsigned int8 spi_read2(void);
.................... _bif unsigned int8 spi_read2(unsigned int8 data);
.................... _bif unsigned int16 spi_read2_16(void);
.................... _bif unsigned int16 spi_read2_16(unsigned int16 data);
.................... _bif int1 spi_data_in2(void);
.................... // Constants used in SETUP_SPI() are:
.................... //      (or (via |) together constants from each group)
.................... #define SPI_MASTER                 0x0020
.................... #define SPI_SLAVE                  0x0000
.................... 
.................... #define SPI_SCK_IDLE_HIGH          0x0040
.................... #define SPI_SCK_IDLE_LOW           0x0000
.................... 
.................... #define SPI_XMIT_L_TO_H            0x0100
.................... #define SPI_XMIT_H_TO_L            0x0000
.................... 
.................... #define SPI_MODE_16B               0x0400
.................... #define SPI_MODE_8B                0x0000
.................... 
.................... #define SPI_SAMPLE_AT_END          0x0200
.................... #define SPI_SAMPLE_AT_MIDDLE       0x0000
.................... 
.................... #define SPI_SS_ENABLED             0x0000
.................... #define SPI_SS_DISABLED            0x0080
.................... 
.................... //or (via |) one of the following when operating as MASTER
.................... #define SPI_CLK_DIV_1              0x001F
.................... #define SPI_CLK_DIV_2              0x001B
.................... #define SPI_CLK_DIV_3              0x0017
.................... #define SPI_CLK_DIV_4              0x001E
.................... #define SPI_CLK_DIV_5              0x000F
.................... #define SPI_CLK_DIV_6              0x000B
.................... #define SPI_CLK_DIV_7              0x0007
.................... #define SPI_CLK_DIV_8              0x0003
.................... #define SPI_CLK_DIV_12             0x0016
.................... #define SPI_CLK_DIV_16             0x001D
.................... #define SPI_CLK_DIV_20             0x000E
.................... #define SPI_CLK_DIV_24             0x000A
.................... #define SPI_CLK_DIV_28             0x0006
.................... #define SPI_CLK_DIV_32             0x0002
.................... #define SPI_CLK_DIV_48             0x0015
.................... #define SPI_CLK_DIV_64             0x001C
.................... #define SPI_CLK_DIV_80             0x000D
.................... #define SPI_CLK_DIV_96             0x0009
.................... #define SPI_CLK_DIV_112            0x0005
.................... #define SPI_CLK_DIV_128            0x0001
.................... #define SPI_CLK_DIV_192            0x0014
.................... #define SPI_CLK_DIV_256            0x0010
.................... #define SPI_CLK_DIV_320            0x000C
.................... #define SPI_CLK_DIV_384            0x0008
.................... #define SPI_CLK_DIV_448            0x0004
.................... #define SPI_CLK_DIV_512            0x0000
.................... 
.................... //The following defines are provided for compatibility
.................... #define SPI_L_TO_H         SPI_SCK_IDLE_LOW
.................... #define SPI_H_TO_L         SPI_SCK_IDLE_HIGH
.................... 
.................... ////////////////////////////////////////////////////////////////// ADC
.................... // ADC Functions: SETUP_ADC(), SETUP_ADC_PORTS()
.................... //                SET_ADC_CHANNEL(), READ_ADC()
.................... // ADC Prototypes:
.................... _bif void setup_adc(unsigned int32 mode);
.................... _bif void setup_adc_ports(unsigned int32 pins);
.................... _bif void setup_adc_ports(unsigned int32 pins, unsigned int16 reference);
.................... _bif void set_adc_channel(unsigned int8 channel);
.................... _bif void set_adc_channel(unsigned int8 channel, unsigned int8 neg_channel);
.................... _bif unsigned int16 read_adc(void);
.................... _bif unsigned int16 read_adc(unsigned int8 mode);
.................... _bif int1 adc_done(void);
.................... // Constants used for SETUP_ADC() are:
.................... // Clock is at ADCS<5:0> of ADCON3 Reg. (0x02A4)
.................... // Tad = (Tcy/2)*(ADCS<5:0>+1)
.................... #define ADC_OFF                 0x10000
.................... #define ADC_CLOCK                0x0000
.................... #define ADC_CLOCK_DIV_2          0x0001
.................... #define ADC_CLOCK_DIV_4          0x0003
.................... #define ADC_CLOCK_DIV_8          0x0007
.................... #define ADC_CLOCK_DIV_16         0x000F
.................... #define ADC_CLOCK_DIV_32         0x001F
.................... #define ADC_CLOCK_DIV_64         0x003F
.................... #define ADC_CLOCK_INTERNAL       0x8000     // Internal
.................... 
.................... // One of the following may be OR'ed in with the above using |
.................... // Auto-Sample Time bits
.................... #define ADC_TAD_MUL_0            0x1F00
.................... #define ADC_TAD_MUL_2            0x1D00
.................... #define ADC_TAD_MUL_4            0x1B00
.................... #define ADC_TAD_MUL_8            0x1700
.................... #define ADC_TAD_MUL_16           0x0F00
.................... #define ADC_TAD_MUL_31           0x0000
.................... 
.................... // Constants used in READ_ADC() are:
.................... #define ADC_START_AND_READ       0x07
.................... #define ADC_START_ONLY           0x01
.................... #define ADC_READ_ONLY            0x06
.................... 
.................... // Constants used in SET_ADC_CHANNEL() second parameter are:
.................... #define VSS                      0
.................... 
.................... // Constants used in SETUP_ADC_PORTS() are:
.................... // First argument:
.................... // OR together desired pins
.................... #define NO_ANALOGS      0           // None
.................... #define ALL_ANALOG      0xFFFFFFFF  // All
.................... #define sAN0      0x00000001 //| A0
.................... #define sAN1      0x00000002 //| A1
.................... #define sAN2      0x00000004 //| B0
.................... #define sAN3      0x00000008 //| B1
.................... #define sAN4      0x00000010 //| B2
.................... #define sAN5      0x00000020 //| B3
.................... #define sAN6      0x00000040 //| C0
.................... #define sAN7      0x00000080 //| C1
.................... #define sAN8      0x00000100 //| C2
.................... 
.................... // Optional Second argument:
.................... #define VSS_VDD            0x0000 // Range 0-Vdd
.................... #define VREF_VREF          0x6000 // Range VrefL-VrefH
.................... #define VREF_VDD           0x4000 // Range VrefL-Vdd
.................... #define VSS_VREF           0x2000 // Range 0-VrefH
.................... 
.................... ////////////////////////////////////////////////////////////////// COMP
.................... // Comparator Functions: setup_comparator()
.................... // Comparator Variables: C1OUT, C2OUT
.................... // Comparator Prototypes:
.................... _bif void setup_comparator(unsigned int16 mode);
.................... // Constants used in setup_comparator() are:
.................... #define NC_NC_NC_NC      0
.................... #define B2_B3_NC_NC      0x401
.................... #define B2_VR_NC_NC      0x400
.................... #define B3_VR_NC_NC      0x402
.................... #define NC_NC_B0_B1      0x804
.................... #define NC_NC_B0_VR      0x800
.................... #define NC_NC_B1_VR      0x808
.................... #define B2_B3_B0_B1      B2_B3_NC_NC | NC_NC_B0_B1
.................... #define B2_VR_B0_VR      B2_VR_NC_NC | NC_NC_B0_VR
.................... #define B3_VR_B1_VR      B3_VR_NC_NC | NC_NC_B1_VR
.................... 
.................... #define C1_INVERT     0x10
.................... #define C2_INVERT     0x20
.................... #define C1_OUTPUT     0x100
.................... #define C2_OUTPUT     0x200
.................... 
.................... #bit C1OUT = getenv("SFR:CMCON").6
.................... #bit C2OUT = getenv("SFR:CMCON").7
.................... 
.................... ////////////////////////////////////////////////////////////////// VREF
.................... // VREF Prototypes:
.................... _bif void setup_vref(unsigned int16 mode);
.................... // Constants used in setup_vref() are:
.................... #define VREF_DISABLED  0x0000
.................... #define VREF_VSS_VDD   0x0080
.................... #define VREF_ANALOG    0x0090
.................... // One of the following maybe OR'ed in with the above using |
.................... #define VREF_HIGH      0x0080
.................... #define VREF_LOW       0x00A0
.................... // The following maybe OR'ed in with the above using |
.................... #define VREF_OUTPUT    0x0040
.................... // Or (with |) the above with a number 0-15
.................... 
.................... ////////////////////////////////////////////////////////////////// PMP
.................... // PMP Functions: setup_pmp(), pmp_address(), psp_read(), pmp_read(),
.................... // psp_write(), pmp_write(), psp_output_full(),psp_input_full(),
.................... // psp_overflow(), pmp_output_full(), pmp_input_full(),
.................... // pmp_overflow()
.................... // PMP Prototypes:
.................... _bif void setup_pmp(unsigned int32 mode, unsigned int16 address_mask);
.................... _bif void pmp_address(unsigned int16 address);
.................... _bif unsigned int8 pmp_read(void);
.................... _bif void pmp_write(unsigned int8 data);
.................... _bif int1 pmp_output_full(void);
.................... _bif int1 pmp_input_full(void);
.................... _bif int1 pmp_overflow(void);
.................... _bif void setup_psp(unsigned int32 mode, unsigned int16 address_mask);
.................... _bif unsigned int8 psp_read(void);
.................... _bif unsigned int8 psp_read(unsigned int16 address);
.................... _bif void psp_write(unsigned int8 data);
.................... _bif void psp_write(unsigned int8 data, unsigned int16 address);
.................... _bif int1 psp_output_full(void);
.................... _bif int1 psp_input_full(void);
.................... _bif int1 psp_overflow(void);
.................... // Constants used in SETUP_PMP() and SETUP_PSP() are:
.................... #define PAR_ENABLE                0x8000
.................... #define PAR_DISABLE               0x0000    // Module enable/disable options
.................... #define PAR_STOP_IN_IDLE          0x2000
.................... #define PAR_CONTINUE_IN_IDLE      0x0000
.................... #define PAR_ADDR_NOT_MULTIPLEXED  0x0000    // Address multiplexing options
.................... #define PAR_LOW_ADDR_MULTIPLEXED  0x0800    // Address multiplexing options
.................... #define PAR_FULL_ADDR_MULTIPLEXED 0x1000    // Address multiplexing options
.................... #define PAR_PTBEEN_ENABLE         0x0400  // Byte Enable Port Enable bit
.................... #define PAR_PTWREN_ENABLE         0x0200  // Write Enable Strobe bit
.................... #define PAR_PTRDEN_ENABLE         0x0100  // Read/Write Strobe Port bit
.................... #define PAR_ALP_ACTIVE_HIGH       0x0020 // Address latch polarity high
.................... #define PAR_BEP_ACTIVE_HIGH       0x0004 // Byte Enable Polarity
.................... #define PAR_WRSP_ACTIVE_HIGH      0x0002 // Write strobe Polarity bit
.................... #define PAR_RDSP_ACTIVE_HIGH      0x0001 // Read strobe Polarity bit
.................... #define PAR_CS_XX                 0x0000   // Chip select pins used for address
.................... #define PAR_CS_X1                 0x0008   // Chip select pin 1 used, active high
.................... #define PAR_CS_X0                 0x0000   // Chip select pin 1 used, active low
.................... #define PAR_CS_1X                 0x0050   // Chip select pin 2 used, active high
.................... #define PAR_CS_0X                 0x0040   // Chip select pin 2 used, active low
.................... #define PAR_CS_00                 0x0080   // Chip select pins 1,2 used, active low
.................... #define PAR_CS_11                 0x0098   // Chip select pins 1,2 used, active high
.................... #define PAR_CS_10                 0x0090   // Chip select pins 1,2 used, 1 is active low, 2 is high
.................... #define PAR_CS_01                 0x0088   // Chip select pins 1,2 used, 1 is active high, 2 is low
.................... #define PAR_INTR_ON_RW                0x20000000  // Interrupt on read write
.................... #define PAR_NO_INTR_STALL_ACTIVATED   0x40000000  // No interrupt, processor stall activated
.................... #define PAR_INTR_ON_3_RW_BUF          0x60000000 // Interrupt on write to Buffer 3 or read from Buffer 3
.................... #define PAR_PSP_AUTO_INC              0x18000000 // Read write buffers auto increment
.................... #define PAR_DEC_ADDR                  0x10000000 // Increment the address
.................... #define PAR_INC_ADDR                  0x08000000 // Decrement the address
.................... #define PAR_MASTER_MODE_1             0x03000000  // Master mode 1
.................... #define PAR_MASTER_MODE_2             0x02000000  // Master mode 2
.................... #define PAR_WAITB1                    0x00000000 // 1 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB2                    0x00400000 // 2 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB3                    0x00800000 // 3 Tcy Wait state for data setup R/W
.................... #define PAR_WAITB4                    0x00C00000 // 4 Tcy Wait state for data setup R/W
.................... #define PAR_WAITM0                    0x00000000 // 0 wait state for Read to byte
.................... #define PAR_WAITM1                    0x00040000 // 1 Tcy wait state for Read to byte
.................... #define PAR_WAITM2                    0x00080000 // 2 Tcy wait state for Read to byte
.................... #define PAR_WAITM3                    0x000C0000 // 3 Tcy wait state for Read to byte
.................... #define PAR_WAITM15                   0x003C0000 // 15 wait states
.................... #define PAR_WAITE1                    0x00000000  // 1 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE2                    0x00010000 // 2 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE3                    0x00020000 // 3 Tcy Wait for data hold after strobe
.................... #define PAR_WAITE4                    0x00030000 // 4 Tcy Wait for data hold after strobe
.................... 
.................... ////////////////////////////////////////////////////////////////// CRC
.................... // CRC Functions: setup_crc(), crc_init(), crc_calc(), crc_calc8()
.................... // CRC Prototypes:
.................... _bif void setup_crc(unsigned int8 poly_terms, ...);
.................... _bif void crc_init(unsigned int16 value);
.................... _bif unsigned int16 crc_calc(unsigned int16 data);
.................... _bif unsigned int16 crc_calc(unsigned int16 *ptr, unsigned int16 count);
.................... _bif unsigned int8 crc_calc8(unsigned int8 data);
.................... _bif unsigned int8 crc_calc8(unsigned int8 *ptr, unsigned int16 count);
.................... 
.................... ////////////////////////////////////////////////////////////////// RTC
.................... // RTC Functions: setup_rtc(), setup_rtc_alarm(), rtc_read(),
.................... //                rtc_write(), rtc_alarm_read(), rtc_alarm_write()
.................... // Structure used in read and write functions (pass pointer):
.................... typedef struct {
....................    unsigned int8 tm_year;
....................    unsigned int8 tm_temp;  // Not used by built in functions, place holder only do not use
....................    unsigned int8 tm_mday;
....................    unsigned int8 tm_mon;
....................    unsigned int8 tm_hour;
....................    unsigned int8 tm_wday;
....................    unsigned int8 tm_sec;
....................    unsigned int8 tm_min;
....................    unsigned int8 tm_isdst; // Not used by built in functions
.................... } rtc_time_t;
.................... // RTC Prototypes:
.................... _bif void setup_rtc(unsigned int16 mode, unsigned int8 calibration);
.................... _bif void setup_rtc_alarm(unsigned int16 mode, unsigned int16 mask, unsigned int8 repeat);
.................... _bif void rtc_read(rtc_time_t *time);
.................... _bif void rtc_write(rtc_time_t *time);
.................... _bif void rtc_alarm_read(rtc_time_t *time);
.................... _bif void rtc_alarm_write(rtc_time_t *time);
.................... // Constants used in setup_rtc() are:  // Second param is calibration
.................... #define RTC_ENABLE           0x8000
.................... #define RTC_DISABLE          0
.................... #define RTC_OUTPUT_SECONDS   0x20400
.................... #define RTC_OUTPUT_ALARM     0x00400
.................... //
.................... // Constants used in setup_rtc_alarm() first param are:
.................... #define RTC_ALARM_ENABLE     0x8000
.................... #define RTC_ALARM_DISABLE    0
.................... #define RTC_CHIME_ENABLE     0x4000
.................... #define RTC_CHIME_DISABLE    0
.................... // Constants used in setup_rtc_alarm() second param are:  // Third param is repeat#
.................... #define RTC_ALARM_HALFSECOND 0x0000
.................... #define RTC_ALARM_SECOND     0x0400
.................... #define RTC_ALARM_10_SECONDS 0x0800
.................... #define RTC_ALARM_MINUTE     0x0C00
.................... #define RTC_ALARM_10_MINUTES 0x1000
.................... #define RTC_ALARM_HOUR       0x1400
.................... #define RTC_ALARM_DAY        0x1800
.................... #define RTC_ALARM_WEEK       0x1C00
.................... #define RTC_ALARM_MONTH      0x2000
.................... #define RTC_ALARM_YEAR       0x2400
.................... 
.................... ////////////////////////////////////////////////////////////////// QEI
.................... // QEI Functions: setup_qei(), qei_set_count(), qei_get_count(),
.................... //                qei_status()
.................... // QEI Prototypes:
.................... _bif void setup_qei(unsigned int16 mode, unsigned int16 filter, unsigned int16 maxcount);
.................... _bif void setup_qei(unsigned int8 unit, unsigned int16 mode, unsigned int16 filter, unsigned int16 maxcount);
.................... _bif void qei_set_count(unsigned int16 count);
.................... _bif void qei_set_count(unsigned int8 unit, unsigned int16 count);
.................... _bif unsigned int16 qei_get_count(void);
.................... _bif unsigned int16 qei_get_count(unsigned int8 unit);
.................... _bif unsigned int16 qei_status(void);
.................... _bif unsigned int16 qei_status(unsigned int8 unit);
.................... // Constants used in setup_qei() first param are:
.................... #define QEI_DISABLED        0
.................... #define QEI_MODE_X2         0x0400
.................... #define QEI_MODE_X4         0x0600
.................... #define QEI_MODE_TIMER      0x0100
.................... #define QEI_STOP_WHEN_IDLE  0x2000
.................... #define QEI_SWAP_AB         0x0080
.................... #define QEI_OUTPUT_ENABLE   0x0040
.................... #define QEI_RESET_WHEN_MAXCOUNT  0x0100
.................... #define QEI_RESET_WHEN_IDX_PULSE 0x0004
.................... #define QEI_TIMER_GATED      0x0020
.................... #define QEI_TIMER_INTERNAL   0x0000
.................... #define QEI_TIMER_EXTERNAL   0x0002
.................... #define QEI_TIMER_DIV_BY_1   0x0000
.................... #define QEI_TIMER_DIV_BY_8   0x0008
.................... #define QEI_TIMER_DIV_BY_64  0x0010
.................... #define QEI_TIMER_DIV_BY_256 0x0018
.................... // Constants used in setup_qei() second param are:   // Third param is MAXCOUNT
.................... #define QEI_FILTER_DIV_1     0x0000
.................... #define QEI_FILTER_DIV_2     0x0010
.................... #define QEI_FILTER_DIV_4     0x0020
.................... #define QEI_FILTER_DIV_16    0x0030
.................... #define QEI_FILTER_DIV_32    0x0040
.................... #define QEI_FILTER_DIV_64    0x0050
.................... #define QEI_FILTER_DIV_128   0x0060
.................... #define QEI_FILTER_DIV_256   0x0070
.................... #define QEI_FILTER_OUTPUT    0x0080
.................... #define QEI_NO_ERROR_INTS    0x0100
.................... #define QEI_IDX_WHEN_A0      0x0000  // for 2X mode
.................... #define QEI_IDX_WHEN_A1      0x0200  // for 2X mode
.................... #define QEI_IDX_WHEN_B0      0x0400  // for 2X mode
.................... #define QEI_IDX_WHEN_B1      0x0600  // for 2X mode
.................... #define QEI_IDX_WHEN_A0_B0   0x0000  // for 4X mode
.................... #define QEI_IDX_WHEN_A1_B0   0x0200  // for 4X mode
.................... #define QEI_IDX_WHEN_A0_B1   0x0400  // for 4X mode
.................... #define QEI_IDX_WHEN_A1_B1   0x0600  // for 4X mode
.................... // Constants returned from qei_status() are:
.................... #define QEI_POS_ERROR        0x8000
.................... #define QEI_FORWARD          0x0800
.................... #define QEI_INDEX_PIN        0x1000
.................... 
.................... ////////////////////////////////////////////////////////////////// MOTOR PWM
.................... // MPWM Functions: setup_motor_pwm(), set_motor_unit(),
.................... //                 set_motor_pwm_duty(), set_motor_pwm_event(),
.................... //                 get_motor_pwm_count()
.................... // MPWM Prototypes:
.................... _bif void setup_motor_pwm(unsigned int8 pwm, unsigned int32 mode, unsigned int32 timebase);
.................... _bif void setup_motor_pwm(unsigned int8 pwm, unsigned int32 mode, unsigned int8 prescale, unsigned int8 postscale, unsigned int16 period);
.................... _bif void set_motor_unit(unsigned int8 pwm, unsigned int8 pin_pair, unsigned int16 mode, unsigned int8 active_deadtime, unsigned int8 inactive_deadtime);
.................... _bif void set_motor_pwm_duty(unsigned int8 pwm, unsigned int8 pin_pair, unsigned int16 duty);
.................... _bif void set_motor_pmw_event(unsigned int8, signed int16 time);
.................... _bif unsigned int16 get_motor_pwm_count(unsigned int8 pwm);
.................... // Constants used in setup_motor_pwm() second param are (first param is unit number 1,2...):
.................... #define MPWM_DISABLED          0
.................... #define MPWM_FREE_RUN          0x8000
.................... #define MPWM_SINGLE_PULSE      0x8001
.................... #define MPWM_UP_DOWN           0x8002
.................... #define MPWM_UP_DOWN_WITH_INTS 0x8003
.................... // OR in any of the following:
.................... #define MPWM_HALT_WHEN_IDLE            0x2000
.................... #define MPWM_DUTY_UPDATES_IMMEADIATE  0x40000
.................... #define MPWM_SYNC_OVERRIDES           0x20000
.................... #define MPWM_DISABLE_UPDATES          0x10000
.................... #define MPWM_LATCH_FAULTS            0x100000
.................... 
.................... // Constants used in set_motor_unit() third param are:  (first param is unit number 1,2... and second param is pwm pin pair 1,2,3 or 4)
.................... #define MPWM_INDEPENDENT     0x0001
.................... #define MPWM_ENABLE          0x0006  // both H and L
.................... #define MPWM_ENABLE_H        0x0004
.................... #define MPWM_ENABLE_L        0x0002
.................... 
.................... #define MPWM_FORCE_L_0       0x0010
.................... #define MPWM_FORCE_L_1       0x0050
.................... #define MPWM_FORCE_H_0       0x0020
.................... #define MPWM_FORCE_H_1       0x00A0
.................... 
.................... #define MPWM_FAULTA_LA_HA     0x0700
.................... #define MPWM_FAULTA_LA_HI     0x0500
.................... #define MPWM_FAULTA_LI_HA     0x0600
.................... #define MPWM_FAULTA_LI_HI     0x0400
.................... #define MPWM_FAULTB_LA_HA     0x7000
.................... #define MPWM_FAULTB_LA_HI     0x5000
.................... #define MPWM_FAULTB_LI_HA     0x6000
.................... #define MPWM_FAULTB_LI_HI     0x4000
.................... #define MPWM_FAULT_NO_CHANGE 0x0000
.................... 
.................... ////////////////////////////////////////////////////////////////// DCI
.................... // DCI Functions: setup_dci(), dci_start(), dci_read(), dci_write(),
.................... //                dci_data_received(), dci_transmit_ready()
.................... // DCI Prototypes:
.................... _bif void setup_dci(unsigned int16 mode, unsigned int16 size, unsigned int16 receive_slot, unsigned int16 transmit_slot, unsigned int16 sample_rate);
.................... _bif void dci_start(void);
.................... _bif signed int16 dci_read(void);
.................... _bif void dci_write(signed int16);
.................... _bif int1 dci_data_received(void);
.................... _bif int1 dci_transmit_ready(void);
.................... // Constants used in setup_dci() first param are:
.................... #define MULTICHANNEL_MODE  0x0000
.................... #define I2S_MODE           0x0001
.................... #define AC97_16BIT_MODE    0x0002
.................... #define AC97_20BIT_MODE    0x0003
.................... 
.................... #define JUSTIFY_DATA       0x0020 //Start data transmission on the same clock cycle as COFS pulses (multichannel)
.................... #define MULTI_DEVICE_BUS   0x0040 //Tri-states the CSDO pin during unused time slots, normally drives '0'
.................... 
.................... #define UNDERFLOW_LAST     0x0080 //Transmits the last written value to the dci when data underflow occurs. Default is undeflow silence.
.................... #define UNDERFLOW_SILENCE  0x0000 //Transmit '0's on data undeflow. This will cause a clicking noise if you are underflowing data while outputing to a codec.
.................... 
.................... #define DCI_SLAVE          0x0100 //Default is master
.................... #define DCI_MASTER         0x0000
.................... 
.................... #define SAMPLE_FALLING_EDGE 0x0000 //Default is Sample on the rising edge of the clock
.................... #define SAMPLE_RISING_EDGE 0x0200
.................... 
.................... #define DCI_CLOCK_INPUT    0x0400 //SCLK is an input (supplied by codec or external source)
.................... #define DCI_CLOCK_OUTPUT   0x0000 //Default is clock output
.................... 
.................... #define ENABLE_LOOPBACK    0x0800 //Connect the CSDI/CSDO internally; loops all of the sound back onto the bus
.................... 
.................... #define CODEC_MULTICHANNEL  0x0000  //enables multichannel (generic) codec support
.................... #define CODEC_I2S           0x0001  //enables the I2S protocol
.................... #define CODEC_AC16          0x0002  //enables the AC-16 protocol, setupCodecTransmission has no effect
.................... #define CODEC_AC20          0x0003  //enables the AC-20 protocol, setupCodecTransmission has no effect
.................... 
.................... #define BUS_MASTER          0x0000  //designates this device as the bus master
.................... #define BUS_SLAVE           0x0300  //designates this device as a slave on a bus controlled by another codec
.................... 
.................... #define TRISTATE_BUS        0x0040        //when in master mode, the module will be in high impedance
....................                                     //during disabled frames (default drives 0's onto bus)
.................... #define SYNC_COFS_DATA_PULSE 0x0020 //signifies that data starts transmitting on the same SCK pulse as the edge of the COFS pulse
....................                                     //(default data starts on the clock after the rising edge of COFS
.................... /* Determines when a sample is taken */
.................... #define SAMPLE_RISING        0x0200 //sample data on the rising edge of the clock
.................... #define SAMPLE_FALLING       0x0000 //sample data on the falling edge of the clock
.................... 
.................... // Constants used in setup_dci() second param are:
.................... #define DCI_4BIT_WORD      0x0003
.................... #define DCI_5BIT_WORD      0x0004
.................... #define DCI_6BIT_WORD      0x0005
.................... #define DCI_7BIT_WORD      0x0006
.................... #define DCI_8BIT_WORD      0x0007
.................... #define DCI_9BIT_WORD      0x0008
.................... #define DCI_10BIT_WORD     0x0009
.................... #define DCI_11BIT_WORD     0x000A
.................... #define DCI_12BIT_WORD     0x000B
.................... #define DCI_13BIT_WORD     0x000C
.................... #define DCI_14BIT_WORD     0x000D
.................... #define DCI_15BIT_WORD     0x000E
.................... #define DCI_16BIT_WORD     0x000F
.................... 
.................... #define DCI_1WORD_FRAME    0x0000
.................... #define DCI_2WORD_FRAME    0x0010 << 1
.................... #define DCI_3WORD_FRAME    0x0020 << 1
.................... #define DCI_4WORD_FRAME    0x0030 << 1
.................... #define DCI_5WORD_FRAME    0x0040 << 1
.................... #define DCI_6WORD_FRAME    0x0050 << 1
.................... #define DCI_7WORD_FRAME    0x0060 << 1
.................... #define DCI_8WORD_FRAME    0x0070 << 1
.................... #define DCI_9WORD_FRAME    0x0080 << 1
.................... #define DCI_10WORD_FRAME   0x0090 << 1
.................... #define DCI_11WORD_FRAME   0x00A0 << 1
.................... #define DCI_12WORD_FRAME   0x00B0 << 1
.................... #define DCI_13WORD_FRAME   0x00C0 << 1
.................... #define DCI_14WORD_FRAME   0x00D0 << 1
.................... #define DCI_15WORD_FRAME   0x00E0 << 1
.................... #define DCI_16WORD_FRAME   0x00F0 << 1
.................... 
.................... #define DCI_1WORD_INTERRUPT 0x0000
.................... #define DCI_2WORD_INTERRUPT 0x0400
.................... #define DCI_3WORD_INTERRUPT 0x0800
.................... #define DCI_4WORD_INTERRUPT 0x0C00
.................... 
.................... // Constants used in setup_dci() third param are:
.................... #define RECEIVE_NONE    0x0000
.................... #define RECEIVE_ALL     0xFFFF
.................... #define RECEIVE_SLOT0   0x0001
.................... #define RECEIVE_SLOT1   0x0002
.................... #define RECEIVE_SLOT2   0x0004
.................... #define RECEIVE_SLOT3   0x0008
.................... #define RECEIVE_SLOT4   0x0010
.................... #define RECEIVE_SLOT5   0x0020
.................... #define RECEIVE_SLOT6   0x0040
.................... #define RECEIVE_SLOT7   0x0080
.................... #define RECEIVE_SLOT8   0x0100
.................... #define RECEIVE_SLOT9   0x0200
.................... #define RECEIVE_SLOT10  0x0400
.................... #define RECEIVE_SLOT11  0x0800
.................... #define RECEIVE_SLOT12  0x1000
.................... #define RECEIVE_SLOT13  0x2000
.................... #define RECEIVE_SLOT14  0x4000
.................... #define RECEIVE_SLOT15  0x8000
.................... 
.................... // Constants used in setup_dci() forth param are:
.................... #define TRANSMIT_NONE   0x0000
.................... #define TRANSMIT_ALL    0xFFFF
.................... #define TRANSMIT_SLOT0  0x0001
.................... #define TRANSMIT_SLOT1  0x0002
.................... #define TRANSMIT_SLOT2  0x0004
.................... #define TRANSMIT_SLOT3  0x0008
.................... #define TRANSMIT_SLOT4  0x0010
.................... #define TRANSMIT_SLOT5  0x0020
.................... #define TRANSMIT_SLOT6  0x0040
.................... #define TRANSMIT_SLOT7  0x0080
.................... #define TRANSMIT_SLOT8  0x0100
.................... #define TRANSMIT_SLOT9  0x0200
.................... #define TRANSMIT_SLOT10 0x0400
.................... #define TRANSMIT_SLOT11 0x0800
.................... #define TRANSMIT_SLOT12 0x1000
.................... #define TRANSMIT_SLOT13 0x2000
.................... #define TRANSMIT_SLOT14 0x4000
.................... #define TRANSMIT_SLOT15 0x8000
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////// DMA
.................... // DMA Functions: setup_dma(), dma_start(), dma_status()
.................... // DMA Prototypes:
.................... _bif void setup_dma(unsigned int8 channel, unsigned int32 pheripheral, unsigned int8 mode);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 count);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 addressb);
.................... _bif void dma_start(unsigned int8 channel, unsigned int16 mode, unsigned int16 addressa, unsigned int16 addressb, unsigned int16 count);
.................... _bif unsigned int8 dma_status(unsigned int8 channel);
.................... // Constants used in setup_dma() second param are:
.................... #define DMA_IN_SPI1      (0x0A0000|getenv("sfr:SPI1BUF"))
.................... #define DMA_OUT_SPI1     (0x8A0000|getenv("sfr:SPI1BUF"))
.................... #define DMA_IN_SPI2      (0x210000|getenv("sfr:SPI2BUF"))
.................... #define DMA_OUT_SPI2     (0xA10000|getenv("sfr:SPI2BUF"))
.................... #define DMA_IN_UART1     (0x0B0000|getenv("sfr:U1RXREG"))
.................... #define DMA_OUT_UART1    (0x8C0000|getenv("sfr:U1TXREG"))
.................... #define DMA_IN_UART2     (0x1E0000|getenv("sfr:U2RXREG"))
.................... #define DMA_OUT_UART2    (0x9F0000|getenv("sfr:U2TXREG"))
.................... #define DMA_IN_ADC1      (0x0D0000|getenv("sfr:ADC1BUF0"))
.................... ////////////////////////////////////////////////////////////////// DAC
.................... // Digital to Analog Functions: SETUP_DAC(), DAC_WRITE()
.................... // DAC Prototypes:
.................... _bif void setup_dac(unsigned int32 mode);
.................... _bif void setup_dac(unsigned int32 mode, unsigned int8 divisor);
.................... _bif void dac_write(unsigned int8 channel, unsigned value);
.................... // Constants used in SETUP_DAC() are:
.................... #define DAC_OFF  0
.................... #define DAC_RIGHT_ON   0x00808000
.................... #define DAC_LEFT_ON    0x80008000
.................... #define DAC_RIGHT_MIDPOINT 0x00A08000
.................... #define DAC_LEFT_MIDPOINT  0xA0008000
.................... #define DAC_SIGNED   0x100
.................... #define DAC_SLEEP_ON 0x1000
.................... #define DAC_IDLE_OFF 0x2000
.................... // Constants used as the first param in DAC_WRITE() are:
.................... #define DAC_DEFAULT  0
.................... #define DAC_RIGHT    1
.................... #define DAC_LEFT     2
.................... 
.................... #define DMA_IN_ECAN1     (0x220000|getenv("sfr:C1RXD"))
.................... #define DMA_OUT_ECAN1    (0xC60000|getenv("sfr:C1TXD"))
.................... #define DMA_INT0         0x000000 // or in direction and perif address
.................... #define DMA_IC1          0x010000 // or in direction and perif address
.................... #define DMA_IN_IC1       (0x010000|getenv("sfr:IC1BUF"))
.................... #define DMA_IC2          0x050000 // or in direction and perif address
.................... #define DMA_IN_IC2       (0x050000|getenv("sfr:IC2BUF"))
.................... #define DMA_OC1          0x020000 // or in direction and perif address
.................... #define DMA_OC2          0x060000 // or in direction and perif address
.................... #define DMA_TIMER2       0x070000 // or in direction and perif address
.................... #define DMA_TIMER3       0x080000 // or in direction and perif address
.................... #define DMA_OUT_DCI      (0xBC0000|getenv("sfr:TXBUF0"))
.................... #define DMA_IN_DCI       (0x3C0000|getenv("sfr:RXBUF0"))
.................... #define DMA_OUT_DACR     (0xCE0000|getenv("sfr:DAC1RDAT"))
.................... #define DMA_OUT_DACL     (0xCF0000|getenv("sfr:DAC1LDAT"))
.................... #define DMA_IN          0x00
.................... #define DMA_OUT         0x800000
.................... // Constants used in setup_dma() third param are:
.................... #define DMA_BYTE        0x40
.................... #define DMA_WORD        0x00  // default
.................... #define DMA_HALF_INT    0x10  // interrupt when half full
.................... #define DMA_WRITE_NULL  0x08
.................... // Constants used in dma_start() second param are:
.................... #define DMA_CONTINOUS   0x00
.................... #define DMA_ONE_SHOT    0x01
.................... #define DMA_PING_PONG   0x02
.................... #define DMA_NO_INC      0x10
.................... #define DMA_PERIF_ADDR  0x20 // Device supplies address
.................... #define DMA_FORCE_NOW  0x100
.................... // Constants returned from dma_status() are:
.................... #define DMA_IN_ERROR    0x01
.................... #define DMA_OUT_ERROR   0x02
.................... #define DMA_B_SELECT    0x04
.................... 
.................... ////////////////////////////////////////////////////////////////// BIF
.................... // Built In Functions Prototypes
.................... //
.................... // Math Prototypes:
.................... _bif signed int8 abs(signed int8 x);
.................... _bif signed int16 abs(signed int16 x);
.................... _bif signed int32 abs(signed int32 x);
.................... _bif float32 abs(float32 x);
.................... _bif unsigned int16 _mul(unsigned int8, unsigned int8);
.................... _bif signed int16 _mul(signed int8, signed int8);
.................... _bif unsigned int32 _mul(unsigned int16, unsigned int16);
.................... _bif signed int32 _mul(signed int16, signed int16);
.................... _bif signed int48 abs(signed int48 x);
.................... _bif signed int64 abs(signed int64 x);
.................... _bif float48 abs(float48 x);
.................... _bif float64 abs(float64 x);
.................... _bif unsigned int64 _mul(unsigned int32, unsigned int32);
.................... _bif signed int64 _mul(signed int32, signed int32);
.................... _bif unsigned int64 _mul(unsigned int48, unsigned int48);
.................... _bif signed int64 _mul(signed int48, signed int48);
.................... 
.................... // Memory Manipulation Prototypes:
.................... _bif void strcpy(char* dest, char* src);
.................... _bif void memset(unsigned int8* destination, unsigned int8 value, unsigned int16 num);
.................... _bif void memcpy(unsigned int8* destination, unsigned int8* source, unsigned int16 num);
.................... 
.................... // Data Manipulators Prototypes:
.................... _bif int1 shift_left(unsigned int8* address, unsigned int8 bytes, int1 value);
.................... _bif int1 shift_right(unsigned int8* address, unsigned int8 bytes, int1 value);
.................... _bif void rotate_left(unsigned int8* address, unsigned int8 bytes);
.................... _bif void rotate_right(unsigned int8* address, unsigned int8 bytes);
.................... _bif void swap(unsigned int8 value);
.................... _bif unsigned int8 make8(unsigned int16 var, unsigned int8 offset);
.................... _bif unsigned int8 make8(unsigned int32 var, unsigned int8 offset);
.................... _bif unsigned int16 make16(unsigned int8 varhigh, unsigned int8 varlow);
.................... _bif unsigned int32 make32(unsigned int16 var1);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int16 var2);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int8 var2);
.................... _bif unsigned int32 make32(unsigned int16 var1, unsigned int8 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int8 var3, unsigned int8 var4);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int16 var2);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int16 var2, unsigned int8 var3);
.................... _bif unsigned int32 make32(unsigned int8 var1, unsigned int8 var2, unsigned int16 var3);
.................... _bif void bit_set(unsigned int8 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int16 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int32 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int8 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int16 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int32 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int8 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int16 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int32 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int48 var, unsigned int8 bit);
.................... _bif void bit_set(unsigned int64 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int48 var, unsigned int8 bit);
.................... _bif void bit_clear(unsigned int64 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int48 var, unsigned int8 bit);
.................... _bif int1 bit_test(unsigned int64 var, unsigned int8 bit);
.................... _bif unsigned int8 bit_first(int1 value, unsigned int16 var);
.................... _bif unsigned int8 bit_last(int16 var);
.................... _bif unsigned int8 bit_last(int1 value, int16 var);
.................... 
.................... // #use delay() Prototypes:
.................... _bif void delay_cycles(unsigned int16 count);
.................... _bif void delay_ms(unsigned int16 time);
.................... _bif void delay_us(unsigned int16 time);
.................... 
.................... // #use rs232() Prototypes:
.................... _bif void putchar(char cdata);
.................... _bif void putchar(char cdata, unsigned int8 stream);
.................... _bif void puts(char* string);
.................... _bif void puts(char* string, unsigned int8 stream);
.................... _bif char getch(void);
.................... _bif char getch(unsigned int8 stream);
.................... _bif void gets(char* string);
.................... _bif void gets(char* string, unsigned int8 stream);
.................... _bif int1 kbhit(void);
.................... _bif int1 kbhit(unsigned int8 stream);
.................... _bif void printf(char* string, ...);
.................... _bif void fprintf(unsigned int8 stream, char* string, ...);
.................... _bif void putc_send(void);
.................... _bif void fputc_send(unsigned int8 stream);
.................... _bif int1 rcv_buffer_full(void);
.................... _bif int1 rcv_buffer_full(unsigned int8 stream);
.................... _bif unsigned int16 rcv_buffer_bytes(void);
.................... _bif unsigned int16 rcv_buffer_bytes(unsigned int8 stream);
.................... _bif int1 tx_buffer_full(void);
.................... _bif int1 tx_buffer_full(unsigned int8 stream);
.................... _bif unsigned int16 tx_buffer_bytes(void);
.................... _bif unsigned int16 tx_buffer_bytes(unsigned int8 stream);
.................... 
.................... // #use i2c() Prototypes:
.................... _bif unsigned int8 i2c_read(void);
.................... _bif unsigned int8 i2c_read(unsigned int8 stream);
.................... _bif unsigned int8 i2c_read(unsigned int8 stream, int1 ack);
.................... _bif int1 i2c_write(unsigned int8 data);
.................... _bif int1 i2c_write(unsigned int8 stream, unsigned int8 data);
.................... _bif void i2c_start(void);
.................... _bif void i2c_start(unsigned int8 stream);
.................... _bif void i2c_start(unsigned int8 stream, unsigned int8 restart);
.................... _bif void i2c_stop(void);
.................... _bif void i2c_stop(unsigned int8 stream);
.................... _bif int8 i2c_isr_state(void);
.................... _bif void i2c_slaveaddr(unsigned int8 addr);
.................... _bif void i2c_slaveaddr(unsigned int8 stream, unsigned int8 addr);
.................... _bif int1 i2c_poll(void);
.................... _bif int1 i2c_poll(unsigned int8 stream);
.................... _bif void i2c_init(unsigned int32 baud);
.................... _bif void i2c_init(unsigned int8 stream, unsigned int32 baud);
.................... 
.................... // #use spi() Prototypes:
.................... _bif unsigned int8 spi_xfer(void);
.................... _bif unsigned int16 spi_xfer(void);
.................... _bif unsigned int32 spi_xfer(void);
.................... _bif unsigned int8 spi_xfer(unsigned int8 data);
.................... _bif unsigned int16 spi_xfer(unsigned int16 data);
.................... _bif unsigned int32 spi_xfer(unsigned int32 data);
.................... _bif unsigned int8 spi_xfer(unsigned int8 stream, unsigned int8 data);
.................... _bif unsigned int16 spi_xfer(unsigned int8 stream, unsigned int16 data);
.................... _bif unsigned int32 spi_xfer(unsigned int8 stream, unsigned int32 data);
.................... _bif unsigned int8 spi_xfer(unsigned int8 stream, unsigned int8 data, unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer(unsigned int8 stream, unsigned int16 data, unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer(unsigned int8 stream, unsigned int32 data, unsigned int8 bits);
.................... _bif void spi_init(unsigned int32 baud);
.................... _bif void spi_init(unsigned int8 stream, unsigned int32 baud);
.................... _bif void spi_speed(unsigned int32 baud);
.................... _bif void spi_speed(unsigned int8 stream, unsigned int32 baud);
.................... _bif void spi_speed(unsigned int8 stream, unsigned int32 baud, unsigned int32 clock);
.................... _bif void spi_prewrite(unsigned int8 data);
.................... _bif void spi_prewrite(unsigned int16 data);
.................... _bif void spi_prewrite(unsigned int32 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int8 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int16 data);
.................... _bif void spi_prewrite(unsigned int8, unsigned int32 data);
.................... _bif unsigned int8 spi_xfer_in(void);
.................... _bif unsigned int16 spi_xfer_in(void);
.................... _bif unsigned int32 spi_xfer_in(void);
.................... _bif unsigned int8 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer_in(unsigned int8 bits);
.................... _bif unsigned int8 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... _bif unsigned int16 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... _bif unsigned int32 spi_xfer_in(unsigned int8 stream, unsigned int8 bits);
.................... 
.................... // #use rtos() Prototypes:
.................... _bif void rtos_run(void);
.................... _bif void rtos_yield(void);
.................... _bif void rtos_enable(unsigned int8 task);
.................... _bif void rtos_disable(unsigned int8 task);
.................... _bif void rtos_terminate(void);
.................... _bif void rtos_await(int1 flag);
.................... _bif void rtos_wait(unsigned int8 sem);
.................... _bif void rtos_signal(unsigned int8 sem);
.................... _bif void rtos_msg_send(unsigned int8 task, unsigned int8 msg);
.................... _bif unsigned int8 rtos_msg_read(void);
.................... _bif unsigned int8 rtos_msg_poll(void);
.................... _bif int1 rtos_overrun(unsigned int8 task);
.................... _bif void rtos_stats(unsigned int8 task, unsigned int8* stat);
.................... 
.................... // #use timer() Prototypes:
.................... _bif unsigned int8 get_ticks(void);
.................... _bif unsigned int16 get_ticks(void);
.................... _bif unsigned int32 get_ticks(void);
.................... _bif unsigned int64 get_ticks(void);
.................... _bif unsigned int8 get_ticks(unsigned int8 stream);
.................... _bif unsigned int16 get_ticks(unsigned int8 stream);
.................... _bif unsigned int32 get_ticks(unsigned int8 stream);
.................... _bif unsigned int64 get_ticks(unsigned int8 stream);
.................... _bif void set_ticks(unsigned int8 value);
.................... _bif void set_ticks(unsigned int16 value);
.................... _bif void set_ticks(unsigned int32 value);
.................... _bif void set_ticks(unsigned int64 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int8 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int16 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int32 value);
.................... _bif void set_ticks(unsigned int8 stream, unsigned int64 value);
.................... 
.................... // #use pwm() Prototypes:
.................... _bif void pwm_on(void);
.................... _bif void pwm_on(unsigned int8 stream);
.................... _bif void pwm_off(void);
.................... _bif void pwm_off(unsigned int8 stream);
.................... _bif void pwm_set_duty(unsigned int16 duty);
.................... _bif void pwm_set_duty(unsigned int8 stream, unsigned int16 duty);
.................... _bif void pwm_set_duty_percent(unsigned int16 percent);
.................... _bif void pwm_set_duty_percent(unsigned int8 stream, unsigned int16 percent);
.................... _bif void pwm_set_frequency(unsigned int32 frequency);
.................... _bif void pwm_set_frequency(unsigned int8 stream, unsigned int32 frequency);
.................... 
.................... // #use capture() Prototypes:
.................... _bif unsigned int16 get_capture_time(void);
.................... _bif unsigned int16 get_capture_time(unsigned int8 stream);
.................... _bif int1 get_capture_event(void);
.................... _bif int1 get_capture_event(unsigned int8 stream);
.................... 
.................... // Environment Prototypes:
.................... //_bif unsigned int8 getenv(char* cstring);
.................... 
.................... // Address Prototypes:
.................... #ifndef __ADDRESS__
.................... #define __ADDRESS__ unsigned int32
.................... #endif
.................... _bif void goto_address(__ADDRESS__ address);
.................... _bif __ADDRESS__ label_address(__ADDRESS__ label);
.................... 
.................... // Program Memory Prototypes:
.................... _bif void read_program_memory(__ADDRESS__ address, unsigned int8* dataptr, unsigned int16 count);
.................... _bif void erase_program_memory(__ADDRESS__ address);
.................... _bif void write_program_memory(__ADDRESS__ address, unsigned int8* dataptr, unsigned int16 count);
.................... _bif void read_configuration_memory(unsigned int8* dataptr, unsigned int8 count);
.................... _bif void write_configuration_memory(unsigned int8* dataptr, unsigned int8 count);
.................... 
.................... ////////////////////////////////////////////////////////////////// INT
.................... // Interrupt Functions: ENABLE_INTERRUPTS(), DISABLE_INTERRUPTS(),
.................... //                      CLEAR_INTERRUPT(), INTERRUPT_ACTIVE(),
.................... //                      EXT_INT_EDGE()
.................... // INT Prototypes:
.................... _bif void enable_interrupts(unsigned int16 interrupt);
.................... _bif void disable_interrupts(unsigned int16 interrupt);
.................... _bif void clear_interrupt(unsigned int16 interrupt);
.................... _bif int1 interrupt_active(unsigned int16 interrupt);
.................... _bif int1 interrupt_enabled(unsigned int16 interrupt);
.................... _bif void ext_int_edge(unsigned int8 source, unsigned int8 edge);
.................... _bif void jump_to_isr(unsigned int16 address);
.................... // Constants used in EXT_INT_EDGE() are:
.................... #define L_TO_H              0x40
.................... #define H_TO_L                 0
.................... //
.................... // Constants used in other interrupt functions are:
.................... #define INTR_GLOBAL               0x400
.................... #define GLOBAL                    0x400  // For compatibility with PIC16/18
.................... #define INTR_NORMAL               0x100
.................... #define INTR_ALTERNATE            0x200
.................... #define INTR_LEVEL0               0x500
.................... #define INTR_LEVEL1               0x501
.................... #define INTR_LEVEL2               0x502
.................... #define INTR_LEVEL3               0x503
.................... #define INTR_LEVEL4               0x504
.................... #define INTR_LEVEL5               0x505
.................... #define INTR_LEVEL6               0x506
.................... #define INTR_LEVEL7               0x507
.................... 
.................... #define INTR_CN_PIN              0x8000  // or in a PIN_xx constant
.................... 
.................... #define INT_OSCFAIL               1
.................... #define INT_ADDRERR               2
.................... #define INT_STACKERR              3
.................... #define INT_MATHERR               4
.................... #define INT_DMAERR                5
.................... #define INT_EXT0                  6
.................... #define INT_IC1                   7
.................... #define INT_OC1                   8
.................... #define INT_TIMER1                9
.................... #define INT_DMA0                  69
.................... #define INT_IC2                   70
.................... #define INT_OC2                   71
.................... #define INT_TIMER2                72
.................... #define INT_TIMER3                73
.................... #define INT_SPI1E                 74
.................... #define INT_SPI1                  75
.................... #define INT_RDA                   76
.................... #define INT_TBE                   77
.................... #define INT_ADC1                  78
.................... #define INT_DMA1                  79
.................... #define INT_SI2C                  81
.................... #define INT_MI2C                  82
.................... #define INT_CNI                   84
.................... #define INT_EXT1                  85
.................... #define INT_IC7                   87
.................... #define INT_IC8                   88
.................... #define INT_DMA2                  89
.................... #define INT_OC3                   90
.................... #define INT_OC4                   91
.................... #define INT_TIMER4                92
.................... #define INT_TIMER5                93
.................... #define INT_EXT2                  94
.................... #define INT_RDA2                  95
.................... #define INT_TBE2                  96
.................... #define INT_SPI2E                 97
.................... #define INT_SPI2                  98
.................... #define INT_C1RX                  99
.................... #define INT_CAN1                  100
.................... #define INT_DMA3                  101
.................... #define INT_PWM1                  110
.................... #define INT_DMA4                  111
.................... #define INT_QEI                   123
.................... #define INT_DMA5                  126
.................... #define INT_PWM2                  127
.................... #define INT_FAULTA                128
.................... #define INT_UART1E                130
.................... #define INT_UART2E                131
.................... #define INT_QEI2                  132
.................... #define INT_DMA6                  133
.................... #define INT_DMA7                  134
.................... #define INT_C1TX                  135
.................... #define INT_FAULTA2               139
.................... #define INT_COMP                  152
.................... #define INT_PMP                   164
.................... #define INT_RTC                   173
.................... #define INT_CRC                   174
.................... #define INT_DAC1R                 177
.................... #define INT_DAC1L                 178
.................... 
.................... #list
.................... 
.................... #endif
.................... 
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... #include "algoritmo.h"
.................... /**
....................  @file    ALGORITMO.h
....................  @author  Ricardo Gomez, Klaudija Ziliute
....................  @brief   PanTompkins header file
.................... */
.................... 
.................... 
.................... #ifndef __ALGORITMO_H
.................... #define __ALGORITMO_H
.................... 
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "adc.h"
.................... /**
....................  @file    adc.h
....................  @author  Ricardo Gomez
....................  @brief   adc init and ISR
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __ADC_H
.................... #define __ADC_H
.................... 
.................... #include "common.h"
.................... 
.................... #WORD ADC1BUF0 = 0x0300;
.................... #WORD ADC1CON1 = 0x0320;
.................... #WORD ADC1CON2 = 0x0322;
.................... #WORD ADC1CON3 = 0x0324;
.................... #WORD AD1CHS0 = 0x0328;
.................... #WORD AD1PCFGL = 0x032C;
.................... #WORD IFS0 = 0x0084;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void adcinit(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ADC_H
.................... 
.................... #include "BEEP.h"
.................... /**
....................  @file    BEEP.h
....................  @author  Julio Gomis-Tena
....................  @brief   Generate n "beeps" of variable frequency
.................... */
.................... // Do not write above this line (except comments)!
.................... 
.................... #ifndef __BEEP_H
.................... #define __BEEP_H
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #pin_select OC2 = BUZZER
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP_Init(void); //Inicializa las frecuencias de los beeps y la separaciÃ³n entre ellos
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void BEEP(unsigned int8); //Realiza n beeps
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __BEEP_H
.................... 
.................... 
.................... 
.................... int algoritmo(void);
.................... void init_algoritmo(void);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __ALGORITMO_H
.................... 
.................... #include "SD_Card.h"
.................... /**
....................  @file    SD_CARD.h
....................  @author  Ricardo Gomez, Klaudija Ziliute
....................  @brief   PanTompkins header file
.................... */
.................... 
.................... 
.................... #ifndef __SD_CARD_H
.................... #define __SD_CARD_H
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #include "common.h"
.................... #ifndef COMMON_h
.................... #define COMMON_h
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #include "33FJ128MC804.h"
.................... #include "adc.h"
.................... #include "lcd.h"
.................... #include "Header.h"
.................... #include "algoritmo.h"
.................... #include "SD_Card.h"
.................... #include "BLUETOOTH.h"
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... #include "miFAT.h"
.................... 
.................... #ifndef __MIFAT_H
.................... #define __MIFAT_H
.................... // Definidos en sdcard.h - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... extern unsigned int8 dt[512];
.................... extern unsigned int32 LBA0;
.................... extern unsigned int8 sd_init();
.................... extern unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr);
.................... extern unsigned int8 sd_read_block( unsigned int32 address, unsigned char* ptr);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define MAX_ENTRIES_SECTOR_FAT16        256
.................... #define ENDFILE16                    0xFFFF
.................... #define MAX_ENTRIES_SECTOR_FAT32        128
.................... #define ENDFILE32                0x0FFFFFFF
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... typedef struct{
.................... 	union{
.................... 		unsigned int8 raw[32];
.................... 		struct fields{
.................... 			char name[8];
.................... 			char extension[3];
.................... 			unsigned int8 attrib;			///sï¿½lo lectura, oculto, de sistema, directorio...
.................... 			//unsigned int8 reserved[10];
.................... 			  unsigned int8  reserved;
.................... 	 		  unsigned int8  createTimeMs;
.................... 			  unsigned int16 create_hour;
.................... 			  unsigned int16 create_date;
.................... 			  unsigned int16 last_access;
.................... 			  unsigned int16 eaIndex;
.................... 			  unsigned int16 modif_hour;
.................... 			  unsigned int16 modif_date;
.................... 			  unsigned int16 first_cluster;	///primer cluster (direcciona tabla FAT y sector para escribir contenido)
.................... 			  unsigned int32 size;			///tamaï¿½o en bytes
.................... 		};
.................... 	};
.................... } fileEntry;
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... typedef struct{
.................... 	unsigned int32 currentCluster;
.................... 	unsigned int32 currentSector;
.................... 	unsigned int16 posInSector;      //posiciï¿½n actual al escribir en el sector
.................... 	unsigned int32 sectorAtFAT;      //sector de la 1ï¿½ FAT en el que tenemos el actual puntero de cierre de fichero
.................... 
.................... 	unsigned int32 sectorEntryFile; //direcciï¿½n del sector de entradas de fichero
.................... 	unsigned int8  EntryFile[512];  //sector donde estï¿½ la entrada (root) del fichero (para actualizar tamaï¿½o)
.................... 	unsigned int16 offsetEntry;     //offset en el sector de entradas del fichero
.................... 	unsigned int32 size;            //tamaï¿½o del fichero
.................... }_file;
.................... 
.................... _file file;
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... typedef struct _diskinforec{
....................    unsigned int8  jmpBoot[3];   // bytes  0.. 2: Salto a la rutina de arranque
....................    unsigned int8  OEMName[8];   // bytes  3..10: Es una cadena "MSDOS5.0"
....................    unsigned int16 BytsPerSec;   // bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes)
....................    unsigned int8  SectPerClus;  // byte  13:    Numero de sectores contenidos en 1 cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes
....................    unsigned int16 RsrvdCnt;     // bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente
....................    unsigned int8  NumFATs;      // byte  16:    Numero de tablas FAT en el volumen. Habitualmente es 2
....................    unsigned int16 RootEntCnt;   // bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
....................    unsigned int16 TotSect16;    // bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0)
....................    unsigned int8  Media;        // byte  21:    Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0
....................    unsigned int16 FATsz16;      // bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0)
....................    unsigned int16 SectPerTrack; // bytes 24..25: Sectores por track
....................    unsigned int16 NumHeads;     // bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.)
....................    unsigned int32 HiddSec;      // bytes 28..31: Sectores ocultos que preceden a la particion (irrelevante en uSD)
....................    unsigned int32 TotSect32;    // bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta
....................    unsigned int32 FATsz32;      // bytes 36..39: Numero de sectores ocupados por una FAT
....................    unsigned int16 ExtFlags;     // bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0)
....................    unsigned int16 FSVer;        // bytes 42..43: Version del sistema de archivos (empleamos la 0.0)
....................    unsigned int32 RootClus;     // bytes 44..47: Indica el numero del 1er cluster del directorio raiz.
....................    unsigned int16 FSInfo;       // bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1)
....................    unsigned int16 BkBootSec;    // bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque
....................    unsigned int8  RsrvdSys[12]; // bytes 52..63: Bytes reservados para futuros usos del sistema
....................    unsigned int8  DrvNum;       // byte  64:     Numero de la unidad (para MSDOS pero irrelevante en uSD).
....................    unsigned int8  Reserved1;    // byte  65:     Windows NT para formatear un volumen pone este byte a 0
....................    unsigned int8  BootSig;      // byte  66:     Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows)
....................    unsigned int32 VolId;        // bytes 67..70: Numero de volumen (generado por el reloj del sistema).
....................    unsigned int8  VolLab[11];   // bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME     ". Nosotros podemos poner "NUUBO_SD    "
....................    unsigned int8  FilSysType[8];// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   "
....................    unsigned int8  spam[420];    // bytes 90..509:Zona de codigo (no lo empleamos y esta a 0)
....................    unsigned int16 firma;        // byte 510..511:Debe de vale 55 AA
.................... } diskinforec;
.................... 
.................... diskinforec DiskInfo;
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned  int8 FATType; // FAT16 o FAT32
.................... //variables clave: inicio de la FAT1 y la FAT2 y de las entradas de ficheros
.................... unsigned  int8 sect_x_cluster;
.................... unsigned int16 sect_fat_1;
.................... unsigned int16 sect_fat_2;
.................... unsigned int32 sect_ini_datos;
.................... unsigned int32 sect_x_fat;
.................... unsigned int32 sect_entry;
.................... unsigned int16 sect_reserv;
.................... 
.................... //unsigned int8 dFil[32];
.................... unsigned int32 sector_fat32[MAX_ENTRIES_SECTOR_FAT32]; // 128 x 4 = 512
.................... unsigned int16 sector_fat16[MAX_ENTRIES_SECTOR_FAT16]; // 256 x 2 = 512
.................... 
.................... //atributos
.................... #define __FILE		0x20
.................... #define _DIRECTORY	0x10
.................... #define _VOLUMEN	0x08
.................... #define _SYSTEM		0x04
.................... #define _HIDDEN		0x02
.................... #define READONLY	0x01
.................... 
.................... ///variables globales
.................... unsigned int16 year = 2020;
.................... unsigned int8 yearLo=   20;
.................... unsigned int8 month =   10;
.................... unsigned int8 day   =	15;
.................... unsigned int8 hour	=   12;
.................... unsigned int8 minute=   34;
.................... unsigned int8 second=   56;
.................... 
.................... ///funciones
.................... #define getHour() (int16)((int16)hour << 11) + (int16)((int16)minute << 5) + (int16) (second >> 1)		//5 bits: horas, 6 bits: minutos, 5 bits: segundos/2
.................... #define getDate() (((int16)year - 1980) << 9 ) + ((int16)month << 5) + (int16)day	//7 bits: aï¿½o (desde 1980), 4 bits: mes, 5 bits: dia
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... void initFAT(){
....................    unsigned int32 startClusterOfRootDirectory = 2;
....................    unsigned int32 sctrs;
....................    unsigned  int8 *ptrSct;
....................    diskinforec *ptrDiskInfo;
.................... 
.................... 	sd_read_block(LBA0, dt);
....................     						ptrDiskInfo=&DiskInfo;
....................     						ptrSct= &dt[0];
....................    	memcpy((*ptrDiskInfo).jmpBoot, (ptrSct +  0), 3); 			//DiskInfo.jmpBoot[3]	// bytes  0.. 2: Salto a la rutina de arranque
....................    	memcpy((*ptrDiskInfo).OEMName, (ptrSct +  3), 8); 			//DiskInfo.OEMName[8]	// bytes  3..10: Es una cadena, habitualmente "MSDOS5.0"
....................    	DiskInfo.BytsPerSec = make16(dt[12],dt[11]);   				// bytes 11..12: Numero de bytes por sector (00 02 = 0x0200 = 512 bytes)
.................... 	DiskInfo.SectPerClus = dt[13];								// byte  13:	 Numero de sectores contenidos en un cluster Nota:el valor (BytsPerSec*SectPerClus) <= 32 KBytes
.................... 	DiskInfo.RsrvdCnt = make16(dt[15],dt[14]);					// bytes 14..15: Sectores reservados del volumen comenzando por el sector de volumen (debe ser >0) FAT16=1 FAT32=32 habitualmente
....................    	DiskInfo.NumFATs = dt[16];									// byte  16:	 Numero de tablas FAT en el volumen. Habitualmente es 2
.................... 	DiskInfo.RootEntCnt = make16(dt[18],dt[17]);				// bytes 17..18: Numero de entradas de 32 bytes al directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
....................    	DiskInfo.TotSect16 = make16(dt[20],dt[19]);					// bytes 19..20: Numero de sectores del volumen (si vale 0 es porque es > 0x10000=65536 y entonces TotSec32 >0)
.................... 	DiskInfo.Media = dt[21];									// byte  21:	 Hab. 0xF8 (medio fijo) Son legales tambien: F9, FA, FB, FC, FD, FE, FF, F0
.................... 	DiskInfo.FATsz16 = make16(dt[23],dt[22]);					// bytes 22..23: Sectores ocupados por una FAT16 (si es FAT32 -> es 0)
.................... 	DiskInfo.SectPerTrack = make16(dt[25],dt[24]); 				// bytes 24..25: Sectores por track
....................    	DiskInfo.NumHeads = make16(dt[27],dt[26]);					// bytes 26..27: Numero de cabezas (el anterior y este tiene sentido en diskettes, cintas, etc.)
.................... 	DiskInfo.HiddSec = make32(dt[31],dt[30],dt[29],dt[28]);		// bytes 28..31: Sectores ocultos que preceden a la particion
.................... 	DiskInfo.TotSect32=make32(dt[35],dt[34],dt[33],dt[32]);		// bytes 32..35: Numero de sectores del volumen (TotSect32*BytsPerSec) es la capacidad de la tarjeta
.................... 	DiskInfo.FATsz32 = make32(dt[39],dt[38],dt[37],dt[36]);		// bytes 36..39: Numero de sectores ocupados por una FAT
.................... 	DiskInfo.ExtFlags = make16(dt[41],dt[40]); 					// bytes 40..41: Flags usados por el sistema (no se usan y se deja a 0)
.................... 	DiskInfo.FSVer = make16(dt[43],dt[42]); 					// bytes 42..43: Version del sistema de archivos (empleamos la 0.0)
.................... 	DiskInfo.RootClus= make32(dt[47],dt[46],dt[45],dt[44]);		// bytes 44..47: Indica el numero del 1er cluster del directorio raiz.
.................... 	DiskInfo.FSInfo = make16(dt[49],dt[48]); 					// bytes 48..49: Indica el numero del sector de la estructura FSInfo (suele ser 1)
.................... 	DiskInfo.BkBootSec = make16(dt[51],dt[50]); 				// bytes 50..51: Indica el numero del sector donde esta la copia de seguridad del sector de arranque
.................... 	//  Estructura en el caso de FAT32 ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½  ï¿½
.................... 	memcpy((*ptrDiskInfo).RsrvdSys, (ptrSct +  52), 12);		//DiskInfo.RsrvdSys[12] 	// bytes 52..63: Bytes reservados para futuros usos del sistema
.................... 	DiskInfo.DrvNum = dt[64];								 	// byte  64: 	 Numero de la unidad
.................... 	DiskInfo.Reserved1 = dt[65];								// byte  65: 	 Windows NT para formatear un volumen pone este byte a 0
.................... 	DiskInfo.BootSig = dt[66]; 									// byte  66: 	 Firma digital= 0x29 (si no lo es -> volumen no reconocido por Windows)
.................... 	DiskInfo.VolId = make32(dt[70],dt[69],dt[68],dt[67]); 		// bytes 67..70: Numero de volumen (generado por el reloj del sistema).
.................... 	memcpy((*ptrDiskInfo).VolLab, (ptrSct +  71), 11);			//DiskInfo.VolLab[11]	// bytes 71..81: Es una cadena etiqueta del volumen suele ser "NO NAME    "
.................... 	memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  82), 8);		//DiskInfo.FilSysType[8] 	// bytes 82..89: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT32   "
.................... 	memcpy((*ptrDiskInfo).spam, (ptrSct +  90),420);			//DiskInfo.spam[420]		// bytes 90..509:Zona de codigo (en uSD no se emplea y suele estar a 0)
.................... 	DiskInfo.firma = make16(dt[510],dt[511]);								// byte 510..511:Debe de vale 55 AA
.................... 
....................    		FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'3''2'
.................... 
....................    if(FATType == 32){
.................... 						sect_x_fat  = DiskInfo.FATsz32;		// Sectores reservados para la FAT
.................... 						startClusterOfRootDirectory = DiskInfo.RootClus;
....................  	}else{
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);	//DiskInfo.FilSysType[8] 	// bytes 54..61: Es una cadena con el nombre de sistema de archivos (p.ej. "FAT16   "
.................... 						FATType = (DiskInfo.FilSysType[3]-'0')*10+ DiskInfo.FilSysType[4]-'0'; // Vale de tomar FAT'1''6'
.................... 	}
.................... 
.................... 	if(FATType == 16){
.................... 						DiskInfo.VolId = make32(dt[42],dt[41],dt[40],dt[39]);
.................... 						memcpy((*ptrDiskInfo).VolLab, (ptrSct +  43), 11);
.................... 						memcpy((*ptrDiskInfo).FilSysType, (ptrSct +  54), 8);
.................... 
.................... 						sect_x_fat  = DiskInfo.FATsz16;		// Sectores reservados para la FAT
.................... 						startClusterOfRootDirectory = DiskInfo.RootEntCnt;
....................  					}
.................... 
....................   	sect_x_cluster = DiskInfo.SectPerClus;					// Cada cluster tiene este numero de sectores
.................... 
....................     			      sctrs  = LBA0;
.................... 				  	  sctrs += DiskInfo.RsrvdCnt;
.................... 	sect_reserv 	= sctrs;								// sectores reservados por el sistema
.................... 
....................     sect_fat_1  	= sctrs;               					// A partir de ahï¿½: FAT 1
.................... 				  	  sctrs += sect_x_fat;
.................... 	sect_fat_2  	= sctrs;;								// A partir de ahï¿½: FAT 2 (copia de seguridad)
.................... 				  	  sctrs += sect_x_fat;
.................... 	sect_entry  	= sctrs ;      							// A partir de ahï¿½ empieza el raï¿½z (la lista de ficheros)
.................... 					  sctrs += sect_x_cluster;
.................... 	sect_ini_datos 	= sctrs ;								// A partir de ahi los datos del fichero
.................... 
....................     if(FATType == 16)										// RootEntCnt: Numero de entradas de 32 bytes al
....................     sect_ini_datos = sect_entry+(DiskInfo.RootEntCnt>>4);	// directorio raiz. Habitualmente FAT16= 512 y FAT32= 0
.................... 
.................... }//fin initFAT()
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void cargaConfig(unsigned int32 j);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... // unsigned int8 encontrar_fichero(){
.................... //    unsigned int8 FicheroEncontrado = 0;
.................... //    unsigned int32 i;
.................... //    unsigned int16 j;
.................... //    unsigned int32 SctStart = sect_entry;			//inicio Root
.................... //    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root
.................... //    unsigned int32 ClstIni  = ((FATType==16)?1:2);
.................... //
.................... //    unsigned int32 ClstNxt;
.................... //    unsigned int32 sctrClstr;
.................... //    unsigned int32 posSctr;
.................... //    unsigned int32 clstrSig;
.................... //
.................... //    for(i = SctStart; i < SctEnd; i++){
.................... // 	      sd_read_block(i, dt);
.................... // 		 for(j = 0; j < 512; j += 32){
.................... // 										if(	(dt[j + 0] == 'C')&&
.................... // 											(dt[j + 1] == 'O')&&
.................... // 											(dt[j + 2] == 'N')&&
.................... // 											(dt[j + 3] == 'F')&&
.................... // 											(dt[j + 4] == 'I')&&
.................... // 											(dt[j + 5] == 'G')&&
.................... // 											(dt[j + 6] == ' ')&&
.................... // 											(dt[j + 7] == ' ')&&
.................... // 											(dt[j + 8] == 'T')&&
.................... // 											(dt[j + 9] == 'X')&&
.................... // 											(dt[j + 10]== 'T')){
.................... // 																 cargaConfig(j);
.................... // 																 FicheroEncontrado = 1;
.................... // 																 return FicheroEncontrado;
.................... // 																}//fin if(CNF)
.................... //
.................... // 		}//j
.................... //    }//i
.................... //    return FicheroEncontrado;
.................... // } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void cargaConfig(unsigned int32 j){
....................    unsigned int32 direccion;
....................    unsigned int32 _sector;
.................... 
.................... 	if(FATType==16){
.................... 	   	direccion = make32(0,0,dt[j+27],dt[j+26]);
.................... 		_sector = ((unsigned int32)direccion - 2) * sect_x_cluster + sect_ini_datos;
.................... 	}
.................... 	if(FATType==32){
.................... 	   direccion = make32(dt[j+21],dt[j+20],dt[j+27],dt[j+26]); //en FAT32 se usa EAIndex + first cluster
.................... 	   _sector = ((unsigned int32)direccion - 3) * sect_x_cluster + sect_ini_datos;
....................    }
....................    sd_read_block(_sector, dt); //leer el primer sector de los datos del fichero
.................... 
....................    // Ahora en el vector dt tengo los datos del fichero y puedo emplearlo
....................    // Por ejemplo: el texto que indica la hora y minutos del ensayo lo obtendria como:
....................    // hora   = (dt[140]-'0')*10 + dt[141]-'0' ;
....................    // minutos= (dt[143]-'0')*10 + dt[144]-'0' ;
....................    // ... Y con esos datos haria algo util
.................... 
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 inicializa_fichero(){
....................    unsigned int8 FicheroIncializado = 0;
....................    unsigned int32 i;
....................    unsigned int16 j;
....................    unsigned int32 SctStart = sect_entry;			//inicio Root
....................    unsigned int32 SctEnd   = sect_ini_datos;		//fin    Root
....................    unsigned int32 ClstIni  = ((FATType==16)?0:1);
.................... 
....................    unsigned int32 ClstNxt;
....................    unsigned int32 sctrClstr;
....................    unsigned int32 posSctr;
....................    unsigned int32 clstrSig;
.................... 
....................    unsigned int32 startCluster;      //cluster donde empezarï¿½an los datos del fichero
....................    fileEntry newFile;
.................... 
....................    for(i = SctStart; i < SctEnd; i++){
.................... 	      sd_read_block(i, dt);
.................... 		  for(j = 0; j < 512; j += 32){
.................... 			if((dt[j] == 0x00) || dt[j] == 0xFF){
.................... 					   newFile.fields.name[0] = 		'L';
.................... 					   newFile.fields.name[1] = 		'A';
.................... 					   newFile.fields.name[2] = 		'T';
.................... 					   newFile.fields.name[3] = 		'I';
.................... 					   newFile.fields.name[4] = 		'D';
.................... 					   newFile.fields.name[5] = 		'O';
.................... 					   newFile.fields.name[6] = 		'S';
.................... 					   newFile.fields.name[7] = 		'_';
.................... 					   newFile.fields.extension[0] = 	'T';
.................... 					   newFile.fields.extension[1] = 	'X';
.................... 					   newFile.fields.extension[2] = 	'T';
.................... 					   newFile.fields.reserved = 0;
.................... 					   newFile.fields.createTimeMs = 0;
.................... 					   newFile.fields.create_hour = getHour();
.................... 					   newFile.fields.create_date = getDate();
.................... 					   newFile.fields.last_access = newFile.fields.create_date;
.................... 					   newFile.fields.eaIndex = 0;
.................... 					   newFile.fields.attrib = __FILE | READONLY;   //archivo normal + sï¿½lo lectura
.................... 					   newFile.fields.modif_hour = newFile.fields.create_hour;
.................... 					   newFile.fields.modif_date = newFile.fields.create_date;
.................... 					   newFile.fields.first_cluster = 0;
.................... 					   newFile.fields.size = 0;
.................... 
.................... 					   file.offsetEntry = j;
.................... 					   file.sectorEntryFile = i;
.................... 					   sd_read_block(file.sectorEntryFile, file.EntryFile);
.................... 
.................... 					   for(i = 0; i < 32; j++, i++)  dt[j] = newFile.raw[i];
.................... 					   for(i = 0; i < 512; i++)      file.EntryFile[i] = dt[i];
.................... 					   file.posInSector    = 0;   															//empezamos en un sector y cluster nuevos
.................... 					   if(FATType==16){
.................... 					   startCluster = encontrarCluster(2);         											//busco cluster donde empezarï¿½a a almacenarse los datos
.................... 					   file.currentCluster = startCluster;   												//que serï¿½ el cluster en el que escribiremos
.................... 					   file.currentSector  = (file.currentCluster -  2) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster)
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 8) + sect_reserv;						//sector en la FAT donde marcar el cluster usado
.................... 					   }
.................... 					   if(FATType==32){
.................... 					   startCluster = encontrarCluster(3);         											//busco cluster donde empezarï¿½a a almacenarse los datos
.................... 					   file.currentCluster = startCluster;   												//que serï¿½ el cluster en el que escribiremos
.................... 					   file.currentSector  = (file.currentCluster -  3) * sect_x_cluster + sect_ini_datos;  //sector en el que escribiremos (es el primero del cluster)
.................... 					   file.sectorAtFAT    = (file.currentCluster >> 7) + sect_reserv;						//sector en la FAT donde marcar el cluster usado
.................... 					   }
.................... 					   file.EntryFile[file.offsetEntry + 27] = make8(file.currentCluster, 1); 					//1er cluster del archivo
.................... 					   file.EntryFile[file.offsetEntry + 26] = make8(file.currentCluster, 0);
.................... 					   file.EntryFile[file.offsetEntry + 21] = make8(file.currentCluster, 3);
.................... 					   file.EntryFile[file.offsetEntry + 20] = make8(file.currentCluster, 2);
.................... 					   file.size = 0;																			//Inicialmente el tamaï¿½o es cero
.................... 
.................... 					   if(FATType==16){
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile);
.................... 						sd_read_block (file.sectorAtFAT, sector_fat16);
.................... 						sector_fat16[file.currentCluster % MAX_ENTRIES_SECTOR_FAT16] = ENDFILE16;				//marco el cluster como usado
.................... 						sd_write_block( file.sectorAtFAT, sector_fat16);
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat16);   //FAT2					//ï¿½Ojo! la cosa puede ser mas complicada...
.................... 						}
.................... 					   if(FATType==32){
.................... 						sd_write_block(file.sectorEntryFile, file.EntryFile);
.................... 						sd_read_block (file.sectorAtFAT,sector_fat32);
.................... 						sector_fat32[file.currentCluster % MAX_ENTRIES_SECTOR_FAT32] = ENDFILE32;				//marco el cluster como usado
.................... 						sd_write_block( file.sectorAtFAT, sector_fat32);
.................... 						sd_write_block((file.sectorAtFAT+sect_x_fat),sector_fat32);   //FAT2					//ï¿½Ojo! la cosa puede ser mas complicada...
.................... 						}
.................... 					   FicheroIncializado = 1;
.................... 					   return FicheroIncializado;
.................... 					   }
.................... 
.................... 		}//j
....................    }//i
....................    return FicheroIncializado;
.................... } // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int32 encontrarCluster(unsigned int32 clusterStart){
....................    unsigned int32 cluster;
....................    unsigned int32 _sector;   //recorrer sectores
....................    unsigned int32 bytes;     //recorrer bytes en cada sector
.................... 
....................    cluster =  clusterStart;
....................    if(FATType==16)
....................    _sector = (clusterStart >> 2) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante
....................    if(FATType==32)
....................    _sector = (clusterStart >> 3) + sect_fat_1;	// Empiezo a buscar desde donde estoy en adelante
....................    bytes = (clusterStart % ((FATType==16) ? MAX_ENTRIES_SECTOR_FAT16 : MAX_ENTRIES_SECTOR_FAT32));
.................... 
....................    if(FATType==32){
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT
.................... 		  sd_read_block(_sector,sector_fat32); 							//leemos el sector
....................     					      for(; bytes < MAX_ENTRIES_SECTOR_FAT32; bytes++){ //recorremos el sector para buscar un puntero a cluster libre
.................... 					         if(sector_fat32[bytes]== 0){
.................... 					            if(cluster < 3)               continue;  	//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando
.................... 					            return cluster;
.................... 					         }//fin if
.................... 					         cluster++;
.................... 					      }//fin for de recorrer bytes dentro de un sector
.................... 	      bytes = 0;
.................... 	   }//fin for de recorrer sectores
....................    }else
....................     if(FATType==16){
.................... 	   for(;_sector < sect_fat_2; _sector++){      						//recorremos los sectores de la FAT
.................... 		  sd_read_block(_sector,sector_fat16); 							//leemos el sector
.................... 
.................... 					      for(; bytes < MAX_ENTRIES_SECTOR_FAT16; bytes++){ 	//recorremos el sector para buscar un puntero a cluster libre
.................... 					         if(sector_fat16[bytes]== 0){
.................... 					            if(cluster < 2)               continue;		//si hubiera un error y el primer cluster de la fat apareciera como disponible, seguimos buscando
.................... 					            return cluster;
.................... 					         }//fin if
.................... 					         cluster++;
.................... 					      }//fin for de recorrer bytes dentro de un sector
.................... 	      bytes = 0;
.................... 	   }//fin for de recorrer sectores
.................... 	}
....................    return ((FATType==16)?ENDFILE16:ENDFILE32);
.................... }//fin encontrarCluster
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... void escribe_datos_en_fichero(){
....................    unsigned int32 relSector;
....................    unsigned int32 nextCluster;
....................    unsigned int32  oldCluster;
....................    unsigned int16 _hour, date;
.................... 
.................... 	sd_write_block(file.currentSector, dt);
.................... 
.................... 
.................... 
.................... 
.................... 		file.currentSector++;																					//actualizar las FATs
.................... 		if(FATType==16)
.................... 	    relSector= file.currentSector - ((file.currentCluster -  2) * sect_x_cluster + sect_ini_datos);
.................... 		if(FATType==32)
.................... 	    relSector= file.currentSector - ((file.currentCluster -  3) * sect_x_cluster + sect_ini_datos);
.................... 
.................... 	    if((relSector % sect_x_cluster) == 0){   											//ï¿½el siguiente sector estï¿½ en cluster nuevo?
.................... 	      oldCluster = 	file.currentCluster;
.................... 	      nextCluster = encontrarCluster(oldCluster);   									//siguiente cluster
.................... 	      //escribirCluster(oldCluster, nextCluster);  										//marcar actual cluster para que apunte al siguiente
.................... 	      file.currentCluster = nextCluster;
.................... 		  if(FATType==16)
.................... 	      file.currentSector = (nextCluster - 2) * sect_x_cluster + sect_ini_datos;
.................... 		  if(FATType==32)
.................... 	      file.currentSector = (nextCluster - 3) * sect_x_cluster + sect_ini_datos;
.................... 	   }
.................... 
.................... 	   //actualizar el tamaï¿½o del fichero y fechas
.................... 	   file.size += 512;
.................... 	   file.EntryFile[file.offsetEntry + 28] = make8(file.size, 0);   //tamaï¿½o
.................... 	   file.EntryFile[file.offsetEntry + 29] = make8(file.size, 1);
.................... 	   file.EntryFile[file.offsetEntry + 30] = make8(file.size, 2);
.................... 	   file.EntryFile[file.offsetEntry + 31] = make8(file.size, 3);
.................... 	   //ActualizaReloj();
.................... 	   _hour = getHour();
.................... 	   date = getDate();
.................... 	   file.EntryFile[file.offsetEntry + 24] = make8(date, 0);       //fecha modif
.................... 	   file.EntryFile[file.offsetEntry + 25] = make8(date, 1);
.................... 	   file.EntryFile[file.offsetEntry + 22] = make8(_hour, 0);      //hora modif
.................... 	   file.EntryFile[file.offsetEntry + 23] = make8(_hour, 1);
.................... 	   file.EntryFile[file.offsetEntry + 18] = file.EntryFile[file.offsetEntry + 24];   //fecha ï¿½ltimo acceso
.................... 	   file.EntryFile[file.offsetEntry + 19] = file.EntryFile[file.offsetEntry + 25];
.................... 
.................... 	   sd_write_block(file.sectorEntryFile, file.EntryFile);  	// Actualiza root
.................... 
.................... }
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __MIFAT_H
.................... 
.................... #include "sdcard.h"
.................... 
.................... #ifndef __SDCARD_H
.................... #define __SDCARD_H
.................... 
.................... #bit  SPIRBF    = getenv("SFR:SPI1STAT").0
.................... #bit  SPITBF    = getenv("SFR:SPI1STAT").1
.................... #bit  SPIROV    = getenv("SFR:SPI1STAT").6
.................... #byte SPI1BUF   = getenv("SFR:SPI1BUF")
.................... #byte SPI1STAT  = getenv("SFR:SPI1STAT")
.................... #byte SPI1CON1  = getenv("SFR:SPI1CON1")
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define   CMD0              		0x40      //go to idle				//Commands
.................... #define   CMD1               		0x41      //initialization process
.................... #define   CMD8               		0x48      //verify interface
.................... #define   CMD17              		0x51      //read single block
.................... #define   CMD24              		0x58      //write single block
.................... #define   CMD55              		0x77      //escape for app specific command
.................... #define   CMD58              		0x7a      //read OCR
.................... #define   ACMD41             		0x69      //poll operation range
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define   R1_READY_STATE          	0x00      //sd ready				//Responses
.................... #define   R1_IDLE_STATE           	0x01      //card in idle state
.................... #define   R1_ILLEGAL_COMMAND      	0x04      //illegal command
.................... #define   DATA_START_BLOCK       	0xFE      //start token for read or write
.................... #define   DATA_RES_MASK          	0x1F      //mask for data response
.................... #define   DATA_RES_ACCEPTED      	0x05      //write accepted
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sdhc;
.................... unsigned int8 dt[512];            /// Buffer de escritura  en uSD
.................... unsigned int32 LBA0 = 0;
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... inline unsigned int8 xfer_spi(char envio){
....................    SPIROV = 0;
....................    SPI1BUF= envio;
....................    while( SPITBF);
....................    while(!SPIRBF);
....................    return SPI1BUF;
.................... }//fin xfer_spi
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 Commnd(char befF, int32 SD_Adress, char befH){
....................    unsigned int8 iC1;
....................    xfer_spi(0xFF);
....................    xfer_spi(befF);
....................    xfer_spi(make8(SD_Adress, 3));
....................    xfer_spi(make8(SD_Adress, 2));
....................    xfer_spi(make8(SD_Adress, 1));
....................    xfer_spi(make8(SD_Adress, 0));
....................    xfer_spi(befH);
....................     do{iC1 = xfer_spi(0xFF);
....................    }while(iC1 == 0xFF);
....................    return iC1;
.................... }//fin Commnd
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr);
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_init(){
....................  unsigned  int8 R[17]={0}, versionSD= 1, crc;
....................  unsigned int16 iI;
....................  unsigned int32 arg=0;
.................... 
....................  setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_16);
.................... 
....................  memset(dt,0,512);
....................  // CMD0 - GO_IDLE_STATE  (R1)ï¿½ ï¿½ Card Reset  ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 	do{	output_high(CS);   	// tarjeta deshabilitada
.................... 		for (iI = 0; iI < 10; iI++)  	xfer_spi(0xFF);
.................... 		output_low(CS); 	// tarjeta habilitada
.................... 		R[0] = Commnd( CMD0 , 0x00000000 , 0x95); //go to idle
.................... 	}while( R[0] != R1_IDLE_STATE);
....................   // CMD8 - SEND_IF_COND (R7)  ï¿½ Send Interface Condition Commandï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // Argument 00 - 00 - 01 (Voltage supplied = 2.7-3.6V) - AA (Check pattern)
....................   // Response: illegal command -> Version 1
....................   // Response: echo-back 	   -> Version 2
.................... 	R[0] = Commnd(CMD8, 0x000001AA, 0x87);
....................     if(R[0]& R1_ILLEGAL_COMMAND){	  			versionSD = 1;
....................    			}else{	R[1] = xfer_spi(0xFF);
.................... 					R[2] = xfer_spi(0xFF);
.................... 					R[3] = xfer_spi(0xFF);
.................... 					R[4] = xfer_spi(0xFF);
.................... 				    if(R[4]!=0xAA){	output_high(CS); return 1; }		//error
....................       											versionSD = 2;
....................    			}
.................... 
....................   // ACMD41 - SD_SEND_OP_ COND (R1) ï¿½ ï¿½ Initialization Command   ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // If host supports SDHC or SDXC: HCS (Host Capacity Support) is set to 1 (arg= 0x40000000)
....................   // If host only support SDSC:     HCS (Host Capacity Support) is set to 0 (arg= 0)
....................    arg = (versionSD == 2) ? 0x40000000 : 0;
....................    crc = (versionSD == 2) ? 0x77 : 0xFF;
.................... 
.................... 
....................    do{            Commnd(CMD55,    0, 0x65);	// El proceso puede llegar a durar hasta 1 segundo
....................            R[0] = Commnd(ACMD41, arg, crc);		// Application-Specific Command ï¿½ APP_CMD (CMD55)
.................... 		   delay_ms(4);
....................    }while(R[0] != R1_READY_STATE);
.................... 
....................   if(versionSD == 2){
.................... 
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // CMD58 - READ_OCR (R3) ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
....................   // Bit 30 - Card Capacity Status bit: 	0 indicates that the card is SDSC.
....................   //										1 indicates that the card is SDHC or SDXC
.................... 	R[0] = Commnd(CMD58, 0x00000000, 0xFF);
....................     if(R[0] == R1_READY_STATE){	R[1] = xfer_spi(0xFF);
.................... 								R[2] = xfer_spi(0xFF);
.................... 								R[3] = xfer_spi(0xFF);
.................... 								R[4] = xfer_spi(0xFF);
.................... 								sdhc = ((R[1]& 0xC0) == 0xC0) ? 1 : 0;
....................    			}else{				output_high(CS); return 1; }		//error
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 
....................   }// versionSD == 2 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
....................   setup_spi(SPI_MASTER|SPI_SS_DISABLED|SPI_L_TO_H|SPI_XMIT_L_TO_H|SPI_CLK_DIV_1);
.................... 
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 	sd_read_block(0, dt);	//Lee el sector fisico 0 para obtener el LBA0
.................... 	if(dt[510]==0x55)
.................... 	if(dt[511]==0xAA){ 		// Efectivamente parece que estoy en sct 0
.................... 							// Tabla de particiones
.................... 								LBA0 = make32(dt[457],dt[456],dt[455],dt[454]);
.................... 								if(dt[0]==0xEB) // MBR
....................  								LBA0 = 0;
.................... 						  }//55AA
....................   // ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½
.................... 
....................   output_high(CS);   									// tarjeta deshabilitada
....................   return 0;
.................... }//char sd_init()- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_write_block(unsigned int32 address, unsigned char* ptr){
....................    unsigned int16 iW;
.................... 
....................    if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores
....................    output_low(CS);
.................... 
.................... 		iW = Commnd(CMD24, address, 0xFF);
....................     if( iW == R1_READY_STATE){
....................              								              		xfer_spi(0xFF);
....................                               									xfer_spi(DATA_START_BLOCK);   // Data start token
....................                            			for(iW = 0; iW < 512; iW++)  xfer_spi(ptr[iW]);
....................                            							xfer_spi(0xFF);   // Dummy bytes
....................                           							xfer_spi(0xFF);   // en lugar del CRC16
.................... 
....................                         do{       iW = xfer_spi(0xFF);
....................                         }while( (iW & DATA_RES_MASK) != DATA_RES_ACCEPTED);
.................... 
....................                         do{       iW = xfer_spi(0xFF); delay_us(100);
....................                         }while(   iW == 0 );
.................... 
.................... 						xfer_spi(0xFF);
.................... 						xfer_spi(0xFF);
.................... 
....................    						output_high(CS);   return 0; //correcto
.................... 						}
....................    						output_high(CS);   return 1; //error
.................... }//fin sd_write_block
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... unsigned int8 sd_read_block(unsigned int32 address, unsigned char* ptr){
....................    unsigned int16 jR;
....................    unsigned int8  iR;
.................... 
....................     if(sdhc==0){ address <<= 9; }    //memoria SC -> bytes 		memoria HC -> sectores
....................     output_low(CS);
.................... 
....................        iR  = Commnd(CMD17, address, 0xFF);
....................     if(iR == R1_READY_STATE){
.................... 								do{     iR  = xfer_spi(0xFF);
.................... 								}while( iR != DATA_START_BLOCK);
.................... 
.................... 								if(iR == DATA_START_BLOCK){
.................... 								for(jR = 0; jR < 512; jR++)
.................... 								         ptr[jR] = xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
.................... 								xfer_spi(0xFF);
....................   								}
.................... 
....................    							output_high(CS);      return 0;
.................... 							}
.................... 							output_high(CS);      return 1;
.................... }//fin sd_read_block
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __SDCARD_H
.................... 
.................... 
.................... void sd_init_global();
.................... void escritura_sd();
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif // __SD_CARD_H
.................... 
.................... #include "BLUETOOTH.h"
.................... #ifndef Bluetooth_h
.................... #define Bluetooth_h
.................... #include "Header.h"
.................... #ifndef HEADER_h
.................... #define HEADER_h
.................... //-------------------------------------------------------------------
.................... 
.................... #include "33FJ128MC804.h"
.................... 
.................... #fuses NOJTAG      // JTAG port is disabled
.................... #fuses NOPROTECT   // Code protection is disabled
.................... #fuses NOWRT       // Writes to program memory are allowed
.................... #fuses ICSP1       // Emulator functions are shared with PGEC1/PGED1
.................... #fuses NOWDT       // WDT is disabled; SWDTEN bit is disabled
.................... #fuses WPOSTS16    // Watchdog Timer Postscaler Select bits-> 1:32,768 (NOT USED)
.................... #fuses NOIESO      // Internal External Switchover bit: IESO mode (Two-Speed Start-up) is disabled
.................... #fuses FRC_PS      // Initial Oscillator Select bits: Fast RC Oscillator with Postscaler (FRCDIV)
.................... #fuses CKSNOFSM    // Clock switching is enabled, Fail-Safe Clock Monitor is disabled
.................... #fuses OSCIO       // OSCO Pin Configuration bit: OSCO/CLKO/RC15 functions as port I/O (RC15)
.................... #fuses NOPR        // Primary Oscillator Configuration bits: Primary Oscillator mode is disabled
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use delay(clock=7370000)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ON(pin)   output_high(pin)
.................... #define OFF(pin)   output_low( pin)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //#define SDA1         PIN_B9  //                    ( 1)
.................... #define BUZZER         PIN_C6  //                    ( 2)
.................... #define LED1           PIN_C7  //                    ( 3)
.................... #define LED2           PIN_C8  //                    ( 4)
.................... #define LED3           PIN_C9  //                    ( 5)
.................... //                     VSS     //                    ( 6)
.................... //                     VCAP    //                    ( 7)
.................... #define H3             PIN_B10 //                    ( 8)
.................... #define L3             PIN_B11 //                    ( 9)
.................... #define H2             PIN_B12 //                    (10)
.................... #define L2             PIN_B13 //                    (11)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define _I             PIN_A10 //                    (12)
.................... #define BTOK           PIN_A7  //                    (13)
.................... #define H1             PIN_B14 //                    (14)
.................... #define L1             PIN_B15 //                    (15)
.................... //                     AVSS    //                    (16)
.................... //                     AVDD    //                    (17)
.................... //                     ~MCLR   //                    (18)
.................... #define BTIN           PIN_A0  //                    (19)
.................... #define POT  		       PIN_A1  //                    (20)
.................... //                     PIN_B0  //                    (21)
.................... //                     PIN_B1  //                    (22)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #define ANL4           PIN_B2  //                    (23)
.................... #define ANL3           PIN_B3  //                    (24)
.................... #define ANL2           PIN_C0  //                    (25)
.................... #define SD             PIN_C1  //                    (26)
.................... #define ANL1           PIN_C2  //                    (27)
.................... //                     VDD     //                    (28)
.................... //                     VSS     //                    (29)
.................... //                     PIN_A2  //                    (30)
.................... //                     PIN_A3  //                    (31)
.................... #define BTCM           PIN_A8  //                    (32)
.................... //                     PIN_B4  //                    (33)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... //                     PIN_A4  //                    (34)
.................... #define COMM           PIN_A9  //                    (35)
.................... #pin_select U1TX =     PIN_C3  //                    (36)
.................... #pin_select U1RX =     PIN_C4  //                    (37)
.................... #define CS             PIN_C5  //                    (38)
.................... //                     VSS     //                    (39)
.................... //                     VDD     //                    (40)
.................... #pin_select SDI1 =     PIN_B5  //                    (41)
.................... #pin_select SCK1OUT=   PIN_B6  //                    (42)
.................... #pin_select SDO1 =     PIN_B7  //                    (43)
.................... //#define SCL1         PIN_B8  //                    (44)
.................... // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... 
.................... #endif
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #use rs232(UART1,baud=115200,STREAM=BT)
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... void init_BT(void); //inits and enables uart isr
.................... void enviar_datos(unsigned int16 ppm);
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.................... #endif
.................... 
.................... 
.................... unsigned int16 ppm;
.................... int1 datos_flag;
.................... char cadena[32];
.................... int jj, k;
.................... 
.................... #INT_TIMER2
.................... 
.................... void timer2_isr()
*
006EA:  PUSH    42
006EC:  PUSH    36
006EE:  PUSH    32
006F0:  MOV     W0,[W15++]
006F2:  MOV     #2,W0
006F4:  REPEAT  #C
006F6:  MOV     [W0++],[W15++]
.................... {
.................... 	ppm=algoritmo();
006F8:  CALL    5F8
*
006FC:  MOV     W0,3BB8
.................... 	//sprintf(cadena,"%04d\n",ppm); //Escribe ppm en el archivo LATIDOS
.................... 	// output_toggle(H1);
.................... 	//
.................... 	// for(jj=0;jj<5;jj++)
.................... 	// {
.................... 	// 	dt[jj+(k*5)] = cadena[jj];
.................... 	// }
.................... 	// k++;
.................... }
.................... 
006FE:  BCLR.B  84.7
00700:  MOV     #1A,W0
00702:  REPEAT  #C
00704:  MOV     [--W15],[W0--]
00706:  MOV     [--W15],W0
00708:  POP     32
0070A:  POP     36
0070C:  POP     42
0070E:  RETFIE  
.................... #INT_TIMER5
.................... void timer5_isr()
00710:  PUSH    42
00712:  PUSH    36
00714:  PUSH    32
00716:  MOV     W0,[W15++]
00718:  MOV     #2,W0
0071A:  REPEAT  #C
0071C:  MOV     [W0++],[W15++]
.................... {
.................... 	datos_flag=1;
0071E:  BSET.B  1CF0.1
00720:  BCLR.B  87.4
00722:  MOV     #1A,W0
00724:  REPEAT  #C
00726:  MOV     [--W15],[W0--]
00728:  MOV     [--W15],W0
0072A:  POP     32
0072C:  POP     36
0072E:  POP     42
00730:  RETFIE  
.................... }
.................... 
.................... void main(void)
*
00E44:  MOV     #3F60,W15
00E46:  MOV     #3FFF,W0
00E48:  MOV     W0,20
00E4A:  NOP     
00E4C:  MOV     #4444,W0
00E4E:  MOV     W0,A6
00E50:  MOV     #4444,W0
00E52:  MOV     W0,B0
00E54:  BSET.B  81.7
00E56:  DISI    #6
00E58:  MOV     #742,W1
00E5A:  MOV     #46,W2
00E5C:  MOV     #57,W3
00E5E:  MOV.B   W2L,[W1]
00E60:  MOV.B   W3L,[W1]
00E62:  BCLR.B  742.6
00E64:  MOV     #3F14,W0
00E66:  MOV     W0,6A4
00E68:  MOV     #605,W0
00E6A:  MOV     W0,6A8
00E6C:  MOV     #708,W0
00E6E:  MOV     W0,6C6
00E70:  MOV     #300,W0
00E72:  MOV     W0,6D2
00E74:  MOV     #13,W0
00E76:  MOV     W0,6D6
00E78:  DISI    #6
00E7A:  MOV     #742,W1
00E7C:  MOV     #46,W2
00E7E:  MOV     #57,W3
00E80:  MOV.B   W2L,[W1]
00E82:  MOV.B   W3L,[W1]
00E84:  BSET.B  742.6
00E86:  MOV     #7E4,W4
00E88:  MOV     W4,1290
00E8A:  MOV.B   #14,W0L
00E8C:  MOV.B   W0L,1292
00E8E:  MOV.B   #A,W0L
00E90:  MOV.B   W0L,1293
00E92:  MOV.B   #F,W0L
00E94:  MOV.B   W0L,1294
00E96:  MOV.B   #C,W0L
00E98:  MOV.B   W0L,1295
00E9A:  MOV.B   #22,W0L
00E9C:  MOV.B   W0L,1296
00E9E:  MOV.B   #38,W0L
00EA0:  MOV.B   W0L,1297
00EA2:  CLR     A5A
00EA4:  CLR     A5C
00EA6:  MOV     #8000,W4
00EA8:  MOV     W4,220
00EAA:  MOV     #400,W4
00EAC:  MOV     W4,222
00EAE:  BCLR.B  220.3
00EB0:  MOV     #1,W4
00EB2:  MOV     W4,228
00EB4:  BRA     F30
00EB6:  DATA    80,02,02
00EB8:  DATA    04,02,00
00EBA:  DATA    80,02,02
00EBC:  DATA    0A,00,00
00EBE:  DATA    80,04,02
00EC0:  DATA    20,00,80
00EC2:  DATA    00,04,80
00EC4:  DATA    02,02,28
00EC6:  DATA    01,00,80
00EC8:  DATA    02,03,2C
00ECA:  DATA    FF,FF,80
00ECC:  DATA    04,14,9A
00ECE:  DATA    00,00,00
00ED0:  DATA    00,80,01
00ED2:  DATA    18,BD,14
00ED4:  DATA    80,07,1C
00ED6:  DATA    D0,E4,07
00ED8:  DATA    0A,0F,0C
00EDA:  DATA    22,38,80
00EDC:  DATA    04,1E,F6
00EDE:  DATA    00,00,00
00EE0:  DATA    00,80,01
00EE2:  DATA    23,19,14
00EE4:  DATA    80,07,27
00EE6:  DATA    2C,E4,07
00EE8:  DATA    0A,0F,0C
00EEA:  DATA    22,38,80
00EEC:  DATA    04,27,36
00EEE:  DATA    00,00,00
00EF0:  DATA    00,80,04
00EF2:  DATA    29,3A,00
00EF4:  DATA    00,00,00
00EF6:  DATA    80,08,31
00EF8:  DATA    70,E4,07
00EFA:  DATA    14,0A,0F
00EFC:  DATA    0C,22,38
00EFE:  DATA    80,04,33
00F00:  DATA    7A,00,00
00F02:  DATA    00,00,80
00F04:  DATA    01,37,9D
00F06:  DATA    14,80,07
00F08:  DATA    3B,B0,E4
00F0A:  DATA    07,0A,0F
00F0C:  DATA    0C,22,38
00F0E:  DATA    80,02,3B
00F10:  DATA    DE,00,00
00F12:  DATA    00,00,00
00F14:  INC     W2,W2
00F16:  CP      W2,#1
00F18:  BRA     NZ,F22
00F1A:  TBLRDL  [W1],W3
00F1C:  TBLRDH  [W1++],W4
00F1E:  MOV.B   6,W0L
00F20:  RETURN  
00F22:  CP      W2,#2
00F24:  BRA     NZ,F2A
00F26:  MOV.B   7,W0L
00F28:  RETURN  
00F2A:  MOV.B   8,W0L
00F2C:  CLR     W2
00F2E:  RETURN  
00F30:  MOV     #0,W6
00F32:  MOV     #0,W0
00F34:  MOV     W0,32
00F36:  MOV     #EB6,W0
00F38:  MOV     W0,W1
00F3A:  CLR     W2
00F3C:  CALL    F14
*
00F40:  MOV.B   W0L,B
00F42:  CALL    F14
*
00F46:  MOV.B   W0L,A
00F48:  CP0     W5
00F4A:  BRA     Z,F7E
00F4C:  BTSS    W5.F
00F4E:  BRA     F5E
00F50:  CALL    F14
*
00F54:  MOV.B   W0L,D
00F56:  CALL    F14
*
00F5A:  MOV.B   W0L,C
00F5C:  BCLR    W5.F
00F5E:  BTSS    W5.E
00F60:  BRA     F72
00F62:  BCLR    W5.E
00F64:  DEC     W5,W5
00F66:  CALL    F14
*
00F6A:  MOV.B   W0L,W7L
00F6C:  REPEAT  W5
00F6E:  MOV.B   W7L,[W6++]
00F70:  BRA     F3C
00F72:  CALL    F14
*
00F76:  MOV.B   W0L,[W6++]
00F78:  DEC     W5,W5
00F7A:  BRA     NZ,F72
00F7C:  BRA     F3C
00F7E:  MOV     #0,W4
00F80:  MOV     W4,3BEC
.................... {
....................   //DeclaraciÃ³n e inicializaciÃ³n de variables
.................... 
....................   char ppm_string[9];
.................... 
.................... 	// Flags del programa
....................   int1 peligro_flag, peligro_flag_ant, altas, bajas;
.................... 
....................   unsigned int16 ppm_anterior=0;
.................... 
.................... 
.................... 	peligro_flag_ant=0;
00F82:  MOV     3BE0,W0
00F84:  BCLR.B  0.1
00F86:  MOV     W0,3BE0
.................... 	altas=0;
00F88:  MOV     3BE0,W0
00F8A:  BCLR.B  0.2
00F8C:  MOV     W0,3BE0
.................... 	bajas=0;
00F8E:  MOV     3BE0,W0
00F90:  BCLR.B  0.3
00F92:  MOV     W0,3BE0
.................... 
....................   //para debugging. Eliminar al final
....................   datos_flag=1;
00F94:  BSET.B  1CF0.1
.................... 
.................... 
....................   // -----------------------------------------
.................... 
....................   // 1. InicializaciÃ³n de mÃ³dulos (BT, LCD)
....................   // 2. Menu de bienvenida y espera a BTOK
.................... 	// 3. Inicializar ADC y rutina del algoritmo
....................   // 4. Bucle de programa. Finalizar al pulsar BTOK
.................... 	//			4.1 Un ISR temporizado calcula las ppm
....................   //      4.2 Generar alarmas si es necesario
....................   //      4.3 Mostrar por pantalla
....................   //      4.4 EnvÃ­o de datos
.................... 
.................... 
....................   //1.
....................   //init_BT();
....................   lcdi2cinit();
00F96:  CALL    78C
....................   BEEP_Init();
*
00F9A:  CALL    830
....................   //sd_init();
.................... 
....................   //2. Menu bienvenida
....................   initmenu();
*
00F9E:  CALL    8D2
....................   while(input(BTOK))
*
00FA2:  BSET.B  2C0.7
00FA4:  NOP     
00FA6:  BTSS.B  2C2.7
00FA8:  BRA     FB4
....................   {
....................     delay_ms(50);
00FAA:  MOV     #32,W0
00FAC:  CALL    732
*
00FB0:  GOTO    FA2
....................   }
....................   while(!input(BTOK)) // para evitar rebotes y finalizar el programa
*
00FB4:  BSET.B  2C0.7
00FB6:  NOP     
00FB8:  BTSC.B  2C2.7
00FBA:  BRA     FC6
....................   {
....................     delay_ms(50);
00FBC:  MOV     #32,W0
00FBE:  CALL    732
*
00FC2:  GOTO    FB4
....................   }
.................... 
.................... 
....................   //3. Inicializar algoritmo, adc y timer2 a 250 Hz
....................   adcinit();
*
00FC6:  CALL    978
....................   setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8, 1843); // 7370000/2/8/1843 = 4 ms
*
00FCA:  CLR     110
00FCC:  MOV     #733,W4
00FCE:  MOV     W4,10C
00FD0:  MOV     #8010,W4
00FD2:  MOV     W4,110
.................... 	setup_timer5(TMR_INTERNAL | TMR_DIV_BY_8, 1843); // 7370000/2/8/1843 = 4 ms
00FD4:  CLR     120
00FD6:  MOV     #733,W4
00FD8:  MOV     W4,11C
00FDA:  MOV     #8010,W4
00FDC:  MOV     W4,120
....................   init_algoritmo();
00FDE:  CALL    990
.................... 
....................   //Mostrar pantalla de frecuencia
....................   display_frecuencia();
*
00FE2:  CALL    9D4
....................   delay_ms(4); // que al menos se ejecute el algoritmo una vez para no tener valores raros
*
00FE6:  REPEAT  #3992
00FE8:  NOP     
.................... 
....................   //4. Bucle del programa
....................   while(input(BTOK))
00FEA:  BSET.B  2C0.7
00FEC:  NOP     
00FEE:  BTSS.B  2C2.7
00FF0:  BRA     10DA
....................   {
.................... 
....................     //4.1 Generar alarmas si es necesario
....................     if(ppm>=250 || ppm<=35)
00FF2:  MOV     3BB8,W0
00FF4:  MOV     #FA,W4
00FF6:  CP      W4,W0
00FF8:  BRA     GTU,FFC
00FFA:  BRA     1004
00FFC:  MOV     3BB8,W0
00FFE:  MOV     #23,W4
01000:  CP      W4,W0
01002:  BRA     NC,1058
....................     {
....................       if(peligro_flag_ant==0) // si no ha habido peligro antes hay que actualizar la pantalla y el buzzer
01004:  MOV     3BE0,W4
01006:  BTSC    W4.1
01008:  BRA     104E
....................       {
.................... 				if(ppm>=250) // caso alto
0100A:  MOV     3BB8,W0
0100C:  MOV     #FA,W4
0100E:  CP      W4,W0
01010:  BRA     GTU,102C
.................... 				{
.................... 					if(!altas) // Solo actualizar pantalla si corresponde
01012:  MOV     3BE0,W4
01014:  BTSC    W4.2
01016:  BRA     102C
.................... 					{
.................... 						display_alarma_alto();
01018:  CALL    AA8
.................... 						altas=1;
*
0101C:  MOV     3BE0,W0
0101E:  BSET.B  0.2
01020:  MOV     W0,3BE0
.................... 						bajas=0;
01022:  MOV     3BE0,W0
01024:  BCLR.B  0.3
01026:  MOV     W0,3BE0
.................... 						ON(BUZZER);
01028:  BCLR.B  2D0.6
0102A:  BSET.B  2D4.6
.................... 					}
.................... 				}
.................... 				if(ppm<=35) // caso bajo
0102C:  MOV     3BB8,W0
0102E:  MOV     #23,W4
01030:  CP      W4,W0
01032:  BRA     NC,104E
.................... 				{
.................... 					if(!bajas)
01034:  MOV     3BE0,W4
01036:  BTSC    W4.3
01038:  BRA     104E
.................... 					{
.................... 						display_alarma_bajo();
0103A:  CALL    AFA
.................... 						bajas=1;
*
0103E:  MOV     3BE0,W0
01040:  BSET.B  0.3
01042:  MOV     W0,3BE0
.................... 						altas=0;
01044:  MOV     3BE0,W0
01046:  BCLR.B  0.2
01048:  MOV     W0,3BE0
.................... 						ON(BUZZER);
0104A:  BCLR.B  2D0.6
0104C:  BSET.B  2D4.6
.................... 					}
.................... 				}
....................       }
....................       peligro_flag=1;
0104E:  MOV     3BE0,W0
01050:  BSET.B  0.0
01052:  MOV     W0,3BE0
.................... 
....................     }//fin bloque de alarmas
01054:  GOTO    10B8
.................... 
.................... 
.................... 		//4.2 Mostrar por pantalla en funcionamiento normal
....................     else
....................     {
....................       if(peligro_flag_ant) // si antes ha habido peligro pero ahora no. hay que actualizar pantalla y apagar el buzzer
*
01058:  MOV     3BE0,W4
0105A:  BTSS    W4.1
0105C:  BRA     1066
....................       {
....................         display_frecuencia();
0105E:  CALL    9D4
.................... 				OFF(BUZZER);
*
01062:  BCLR.B  2D0.6
01064:  BCLR.B  2D4.6
....................       }
....................       peligro_flag=0; // actualizar flag
01066:  MOV     3BE0,W0
01068:  BCLR.B  0.0
0106A:  MOV     W0,3BE0
.................... 			bajas=0;
0106C:  MOV     3BE0,W0
0106E:  BCLR.B  0.3
01070:  MOV     W0,3BE0
.................... 			altas=0;
01072:  MOV     3BE0,W0
01074:  BCLR.B  0.2
01076:  MOV     W0,3BE0
.................... 
.................... 			if(ppm!=ppm_anterior) // mostrar por pantalla si ha cambiado el valor
01078:  MOV     3BB8,W0
0107A:  MOV     3BEC,W4
0107C:  CP      W4,W0
0107E:  BRA     Z,10B8
.................... 			{
.................... 				sprintf(ppm_string,"%d  ",ppm); // crear cadena con espacios para borrar el valor anterior
01080:  MOV     #3BE2,W4
01082:  MOV     W4,3BDE
01084:  MOV     3BB8,W0
01086:  MOV     #0,W4
01088:  CALL    B54
*
0108C:  MOV.B   #20,W0L
0108E:  CALL    B42
*
01092:  MOV.B   #20,W0L
01094:  CALL    B42
.................... 				LCD_cursor_at(0,16);
*
01098:  MOV     3C28,W0
0109A:  MOV.B   #0,W0L
0109C:  MOV     W0,3C28
0109E:  MOV     3C28,W0
010A0:  SWAP    W0
010A2:  MOV.B   #10,W0L
010A4:  SWAP    W0
010A6:  MOV     W0,3C28
010A8:  CALL    84A
.................... 				LCD_write(ppm_string);
*
010AC:  MOV     #3BE2,W4
010AE:  MOV     W4,3C28
010B0:  CALL    86A
.................... 				ppm_anterior=ppm; 							// actualizar pulsaciones anteriores
*
010B4:  PUSH    3BB8
010B6:  POP     3BEC
.................... 			}
....................     }
.................... 
....................     //4.3 Enviar datos y escribir cada x segundos
....................     if(datos_flag)
010B8:  BTSS.B  1CF0.1
010BA:  BRA     10C6
....................     {
....................       enviar_datos(ppm);
010BC:  PUSH    3BB8
010BE:  POP     3BEE
010C0:  CALL    D84
.................... 			
.................... 			//sd_init_global();
.................... 			//escritura_sd();
.................... 			datos_flag=0;
*
010C4:  BCLR.B  1CF0.1
.................... 		}
.................... 
....................     //fin del bucle
....................     peligro_flag_ant=peligro_flag;
010C6:  MOV     3BE0,W4
010C8:  BCLR.B  8.1
010CA:  MOV     3BE0,W3
010CC:  BTSC    W3.0
010CE:  BSET.B  8.1
010D0:  PUSH    3BE0
010D2:  MOV.B   W4L,[W15-#2]
010D4:  POP     3BE0
010D6:  GOTO    FEA
....................   }
.................... 
.................... 	//fin de programa
.................... 	display_final();
*
010DA:  CALL    DFA
.................... }
.................... 
*
010DE:  BRA     10DE

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: 0000  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: 0000  
   Word  3L: 0007   NOWRT NOPROTECT
          H: 0000  
   Word  4L: 0007   FRC_PS NOIESO
          H: 0000  
   Word  5L: 0063   NOPR OSCIO IOL1WAY CKSNOFSM
          H: 0000  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: 0000  
   Word  7L: 00F7   PUT128 NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: 0000  
   Word  8L: 0043   ICSP1 NOJTAG DEBUG
          H: 0000  

   Some fuses have been forced to be compatible with the ICD debugger.
